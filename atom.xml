<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>libreliu&#39;s blog</title>
  
  
  <link href="https://blog.libreliu.info/atom.xml" rel="self"/>
  
  <link href="https://blog.libreliu.info/"/>
  <updated>2022-08-25T17:30:19.431Z</updated>
  <id>https://blog.libreliu.info/</id>
  
  <author>
    <name>Libre Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>让 Hexo 支持内联 LaTeX 数学公式的 Markdown</title>
    <link href="https://blog.libreliu.info/towards-math-markdown/"/>
    <id>https://blog.libreliu.info/towards-math-markdown/</id>
    <published>2022-08-25T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<p>经过一周多陆陆续续的折腾，到<a href="https://github.com/libreliu/libreliu.github.io/commit/627caa945440bed93a3fe69a90a932a84f7dceb0">现在</a>本博客基本实现了博客 Markdown 渲染和 Typora, VSCode 等的默认预览中数学公式的表现一致。</p><blockquote><p>Note: 大于号（<code>&gt;</code>）小于号（<code>&lt;</code>）目前没有做额外的转义（它们本身是 HTML 标签的结束和开始），但是这个用 <code>\lt</code> 和 <code>\gt</code> 就行了，所以有点懒得改。</p><p>如果要改的话，就对 <code>math</code> 的处理加上这两个东西的 escape 就好，MathJaX 本身会识别出 <code>&amp;lt;</code> 和 <code>&amp;gt;</code> 的。</p></blockquote><p>简单来说，我分别魔改了 <a href="https://github.com/libreliu/marked">marked</a> 和 <a href="https://github.com/libreliu/hexo-renderer-marked-math">hexo-renderer-marked</a> 两个包，实现了内联 LaTeX 的正确 Tokenize 和 Renderer (i.e. 什么也不做，原样输出)，再由浏览器里运行的 <a href="https://github.com/libreliu/libreliu.github.io/commit/9523cf2ec2de2888fee50f2e9925313f96da5a35">MathJaX 3</a> 来进行 LaTeX 渲染。</p><p>魔改后的版本支持块公式 (block math) <code>$$ ... $$</code> 和内联公式 (inline math) <code>$ ... $</code>，并且内联公式内部的 <code>_</code> 不会和 Markdown 对 <code>_</code> 的使用冲突。</p><p>下面是渲染 Maxwell 方程组的示例：</p>$$\begin{aligned}\nabla \cdot \mathbf{E} &= \frac {\rho} {\varepsilon_0} \\\nabla \cdot \mathbf{B} &= 0 \\\nabla \times \mathbf{E} &= -\frac{\partial \mathbf{B}} {\partial t} \\\nabla \times \mathbf{B} &= \mu_0\left(\mathbf{J} + \varepsilon_0 \frac{\partial \mathbf{E}} {\partial t} \right) \end{aligned}$$<p>上面的 $ \mathbf{E} $ 是电场强度，$ \mathbf{B} $ 是磁感应强度，$ \mu_0$ 是真空磁导率，$ \epsilon_0 $ 是真空介电系数。</p><blockquote><p><code>marked</code> 是 <code>hexo-renderer-marked</code> 使用的 Markdown 渲染器，它负责把 Markdown 渲染成 HTML。</p></blockquote><h2 id="为什么要新造一个轮子？"><a href="#为什么要新造一个轮子？" class="headerlink" title="为什么要新造一个轮子？"></a>为什么要新造一个轮子？</h2><p>Google 一圈，现在有的 Hexo 内联 LaTeX 的方案都不是很让人满意：</p><ol><li><code>hexo-renderer-kramed</code> 使用的 <code>kramed</code> 从 2016 年开始已经没有再更新了</li><li><code>marked</code> 表示不会加入对 <code>$ ... $</code> 和 <code>$$ ... $$</code> 的支持 (<a href="https://github.com/markedjs/marked/issues/722">markedjs&#x2F;marked, Issue #722</a>)</li><li><code>hexo-renderer-pandoc</code> 需要用户自己安装 <code>pandoc</code>，<code>pandoc</code> 本身很庞大，并且是 Haskell 编写，本文作者表示改不动；另外，直接 out-of-box 的装上之后，块公式 <code>pandoc</code> 总是会多生成 <code>\[ ... \]</code> 的 pair，决定弃坑</li><li>网络上还存在一些 patch 方案，比如<a href="https://alexsixdegrees.github.io/2017/03/11/letaxinmarkdown/">这里</a>，直接把 <code>marked</code> 的 inline rule 改掉，让其不再将 <code>_</code> 作为合法的强调标志（比如 <code>_asdf_</code> 之类就不会渲染成 <em>asdf</em> 了）</li><li>其实也可以 <em>摆大烂</em>，把所有 LaTeX 和 Markdown 冲突的关键字都用反斜杠转义掉</li></ol><p>可以看到都不是太优雅。</p><h2 id="改动简介"><a href="#改动简介" class="headerlink" title="改动简介"></a>改动简介</h2><blockquote><p>其实一开始想给 <code>hexo-renderer-marked</code> 写插件，但是它只支持 extend <code>Tokenizer</code> 和 <code>Renderer</code>，把那些乱七八糟规则再写一遍又很难维护，所以最后放弃了这个想法。</p></blockquote><p>主要是对 <code>marked</code> 进行改动，让其支持 <code>$$ .. $$</code> 和 <code>$ .. $</code> 的 Tokenize，并且能无转义的输出。</p><p><code>marked</code> 采用正则表达式不断匹配的方式进行词法分析，对于部分块对象会继续进行行内的词法分析。词法分析后的 Toekn 流会送到 Renderer 进行输出。</p><p>详细可以看 <a href="https://github.com/libreliu/marked">libreliu&#x2F;marked</a> 上面的提交。</p><p>由于人比较懒，没有在 npm 上加自己的包，而是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install github:libreliu/hexo-renderer-marked-math#master --save</span><br></pre></td></tr></table></figure><p>这个的缺点是每次 <code>npm update hexo-renderer-marked-math</code> 都要重新拉，并且版本管理上不是很友好。不过只是自己用的话其实无所谓。</p><h2 id="（作为菜鸡）踩过的坑"><a href="#（作为菜鸡）踩过的坑" class="headerlink" title="（作为菜鸡）踩过的坑"></a>（作为菜鸡）踩过的坑</h2><ol><li><p>NodeJS 的 <code>require</code> 在找不到 <code>index.js</code> 时，会去 <code>package.json</code> 中查找 <code>main</code> 字段，并且加载对应的模块。</p><p>可以注意到，<code>marked</code> 的 <code>main</code> 是 <code>./lib/marked.cjs</code>，这个文件需要运行 <code>npm run build</code> 生成。</p></li><li><p>调试 Promise 链可以采用 Bluebird 的<a href="http://bluebirdjs.com/docs/api/promise.longstacktraces.html">Promise.longStackTraces()</a>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过一周多陆陆续续的折腾，到&lt;a href=&quot;https://github.com/libreliu/libreliu.github.io/commit/627caa945440bed93a3fe69a90a932a84f7dceb0&quot;&gt;现在&lt;/a&gt;本博客基本实现了博客 M</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Slang</title>
    <link href="https://blog.libreliu.info/paper-reading/slang-shader-framework/"/>
    <id>https://blog.libreliu.info/paper-reading/slang-shader-framework/</id>
    <published>2022-07-30T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证<strong>没有额外性能损失</strong>的情况下，解决现代游戏引擎和实时渲染应用中出现的，不同光源 &#x2F; 材质组合出现的 Shader 代码膨胀、晦涩难懂的基于宏的复用等问题。</p><p>Slang 针对原 HLSL，主要增加了以下的新特性：</p><ol><li>带可选成员类型约束的接口系统 (Interfaces)<ul><li>以及 <code>extension</code> 关键字来覆盖接口系统的默认行为，提供最大灵活性</li></ul></li><li>泛型系统 (Generics)</li><li>显式参数块 (Explicit Parameter Blocks)</li><li>Slang 编译器和提供运行时类型特化支持的编译器运行时 API</li><li>(论文发表后新增) 语法糖和其它易用性改进<ul><li>类 C# 的 getter&#x2F;setter 语法糖</li><li>运算符重载</li><li>模块系统</li></ul></li><li>(论文发表后新增) CUDA, OptiX 等非传统 Shader 编译目标</li></ol><p>从上面可以看出，Slang 自论文发布后还存在有功能演进，说明作为 Shader 语言本身还是有一定生命力的。</p><p>截至 2022 年 7 月 31 日，<a href="https://github.com/shader-slang/slang">Slang 的 GitHub 仓库</a> 共有 978 个 Star，235 Open Issue 和 284 Closed Issue，最后一次提交在两天前，证明项目还是比较活跃的。</p><blockquote><p>Note: 据我浅薄的了解，HLSL 也在不断迭代新的功能，如 <a href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">HLSL 2021</a> 的 <code>template</code> 泛型支持等。<del>不过 GLSL 好像没啥大动作</del>(?)</p></blockquote><h2 id="Slang-语言特性介绍"><a href="#Slang-语言特性介绍" class="headerlink" title="Slang 语言特性介绍"></a>Slang 语言特性介绍</h2><h3 id="接口系统-Interfaces"><a href="#接口系统-Interfaces" class="headerlink" title="接口系统 (Interfaces)"></a>接口系统 (Interfaces)</h3><p>Slang 的接口表示一种约定，比如约定里面会有某种特定函数原型的函数实现，某种特定的成员结构体等，与 “traits” 的语言概念比较接近。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare that MyType have conformance to interface IFoo</span></span><br><span class="line"><span class="keyword">struct</span> MyType : IFoo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)arg + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型系统-Generics"><a href="#泛型系统-Generics" class="headerlink" title="泛型系统 (Generics)"></a>泛型系统 (Generics)</h3><p>泛型系统可以实现同时支持不同类型实例的函数。特别的，可以约束传入的形参类型为实现某种接口的类型，如下面的 <code>myGenericMethod</code> 约束 <code>T</code> 为实现 <code>IFoo</code> 接口的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define</span></span><br><span class="line"><span class="type">int</span> myGenericMethod&lt;T: IFoo&gt;(T arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.myMethod(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke</span></span><br><span class="line">MyType obj;</span><br><span class="line"><span class="type">int</span> a = myGenericMethod&lt;MyType&gt;(obj); <span class="comment">// OK, explicit type argument</span></span><br><span class="line"><span class="type">int</span> b = myGenericMethod(obj); <span class="comment">// OK, automatic type deduction</span></span><br></pre></td></tr></table></figure><p>同时，Slang 还支持类似 C++ 的非类型模板形参的泛型参数输入，比如下面的 <code>N</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Array&lt;T, <span class="keyword">let</span> N : <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T arrayContent[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数，<code>struct</code> 等语言组件都支持泛型。</p><blockquote><p>Note: HLSL 本身就支持作为 struct 的 arg 拥有成员函数。</p></blockquote><h3 id="显式参数块-Explicit-Parameter-Blocks"><a href="#显式参数块-Explicit-Parameter-Blocks" class="headerlink" title="显式参数块 (Explicit Parameter Blocks)"></a>显式参数块 (Explicit Parameter Blocks)</h3><blockquote><p>这个特性在 Slang 官方的语言文档中没有着重强调，主要是在 Slang 的这篇论文中强调了。</p></blockquote><p>现代图形 API（D3D12, Vulkan）对于 Shader 的输入参数是以 “parameter block” 的形式来组织的（例：Vulkan 中术语为 Descriptor Set），一个 Shader 的输入可以由多个 Descriptor Set 组成。</p><p>考虑到场景的绘制过程中，有一部分 Shader 参数是不变的（比如同一个绘制到主 RenderTarget 的 Pass 中摄像机的位置），那么把这些不变的参数单独拿出来组织成一个 Parameter Block，把剩下的一些变化频率不太一致的另一些参数（比如模型的 <code>modelMatrix</code>）拿出来作为一个或多个 Parameter Block 的话，就可以降低一部分绘制时的开销。</p><p>但是手工组织 Shader 的 layout（特别是对于不同的材质，我们有不同的 Shader 要用）是比较繁琐的，Slang 则对这个 Parameter Binding 和 Parameter Block 有专门的设计（<code>Shader Parameters</code>），可以方便的自动推导符合程序员设计要求的 layout 和 block。</p><h3 id="编译器和运行时-API"><a href="#编译器和运行时-API" class="headerlink" title="编译器和运行时 API"></a>编译器和运行时 API</h3><p>Slang 提供了功能丰富的运行时 API，其功能经过一些演进和论文中描述的也不是特别一致了。</p><p>Slang 的运行时 API 大概提供了如下机制：</p><ol><li>运行时 Shader 编译和特化 API<ul><li>比如，运行时要对新的材质类型重新编译 Shader，就可以使用这些 API</li></ul></li><li>反射机制<ul><li>可以获得某段 Slang Shader 中的函数、Shader 入口参数等信息</li></ul></li></ol><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>Slang 的文档中描述了不少 Slang 的语法糖和易用性改进。</p><h4 id="类似-C-的-getter-x2F-setter-语法糖"><a href="#类似-C-的-getter-x2F-setter-语法糖" class="headerlink" title="类似 C# 的 getter &#x2F; setter 语法糖"></a>类似 C# 的 getter &#x2F; setter 语法糖</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">uint</span> flag;</span><br><span class="line"></span><br><span class="line">    property <span class="built_in">uint</span> highBits</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> flag &gt;&gt; <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; flag = (flag &amp; <span class="number">0xFF</span>) + (newValue &lt;&lt; <span class="number">16</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基于全局函数的运算符重载"><a href="#基于全局函数的运算符重载" class="headerlink" title="基于全局函数的运算符重载"></a>基于<strong>全局函数</strong>的运算符重载</h4><blockquote><p>HLSL 2021 支持了基于<strong>成员函数</strong>的运算符重载：[Announcing HLSL 2021</p><ul><li>DirectX Developer Blog](<a href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">https://devblogs.microsoft.com/directx/announcing-hlsl-2021/</a>)</li></ul><p>而 GLSL 截至 2022 年 7 月 31 日还在咕咕：<a href="https://github.com/KhronosGroup/GLSL/issues/107">Operator overloading · Issue #107 · KhronosGroup&#x2F;GLSL</a></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    __init(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyType <span class="keyword">operator</span>+(MyType a, MyType b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MyType(a.val + b.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyType rs = MyType(<span class="number">1</span>) + MyType(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rs.val; <span class="comment">// returns 3.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h4><p>Slang 支持一个简单的模块机制，可以把要 import 的目标模块（就是一个 .slang 的 Slang Shader）中的定义导入当前单元。如果该模块此时再被其它模块 import 的话，这些被导入的模块是不会导入到它的“上一层”的单元中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyShader.slang</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的导入</span></span><br><span class="line"><span class="keyword">import</span> YourLibrary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以导入时覆盖前面描述的行为</span></span><br><span class="line">__export <span class="keyword">import</span> SomeOtherModule;</span><br></pre></td></tr></table></figure><h2 id="重构-Falcor-渲染器"><a href="#重构-Falcor-渲染器" class="headerlink" title="重构 Falcor 渲染器"></a>重构 Falcor 渲染器</h2><p>Falcor 是一个基于 D3D12 的实时渲染器。</p><blockquote><p>根据 README，Vulkan 实验性支持在进行中。</p></blockquote><p>作者从 Falcor 的 2.0.2 版本出发，重构了 5400 行着色器代码。</p><p>改进主要集中在如下方面：</p><ol><li><p>将一个大的 Parameter Block 拆分成 per-material 的 block</p></li><li><p>Falcor 原来的 Material 采用层次化的设计，每一层 (e.g. GGX, Lambertian, Phong) 都和下一层进行 blend，而渲染时，根据不同的 material 要 dispatch 不同的 shader 时，采用了很多 <code>#define</code> 和基于文本的 Shader Varient Cache 的查询环节。</p><p>作者重构时将这套系统用 Slang 的泛型系统重构，并且将标准材质的 Varient 用非类型形参编码成了若干个 int，进而加快了查询速度。</p></li><li><p>针对与 Material 类似的技术，实现了光源上的特化，在场景中只有某种类型光源的时候采用静态特化好的 Shader 变体，减少运行时判断的开销</p></li></ol><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>通过重构 Falcor 渲染器，在 NVIDIA 的 ORCA 场景上的测试表明</p><ul><li>每帧 CPU 执行时间降低了 30%</li><li>光源和材料特化改进对部分场景的 GPU 时间有加速作用</li></ul><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>作者分别在重构前和重构后的 Falcor 上实现了（基于 LTC 方法的）多边形面光源，</p><ul><li>重构前：需要改动 7 处，4 个文件，246 行</li><li>重构前，但加入光源分离机制：需要改动 8 处，5 个文件，253 行</li><li>重构后：只需要改动 1 处，1 个文件，249 行</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p>We believe that all real-time graphics programmers could benefit from<br>a new generation of shader compilation tools informed by these<br>ideas. —— <em>Slang: language mechanisms for extensible real-time shading systems</em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证&lt;strong&gt;没有额外性能损失&lt;/strong&gt;的情况下，解决现代游戏引擎和实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields</title>
    <link href="https://blog.libreliu.info/paper-reading/ddgi/"/>
    <id>https://blog.libreliu.info/paper-reading/ddgi/</id>
    <published>2022-07-22T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章提供了一种高效的计算动态物体和动态光源情形下的全局光照的方法。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="DDGI-light-probe"><a href="#DDGI-light-probe" class="headerlink" title="DDGI light probe"></a>DDGI light probe</h3><p>DDGI 是一种利用 light probe（光照探针）进行动态全局光计算的方法。</p><p>对于位于 $\mathrm{x’}$ 位置的 light probe，所有的出射方向可以视为从 probe 所在位置到以 probe 所在位置为中心的单位球面上点构成的向量的集合。此时，构造一个 $S^2 \to R^2$ 的映射，使得球面的八个扇区分别映射到八面体的八个面上，这个映射被称为八面体映射 (octahedron mapping)。</p><blockquote><p>文章中描述到，八面体映射的好处，在于可以将球面以比较均匀的参数化映射到正方形上去，方便之后将每个方向相对应的量储存到 2D 纹理上面去。</p></blockquote><p>通过八面体映射，就可以将 probe 每个方向的信息存储在正方形的纹理贴图上了。</p><p>不过，在这篇文章中，出于性能考虑，作者采用了类似 Variance Shadow Mapping 的方法，极大压缩了纹理贴图的分辨率，同时对于每个 probe 的贴图的每个方向，分别存放</p><ol><li>$E_i(\mathrm{x'}, w)$: probe 以 $\omega$ 方向为天顶的半球的入射 irradiance</li><li>$r(\omega)$: probe 在 $\omega$ 方向对应的最近邻图元的距离在半球面的均值<ul><li>也就是 $\int d(x’, \omega) d \omega$，其中 $d(x, \omega): R^3 \times \Omega \to R$ 为在 $x$ 处沿 $\omega$ 方向到最近邻图元的距离</li></ul></li><li>$r^2(\omega)$: probe 在 $\omega$ 方向对应的最近邻图元的距离的平方在半球面的均值</li></ol><p>三组信息。</p><blockquote><p>Recall: radiance 和 irradiance</p><ul><li>Radiance (辐射率): 单位面积单位立体角辐射功率，$ d\Phi &#x2F; (dS d\Omega) $</li><li>Irradiance (辐照度): 单位面积辐射功率 $ d\Phi &#x2F; dS $</li></ul></blockquote><h3 id="利用-probe-进行间接光计算"><a href="#利用-probe-进行间接光计算" class="headerlink" title="利用 probe 进行间接光计算"></a>利用 probe 进行间接光计算</h3><p>前面提到 probe 中存储的信息为 probe 所在位置中各个方向的入射 irradiance。如果把场景中各处的 irradiance 看成一个 irradiance 场，那么现在要处理的问题就是给定场在某些位置的值，插值出其他位置的值的过程。</p><p>对于漫反射，只需要关心入射 irradiance 而不需要具体的 radiance，所以只需要待着色图元的全局光入射 irradiance 信息。</p><p>irradiance 场大概可以这样描述：$R^3 \times S^2 \to Spectrum$</p><p>输入是 (位置, 方向)，输出是 Spectrum (e.g. RGBSpectrum)</p><p>可以想象到，如果场本身的变化相对于 probe 间距离来说变化比较缓慢，那么方法就会工作的比较好。</p><p>不过，也有一些会导致变化较快的情况：</p><ol><li>图元本身与 probe 所成夹角</li><li>图元被某些物体遮挡</li></ol><p>所以，DDGI 提出了这样的框架来进行着色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float3 n = shading normal, X = shading point, P = probe location</span></span><br><span class="line">float4 irradiance = float4(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (each of <span class="number">8</span> probes around X) &#123;</span><br><span class="line">    float3 dir = P – X;</span><br><span class="line">    <span class="type">float</span> r = <span class="built_in">length</span>(dir);</span><br><span class="line">    dir *= <span class="number">1.0</span> / r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smooth backface</span></span><br><span class="line">    <span class="type">float</span> weight = (<span class="built_in">dot</span>(dir, n) + <span class="number">1</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjacency</span></span><br><span class="line">    weight *= trilinear(P, X);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// visibility (Chebyshev)</span></span><br><span class="line">    float2 temp = <span class="built_in">texelFetch</span>(depthTex, probeCoord).rg;</span><br><span class="line">    <span class="type">float</span> mean = temp.r, mean2 = temp.g;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mean) &#123;</span><br><span class="line">        <span class="type">float</span> variance = <span class="built_in">abs</span>(square(mean) – mean2);</span><br><span class="line">        weight *= variance / (variance + square(r – mean));</span><br><span class="line">    &#125;</span><br><span class="line">    irradiance += <span class="built_in">sqrt</span>(<span class="built_in">texelFetch</span>(colorTex, probeCoord) * weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> square(irradiance.rgb * (<span class="number">1.0</span> / irradiance.a));</span><br></pre></td></tr></table></figure><blockquote><p><code>irradiance.a</code> 的作用是什么..？</p><p>很多权重我理解是为了视觉效果，应该和物理正确没什么太大关系…</p><p>这里的也不是最终的版本（还要加上 normal bias），slides 里面提供了更加魔改的版本，不知道 RTXGI 里面是不是有更进一步的魔改</p></blockquote><h4 id="Chebyshev-项分析"><a href="#Chebyshev-项分析" class="headerlink" title="Chebyshev 项分析"></a>Chebyshev 项分析</h4><p>Chebyshev 不等式 (one-tailed version)：</p>$$P(x > t) \le \frac{\sigma^2}{\sigma^2 + (t-\mu)^2}$$<blockquote><p>可以参考 GAMES202 中<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_04.pdf">关于 Variance Soft Shadow Mapping 的部分</a></p></blockquote><p>相当于小于平均值时认为没有遮挡，大于平均值时按 Chebyshev 不等式的上界来估算被遮挡概率。</p><blockquote><p>有没有更好的估计方法？为什么这样估计是最好的？</p></blockquote><h3 id="各个项效果对比"><a href="#各个项效果对比" class="headerlink" title="各个项效果对比"></a>各个项效果对比</h3><p>原论文中有各项的作用展示：</p><img src="/paper-reading/ddgi/ddgi_term_comparation.png" class="" title="DDGI Term Comparation"><p>其中 classic irradiance probe 应该就是只有三线性插值的结果。</p><h3 id="动态更新-probe-信息"><a href="#动态更新-probe-信息" class="headerlink" title="动态更新 probe 信息"></a>动态更新 probe 信息</h3><p>每一帧，DDGI 会进行如下的操作：</p><ol><li>从 $m$ 个活跃 probe 中，每个 probe 发射 $n$ 条光线，然后存储 $n \times m$ 个交点处的表面元信息（位置，法线）到一个类似 G-buffer 的结构中<ul><li>发射光线时采用每帧不同的 pattern，最大限度避免锯齿<ul><li>作者采用 “stochastically-rotated Fibonacci spiral pattern”<blockquote><p>不过作者 2017 年的文章中并没有详细说明此处的具体实现，需要阅读作者的代码</p></blockquote></li></ul></li></ul></li><li>对表面元信息进行直接光和间接光计算<ul><li>直接光：<ul><li>点光源和方向光光源：利用该 G-buffer 进行普通的 deferred rendering + variance shadow mapping</li><li>面积光光源：使用下面间接光方法，第一跳时考虑面积光</li></ul></li><li>间接光：采用周围的 probe 信息进行计算<ul><li>和前面一节描述的方法一致</li></ul></li><li>(多跳)间接光：通过 3 中每次用 Moving Average 方法来更新，实现多跳的信息传播</li></ul></li><li>更新这 $m$ 个活跃 probe 对应的纹理贴图<ul><li>利用 alpha-blending, $\alpha$ 取 0.85 到 0.98</li><li><code>newIrradiance[texelDir] = lerp(oldIrradiance[texelDir], Sum(ProbeRays(max(0,texelDir · rayDir) ∗ rayRadiance)...), alpha)</code></li></ul></li></ol><blockquote><p>符号说明: <code>lerp(a, b, alpha) = a * alpha + b * (1-alpha)</code></p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><a href="https://research.nvidia.com/sites/default/files/pubs/2017-02_Real-Time-Global-Illumination/light-field-probes-final.pdf">Real-Time Global Illumination using Precomputed Light Field Probes</a><ul><li>McGuire 这篇 2017 年的工作中关于 GI 的部分和这篇文章很像，只是当时他在 light probe 中存储比较高分辨率的最近邻图元到 probe 距离，并且用这个距离来进行基于 probe 阵列的 ray trace，而不是采用硬件 ray trace。</li><li>并且他在这篇工作中提到，可以采用将 BSDF 分解成 diffuse + glossy (所有不 diffuse 的项)，对 glossy 用其它方法来处理 (比如 raytrace + post filter) 来实现整个场景的 GI。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章提供了一种高效的计算动态物体和动态光源情形下的全局光照的方法。&lt;/p&gt;
&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试嵌套 ul 和 li</title>
    <link href="https://blog.libreliu.info/test-ul-nested/"/>
    <id>https://blog.libreliu.info/test-ul-nested/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<p>这是一些正常的测试文本。</p><ul><li>first class ul<ul><li>second class ul<ul><li>third class ul</li></ul></li></ul></li></ul><ol><li>测试 first class li<br>测试缩进后文字显示<ul><li>测试 inner class ul<ul><li>测试更内部显示</li></ul></li></ul></li><li>测试 first class li<br>测试缩进后文字显示<ul><li>测试 inner class ul<ul><li>测试更内部显示</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一些正常的测试文本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;first class ul&lt;ul&gt;
&lt;li&gt;second class ul&lt;ul&gt;
&lt;li&gt;third class ul&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;测试 fi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | EARS</title>
    <link href="https://blog.libreliu.info/paper-reading/ears/"/>
    <id>https://blog.libreliu.info/paper-reading/ears/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了一种在离线渲染中优化 Path Tracing 中 Russian Roulette 和 Splitting 的方法。</p><p>首先，Splitting 即在 Path Tracing 的过程中，到某个 bounce 后，分叉出多条光线进行 trace，最后计算该点光照贡献时按权重进行平均的一种技术。</p><p>作为例子，考虑如下的场景（图源论文）：</p><img src="/paper-reading/ears/pool-scene.png" class="" title="pool-scene"><p>该场景中，池底的表面为漫反射材质，但是路径中其它的部分的 BSDF &#x2F; BRDF 都比较趋向于 Delta 分布。这时，如果可以在绿色点进行 Splitting，对不需要 Splitting 的路径实现复用，就可以帮助以更小的开销实现较低方差的渲染。</p><p>在每次 bounce 时，PathTracer 都需要进行一个决策：</p><ul><li>(Russian Roulette) 是否需要截止这条光线？以多少概率截止？</li><li>(Splitting) 是否需要将这条光线分裂成多份？如果需要的话，分裂成多少份？</li></ul><p>这些因子显然是和场景相关的，而选择好这些因子可以加速 Path Tracing 的收敛过程。</p><h2 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h2><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了一种在离线渲染中优化 Path Tracing 中 Russian Roulette 和 Splitting 的方法。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Generalized RIS</title>
    <link href="https://blog.libreliu.info/paper-reading/gris/"/>
    <id>https://blog.libreliu.info/paper-reading/gris/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要是扩展了 ReSTIR 和 ReSTIR GI 中用到的 Resampled Importance Sampling 在图形学中的理论基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要是扩展了 ReSTIR 和 ReSTIR GI 中用到的 Resampled Importance Sampling 在图形学中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | ReSTIR GI</title>
    <link href="https://blog.libreliu.info/paper-reading/restir-gi/"/>
    <id>https://blog.libreliu.info/paper-reading/restir-gi/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要将 ReSTIR 这种采样增强方法扩展到了间接光照上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要将 ReSTIR 这种采样增强方法扩展到了间接光照上。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Neural Radiance Caching</title>
    <link href="https://blog.libreliu.info/paper-reading/nrc/"/>
    <id>https://blog.libreliu.info/paper-reading/nrc/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了用于实时渲染的神经辐射度缓存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了用于实时渲染的神经辐射度缓存。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | ReSTIR</title>
    <link href="https://blog.libreliu.info/paper-reading/restir/"/>
    <id>https://blog.libreliu.info/paper-reading/restir/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了 ReSTIR 这种用于实时渲染的采样增强方法，该方法可以处理交互式渲染中对大量光源 (&gt;&#x3D; 1k) 的直接光进行采样的问题，也可以用于实时渲染。</p><blockquote><p>注：本篇文章的官方 Slides 我感觉做的很不错，可以在他们的项目主页下载到。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="BSDF-适用的渲染方程"><a href="#BSDF-适用的渲染方程" class="headerlink" title="BSDF 适用的渲染方程"></a>BSDF 适用的渲染方程</h3>$$\begin{aligned}L_o(x, \omega_o) &= \int_\Omega f(x, \omega_i, \omega_o) L_i(x, \omega_i) \cos \theta^x_i d \omega_i \\&= \int_\mathcal{A_i} f(x, \omega_i, \omega_o) L_o(x', \omega_i) \frac{\cos \theta^x_i \cos \theta^{x'}_{o} }{| x - x' |^2} dA \qquad \text{(with light from } x' \text{)} \\&= \int_\mathcal{A_i} f(x, \omega_i, \omega_o) V(x, x') L_o(x', \omega_i) \frac{\cos \theta^x_i \cos \theta^{x'}_{o} }{| x - x' |^2} dA \\\end{aligned}$$<p>其中 $\theta^x_i$ 为 $x$ 处入射光线与 $x$ 所在表面位置法线所成角度，$\theta^{x’}_o$ 为 $x’$ 处出射光线与 $x’$ 所在表面位置法线所成角度。</p>$$V(x, x') := \left\{\begin{aligned}&1 ,& x' \text{ is visible from } x \\&0 ,& \text{otherwise}\end{aligned}\right.$$<!-- 之后可以扩展一节专门讲渲染方程，放到基础回顾部分；现在就略写一下 --><p>对于上面的积分，我们希望用一些离散的采样构成的一个估计量来进行原积分的估计。采样方式和利用采样得到的值进行运算从而构造估计量的方式被称为一种估计方法。</p><p>数理统计告诉我们，估计量也是满足一个分布的，在绝大多数时候我们通过估计量的<strong>期望</strong>和<strong>方差</strong>来衡量一个估计的好坏。</p><p>既然本篇论文是关于采样方法的改进，那么就首先回顾一下 Monte Carlo 求解渲染方程时会使用到的估计方法。</p><h3 id="简单随机抽样"><a href="#简单随机抽样" class="headerlink" title="简单随机抽样"></a>简单随机抽样</h3><p>假设我们需要估计</p>$$I := \int_\Omega f(x) dx$$<p>的值，并且我们可以<strong>等概率</strong>且<strong>独立</strong>的从 $\Omega$ 中抽取样本 ${x_i}_{i&#x3D;1}^n$，那么我们就可以构造估计量 $\bar I$</p>$$\bar I := \frac{|\Omega|}{N} \sum_{i=1}^n f(x_i)$$<p>既然 $X_i$ 是随机变量，那么我们的估计量自然也是个随机变量，它的期望 $\operatorname{E}[\bar I]$ 是</p>$$\begin{aligned}\operatorname{E}[\bar I] &= \frac{|\Omega|}{N} \sum_{i=1}^n \operatorname{E}[f(X_i)] \\&= |\Omega| \operatorname{E}[f(x_1)] & \text{(} \{X_i\} \text{ satisfy i.i.d.)} \\&= |\Omega| \int_\Omega f(x) d \mu(x) \\&= |\Omega| \int_\Omega f(x) \mu(x) dx \\&= |\Omega| \int_\Omega f(x) \frac{1}{|\Omega|} dx \\&= I\end{aligned}$$<blockquote><p>Note: 形如</p>$$\int_\Omega f(x) d\mu(x) $$<p>的积分中，$\mu(x)$ 是随机变量 $X$ 所对应的概率密度函数，在这里是均匀分布所以 $\mu(x) &#x3D; 1&#x2F;|\Omega|$ 。期望的本质就是 “$\sum x \times p(x)$”</p></blockquote><!-- 比如说我们在初等概率论中学到的随机变量，在测度论角度来讲就是一种可测函数，而初等概率论在很多计算上面是直接在取值空间进行计算的，也就是实数空间，它的很多积分的运算你放在测度论来看就是直接应用了积分变换定理。在概率论中提到的“分布”，其实就是根据这个随机变量（可测函数）在原空间和取值空间进行一个测度变换，站在这个角度去看待一些概率论问题就会感觉一切是那么合理，简直就是一种艺术。作者：再熬夜是猪链接：https://www.zhihu.com/question/29800166/answer/1884856359来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。--><p>所以积分最终会收敛，但是估计量 $\bar I$ 的方差依赖于 $f(x)$ 本身的性质：</p>$$\begin{aligned}\operatorname{Var}[\bar I] &= \frac{|\Omega|^2}{N^2} \operatorname{Var} \left[ \sum_{i=1}^{n} f(x_i) \right] \\&= \frac{|\Omega|^2}{N} \operatorname{Var}[f(x)] \\&= \frac{|\Omega|^2}{N} \left( \operatorname{E}[f(x)^2] - \operatorname{E}[f(x)]^2 \right) \\&= \frac{|\Omega|^2}{N} \left[ \int_\Omega f(x)^2 \mu(x) dx - \left( \int_\Omega f(x) \mu(x) dx \right)^2 \right] \\&= \frac{1}{N} \left[ |\Omega| \int_\Omega f(x)^2 dx - \left( \int_\Omega f(x) dx \right)^2 \right]\end{aligned}$$<p>我们观察到，后面的方括号中的内容和抽样次数 N 无关，所以只要 $\operatorname{Var}[f(X_i)]$ 有限，即可说明增加抽样次数，估计量最终可以<strong>在方差意义上</strong>收敛到原函数。</p><!-- https://math.stackexchange.com/questions/1386113/proving-that-the-variance-is-non-negative --><!-- TODO: 补一些 Var 的图 --><!-- 写一个 browser-side 画函数的工具？(大坑) --><blockquote><p>Note: </p><ol><li>$\operatorname{Var}[X] = \operatorname{E}[(X-\operatorname{E}[X])^2] = \operatorname{E}[X^2-2 \cdot X \cdot \operatorname{E}[X] + (\operatorname{E}[X])^2] = \operatorname{E}[X^2]-(\operatorname{E}[X])^2$ </li><li>$\operatorname{Var}[aX+bY] = a^2\operatorname{Var}[X] + b^2\operatorname{Var}[Y] + 2ab \operatorname{Cov}[X, Y]$</li><li>如果很严谨，还应该讨论函数具有何种性质时，方差意义上收敛的两个函数是同一个函数。（<del>不过我不会</del>）</li></ol></blockquote><h3 id="重要性采样-Importance-Sampling"><a href="#重要性采样-Importance-Sampling" class="headerlink" title="重要性采样 (Importance Sampling)"></a>重要性采样 (Importance Sampling)</h3><p>仍然假设我们需要估计</p>$$I := \int_\Omega f(x) dx$$<p>但是这次，我们选择一个连续分布，记其概率密度函数为 $p(x)$，并且我们从该分布中抽样得到样本 ${x_i}_{i&#x3D;1}^N$，我们用这些样本构造估计量 $\bar I$</p>$$\bar I := \frac{1}{N} \sum_{i=1}^n \frac{f(x_i)}{p(x_i)}$$<p>那么，</p>$$\begin{aligned}\operatorname{E}[\bar I] &= \operatorname{E}\left[\frac{f(x_1)}{p(x_1)}\right] \\&= \int_\Omega \frac{f(x)}{p(x)} p(x) dx \\&= \int_\Omega f(x) dx \\&= I\end{aligned}$$<blockquote><p>此处的推导隐含 $p(x)$ 在 $\Omega$ 上的值<strong>非零</strong>，考虑到 $p(x)$ 是概率密度函数，$p(x) &gt; 0$</p><p>不过事实上我们只需要 $p(x) &gt; 0$ 在 $\operatorname{supp}(f)$ 成立即可。</p></blockquote><p>方差：</p>$$\begin{aligned}\operatorname{Var}[\bar I]&= \frac{1}{N^2} \operatorname{Var}\left[ \sum_{i=1}^n \frac{f(x_i)}{p(x_i)} \right] \\&= \frac{1}{N} \operatorname{Var}\left[ \frac{f(x)}{p(x)} \right] \\&= \frac{1}{N} \left( \operatorname{E}\left[\left[\frac{f(x)}{p(x)}\right]^2\right] - \operatorname{E}\left[\frac{f(x)}{p(x)}\right]^2  \right) \\&= \frac{1}{N} \left[ \int_\Omega \left(\frac{f(x)}{p(x)}\right)^2 p(x) dx - \left( \int_\Omega \frac{f(x)}{p(x)} p(x) dx \right)^2 \right] \\&= \frac{1}{N} \left[ \int_\Omega \frac{f(x)^2}{p(x)} dx - \left( \int_\Omega f(x) dx \right)^2 \right] \\\end{aligned}$$<p>则加大 N 后方差可以渐进趋于 0。</p><p>如果我们可以找到概率密度函数 $p(x)$ 满足</p>$$p(x) = \frac{f(x)}{\int_\Omega f(t) \, dt}$$<p>的话，带入上面的式子可以得到</p>$$\begin{aligned}\operatorname{Var}[\bar I]&= \frac{1}{N} \left[ \left(\int_\Omega f(x) dx\right)^2 - \left( \int_\Omega f(x) dx \right)^2 \right] = 0\end{aligned}$$<p>一般的，由 $p(x)$ 决定的分布对 $f(x)$ 近似的越好，相同样本数量下估计量的方差就会越低。</p><h3 id="重采样重要性采样-Resampled-Importance-Sampling"><a href="#重采样重要性采样-Resampled-Importance-Sampling" class="headerlink" title="重采样重要性采样 (Resampled Importance Sampling)"></a>重采样重要性采样 (Resampled Importance Sampling)</h3><p>从前面的重要性采样方法中我们了解到，我们采样的 $p(x)$ 的形状越接近 $f(x)$，那么采样的效果就越好。</p><blockquote><p>所谓形状接近，就是函数贴近 ${f(x)}&#x2F;{\int_\Omega f(t) , dt}$。</p></blockquote><p>如果我们有一个很棒的分布 $\hat p(x)$，他比较接近 $f(x)$ 的形状，但是我们没法直接采样出符合 $\hat p(x)$ 分布的样本。</p><p><em>(1-sample RIS)</em> 假设我们此时还可以找到一个分布 $p(x)$，其与 $\hat p(x)$ 比较接近，那么此时，我们可以采用如下方法，采样出符合 $ \hat p(x)$ 分布的样本：</p><ol><li>从 $p(x)$ 分布中抽样得到集合 $ X &#x3D; {x_1, …, x_M } $</li><li>按如下所给的条件概率抽样一个<strong>索引</strong> $ z \in {1, …, M} $$$p(z \, | \, x_1, ..., x_M) = \frac{w(x_z)}{\sum_{i=1}^M w(x_i)} \quad \text{with} \quad w(x) = \frac{\hat p(x)}{p(x)}$$</li><li>按下式计算估计量$$\begin{aligned}\bar I^{1, M}_{ris}(z, x_1, ..., x_M) = \frac{f(x_z)}{\hat p(x_z)} \cdot \left( \frac{1}{M} \sum^M_{j=1} w(x_j) \right)\end{aligned}$$</li></ol><p>首先，我们需要证明这个方法正确。证明的核心在于计算两步抽样最终抽到 $ x_z $ 的概率。记</p>$$p(z_0, x_z) := \lim_{\epsilon \to 0} P(z = z_0,  x_z \le x \le x_z + \epsilon) / \epsilon$$<p>则</p>$$p(z, x_1, ..., x_M) = p(z \, | \, x_1, ..., x_M) \prod_{i=1}^M p(x_i) = \frac{ {\hat p(x_z)}/{p(x_z)} }{\sum_{i=1}^M \left({\hat p(x_i)}/{p(x_i)}\right)} \prod_{j=1}^M p(x_j)$$<p>则</p>$$\begin{aligned}\operatorname{E}\left[\bar I^{1, M}_{ris}\right]&= \int_{x_1, ..., x_M} \sum_{z=1}^M \bar I^{1, M}_{ris}(z, x_1, ..., x_M) \, p(z \, | \, x_1, ..., x_M) \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \int_{x_1, ..., x_M} \sum_{z=1}^M \frac{f(x_z)}{\hat p(x_z)} \cdot \left( \frac{1}{M} \sum^M_{j=1} w(x_j) \right) \frac{ {\hat p(x_z)}/{p(x_z)} }{\sum_{j=1}^M w(x_j)} \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \frac{1}{M} \int_{x_1, ..., x_M} \sum_{z=1}^M \frac{f(x_z)}{p(x_z)} \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \frac{1}{M} \operatorname{E}\left[ \sum_{z=1}^{M} \frac{f(x_z)}{p(x_z)} \right] \\&= \operatorname{E}\left[ \frac{f(x)}{p(x)} \right] \qquad \text{(} \because x_i \text{ i.i.d.)} \\&= \int_\Omega f(x) \, dx\end{aligned}$$<blockquote><p>NOTE: </p><ol><li>$ \int_{x_1, ..., x_M} $ 和 $ \int_{\mathcal{\Omega}^M} $ 是一样的，是他们各自的空间 $ \Omega $ 的直积。</li><li>$ \operatorname{E}[X+Y] = \operatorname{E}[X] + \operatorname{E}[Y] $ 不依赖于 $ X $ 和 $ Y $ 独立。</li></ol></blockquote><!-- TODO: 补充个 2 的证明 --><p>方差也可以相应计算如下：</p>$$\begin{aligned}\operatorname{Var}\left[\bar I^{1, M}_{ris}\right]&= \frac{1}{M^2} \operatorname{Var}\left[ \frac{f(x_z)}{\hat p(x_z)} \cdot \left(  \sum^M_{j=1} w(x_j) \right) \right] \\&= ?\end{aligned}$$<!-- TODO: Multi-sample RIS --><h3 id="带权蓄水池抽样-Weighted-Reservoir-Sampling"><a href="#带权蓄水池抽样-Weighted-Reservoir-Sampling" class="headerlink" title="带权蓄水池抽样 (Weighted Reservoir Sampling)"></a>带权蓄水池抽样 (Weighted Reservoir Sampling)</h3><p>前面提到，重采样重要性采样需要先抽 $ M $ 个样本，然后从中再抽样出最终的值。</p><p>经过仔细观察，拥有如下结构的抽样问题可以用带权蓄水池抽样 (Weighted Reservoir Sampling) 来解决：</p>$$p(z \, | \, x_1, ..., x_M) = \frac{w(x_z)}{\sum_{i=1}^M w(x_i)}$$<p>(WRS) 假设对于序列 $ {x_1, …, x_m} $，我们希望按上述概率抽样得到样本 $x_z$</p><ol><li>维护一个当前总权重 $ w_\text{sum} $，当前总样本数 $ M $ 和最终样本 $ y $</li><li>初始化 $ y:&#x3D;x_1; , M:&#x3D;1; , w_\text{sum}:&#x3D;w(x_1) $</li><li>对于每个新样本 $x_i$<ul><li>以 $ w(x_i) &#x2F; w_\text{sum} $ 概率：$ y:&#x3D;x_i; , M:&#x3D;M+1; , w_\text{sum} :&#x3D; w_\text{sum}+w(x_i) $</li><li>以 $ 1 - w(x_i) &#x2F; w_\text{sum} $ 概率：$ M:&#x3D;M+1; , w_\text{sum} :&#x3D; w_\text{sum}+w(x_i) $</li></ul></li></ol><p>这样对于某个样本 $ x_k $，经过这个过程最后被选中的概率为 <code>P(第 k 次被选中) * P(第 k 次之后都没有被换掉)</code>，乘起来很容易证明正确性。</p><p>WRS 方法的优势在于，不需要完成存储 $ {x_i} $ 序列本身，而是线性扫描一遍这个序列就可以得出结果，非常适合和前面的 RIS 方法搭配使用。</p><h3 id="蓄水池合并-Reservoir-Merging"><a href="#蓄水池合并-Reservoir-Merging" class="headerlink" title="蓄水池合并 (Reservoir Merging)"></a>蓄水池合并 (Reservoir Merging)</h3><!-- 假设我们要从 $ \{x_1, ..., x_m, y_1, ..., y_n\} $ 中抽样， -->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了 ReSTIR 这种用于实时渲染的采样增强方法，该方法可以处理交互式渲染中对大量光源 (&amp;gt;&amp;#x3D; 1k) 的直</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客复活！</title>
    <link href="https://blog.libreliu.info/blog-reborn/"/>
    <id>https://blog.libreliu.info/blog-reborn/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客已经有一段时间没更新了，以至于竟然连之前的源文件都找不到了。</p><p>这次将博客的源文件放到 GitHub 上，并且把之前的文章收集整理一下，进行一下重构。</p><h2 id="用什么博客框架？"><a href="#用什么博客框架？" class="headerlink" title="用什么博客框架？"></a>用什么博客框架？</h2><p>在 Hexo 和 Pelican 中选择了 Hexo，主要社区和主题的维护者都更活跃一些。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="生成-amp-测试"><a href="#生成-amp-测试" class="headerlink" title="生成 &amp; 测试"></a>生成 &amp; 测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/hexo generate</span><br><span class="line">./node_modules/.bin/hexo server</span><br></pre></td></tr></table></figure><p>也可以考虑 <code>npm run build</code> 和 <code>npm run server</code>。</p><h3 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h3><p><code>hexo new &quot;My new post&quot;</code></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>主题基于 <a href="https://github.com/52binge/hexo-theme-blairos">BlairOS</a> 这个 Hexo 主题，我裁减了其中的统计代码，更改了 Logo 和相关的 Stylus 代码。</p><h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><ul><li>计划在将来把对 cdn.mathjax.org 的依赖也去掉，变成完全服务端渲染</li><li>这个模板对 ul 嵌套的情况渲染不正确</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前的博客已经有一段时间没更新了，以至于竟然连之前的源文件都找不到了。&lt;/p&gt;
&lt;p&gt;这次将博客的源文件放到 GitHub 上，并且把之前的文章收集整理一下，进行一下重构。&lt;/p&gt;
&lt;h2 id=&quot;用什么博客框架？&quot;&gt;&lt;a href=&quot;#用什么博客框架？&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>USTC Verilog OJ | 设计、实现、剩下的坑</title>
    <link href="https://blog.libreliu.info/ustc-verilog-oj/"/>
    <id>https://blog.libreliu.info/ustc-verilog-oj/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-08-25T17:30:19.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>(Remark 2022-07-07): 本文原发于知乎，现在在博客这边补个档。</p></blockquote><p>夜深人静的时候有些难以入眠（实际上可能是早上起太迟了），于是开一篇文章大略记叙一下部署在 <a href="https://verilogoj.ustc.edu.cn/">https://verilogoj.ustc.edu.cn/</a> 处的 USTC Verilog OJ 的设计实现和留下的坑。</p><p>设计一个 Verilog OJ 的想法源于 2020 春的《软件工程》课程，课程伊始要求同学们以 10 人为一组提交一个大作业。正好，当时 lluckydog 提到了这个点子，我们就去找实验中心的老师协商，老师也感觉不错。</p><p>设计之初，考虑到 Verilog 作为硬件描述（和仿真）语言的地位，我们认为 Verilog OJ 本身应该与其它程序设计语言的 OJ 有所不同。这种不同主要是来源于电路这种设计产出与程序这种产出之间的差异。</p><p>电路可以从功能和性能两方面来进行评价。对于功能，用行为级仿真就可以解决，而对于性能，则要将其放到后端当中去，从占用的资源，完成功能所需要的时钟周期和可以达到的最高时钟频率，以及使用到的资源等来综合的进行评价。这就意味着，OJ 在执行架构上需要兼容各种不同的评价任务，并且可以灵活配置。</p><p>针对这一点，我们认为应该将每个判题任务配置为 shell 脚本，在脚本中读取用户输入的文件，并且进行输出操作，这样就可以比较灵活的进行不同评测任务的配置了。</p><p>我们当时还调研了前端和后端评测任务的一些可能方向，比如<a href="https://github.com/YAVGroup/Verilog-OJ/blob/master/doc/research/OpenTimer%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90.md">使用 OpenTimer 进行静态时序分析</a>，<a href="https://github.com/YAVGroup/Verilog-OJ/blob/master/doc/research/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%AF%84%E4%BB%B7.md">使用 Yosys 进行综合并且判断电路综合后有没有 latch</a> 等等。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>前端方面我们是从 <a href="https://github.com/Linzecong/LPOJ">LPOJ</a> 的代码基础上开始修改的，所以也沿用了 Element UI + Vue.js 的组合；编辑代码采用 CodeMirror，显示波形采用 Wavedrom。</p><p>后端采用 Django + Django RESTful Framework，Django 赋予的快速原型能力我们整体还是比较满意的。</p><p>后端和判题机通过消息队列 Celery 实现解耦，为增加新的判题机留出空间，同时将两个过程掰开。判题机提交判题结果的方法就是把 SubmissionResult 对象进行 HTTP PATCH。</p><p>判题机本身会在每个新的判题请求到来时，从后端拉下来所有需要的文件，同时新启动一个 Docker 容器用来判题，判题完成时会将容器中分数、日志、波形（app_data）拷出并上传，之后销毁容器。容器本身有时间和内存限制。</p><blockquote><p>大多数判题任务就是在参考答案和用户提交答案上面跑一个 testbench 并且 dump vcd，然后做一个波形比较。vcd 文件解析使用的是 pyDigitalWaveTools。</p></blockquote><p>使用 Nginx 做反代，方便调整一些请求头之类的，上面所有的部分都打包为容器，并且用 docker-compose 进行部署。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>软工课程答辩前，我们设计了几道简单的题目来验证 Verilog OJ 的功能。<a href="https://github.com/YAVGroup/Verilog-OJ/tree/master/assets">这些题目</a>包括输出 0，输出 1，3-8 译码器和三个数的比较器等。前面几道题目是行为级的仿真，最后一题用到了 Yosys 进行综合，并且对综合后结果进行仿真（大概就是 <code>yosys -p &quot;read_verilog ./submit/code.v; synth -top top_module; write_verilog code_synthed.v&quot; -v 3</code>）</p><p>不过软工结束之后，由于鸽子们鸽来鸽去，想搞的计算机组成原理实验自动评测一直没有动静，助教们最后也还是决定手工检查，所以系统就有派上用场。</p><p>2021 年署假的时候，老师决定先翻译一些 <a href="https://hdlbits.01xz.net/">HDLBits</a> 上面的题目，作为下学期数字电路实验的一小部分，来帮助 Verilog 的学习。</p><p>在这学期出题和同学们做题的过程中，也发现并且修复了一些脚本上的问题，主要是 VCD 的一些 corner case。</p><h2 id="剩下的坑"><a href="#剩下的坑" class="headerlink" title="剩下的坑"></a>剩下的坑</h2><p>使用过程中同学们提了很多意见，这些意见基本都以 Issue 的形式放到了仓库当中去。不过不少问题都被我们一直鸽着，也缺乏感兴趣的新同学加入进来。</p><p>远期来说，我个人希望这个平台可以帮助希望做硬件开发的同学们更贴近 IC 业界考虑的问题，并且对硬件设计本身有更好的理解——当然鉴于我本人是个硬件菜鸡，这还需要很多大佬的支持才能办到。</p><p>就我个人从前辈处了解到的一些信息来说，IC 的验证和后端的流程普通的同学还是很难接触到的，可能在平台中有关于验证和后端设计需要关心的问题进行设计并包装成为题目是值得尝试的一些方向。</p><blockquote><p>比如说，SystemVerilog &#x2F; UMD 通用验证方法学 的超快速入门，调教时序问题的小实战等</p></blockquote><p>另一个可能值得尝试的坑是对接 USTC FPGAOL 平台，将片上的表现作为评估和设计迭代的依据。</p><p>（不过听着就是大坑.jpg）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>赶紧来个大佬填坑吧！（x）</p><p>希望有更多感兴趣的同学加入到我们的开发（和提 Issue）的工作当中ww</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;(Remark 2022-07-07): 本文原发于知乎，现在在博客这边补个档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;夜深人静的时候有些难以入眠（实际上可能是早上起太迟了），于是开一篇文章大略记叙一下部署在 &lt;a href=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
</feed>
