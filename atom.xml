<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>libreliu&#39;s blog</title>
  
  
  <link href="https://blog.libreliu.info/atom.xml" rel="self"/>
  
  <link href="https://blog.libreliu.info/"/>
  <updated>2025-02-25T16:00:00.000Z</updated>
  <id>https://blog.libreliu.info/</id>
  
  <author>
    <name>Libre Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tailscale 服务部署快速参考</title>
    <link href="https://blog.libreliu.info/tailscale-howto/"/>
    <id>https://blog.libreliu.info/tailscale-howto/</id>
    <published>2025-02-25T16:00:00.000Z</published>
    <updated>2025-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2025&#x2F;02&#x2F;28: 修复了笔误，感谢 @taoky。</p></blockquote><h2 id="Tailscale-介绍"><a href="#Tailscale-介绍" class="headerlink" title="Tailscale 介绍"></a>Tailscale 介绍</h2><blockquote><p>来源于 Kimi.ai，K1.5 Long thinking</p></blockquote><p>Tailscale 是一种网状 VPN 服务，它简化了不同网络中设备和服务之间的安全连接。以下是关于它的一些关键点：</p><ul><li>基本概念和工作原理<ul><li>网状网络架构：与传统的使用中央网关的 VPN 不同，Tailscale 创建了一个点对点的网状网络（称为 tailnet）。网络中的每个设备都可以直接与其他设备通信，从而降低了延迟并提高了吞吐量。</li><li>WireGuard 协议：它利用开源的 WireGuard 协议进行加密的点对点连接。该协议以其安全性和性能著称，提供了端到端的加密和零信任架构。</li></ul></li><li>优势<ul><li>高性能：去中心化的架构避免了单点故障和瓶颈，即使网络规模扩大，也能确保稳定可靠的连接。</li><li>安全性和隐私性：基于现代技术和最佳实践构建，Tailscale 提供了强大的安全功能，如访问控制策略和 tailnet 锁定。它还符合各种安全标准。</li><li>易于使用：Tailscale 高度可配置，但设置起来非常简单。用户无需深厚的网络知识即可在几分钟内部署一个 tailnet。“零配置”方法允许在防火墙和 NAT 之后无缝连接，无需复杂的配置。</li></ul></li></ul><h2 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h2><p>其实 Tailscale 可以采用官方的服务器，不过也可以使用开源的 headscale 实现，自己搭建登录服务器。</p><p>这里选择采用</p><ul><li><a href="https://github.com/juanfont/headscale">headscale</a> v0.23.0 作为登录服务器</li><li><a href="https://github.com/gurucomputing/headscale-ui">headscale-ui</a> </li><li>Caddy 作为反向代理，把 UI 和 headscale 本身需要提供的网关功能搓到一起，同时自动获取 SSL 证书来处理 https</li></ul><p>采用 Docker Compose v3 来简单编排容器。</p><p>具体可以参考后面的“附录：全量服务端配置”。</p><p>配置文件和其余命令约定如下：</p><ul><li><code>your.example.com</code> 是用来 host Tailscale 的你的域名，其应该有正确配置的 A 和 AAAA 记录。</li><li><code>your_email@example.com</code> 是你的邮箱。</li><li><code>intra.example.com</code> 是 MagicDNS 前缀，Tailscale 网络内的客户端在连接到 Tailscale 网络后，可以通过 <code>主机名.intra.example.com</code> 解析到彼此的网内 IP 地址。这里推荐采用自己域名的子域名，这样以避免和互联网上的可能域名冲突。</li></ul><p>在按全量服务端配置配置后，需要生成 api key 用于 Headscale UI 的 Web 访问。</p><p>可以考虑用下面的命令生成 Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3650d 代表该 apikey 将在 3650 天后过期</span></span><br><span class="line">docker <span class="built_in">exec</span> -it headscale headscale apikeys create -e 3650d</span><br></pre></td></tr></table></figure><p>记录该 Key，并填入 Headscale UI，就可以通过浏览器管理客户端设备和用户的访问权限等。</p><h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 Tailscale 官方网站下载客户端，安装后，打开 cmd，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tailscale login --login-server http://your.example.com/</span><br></pre></td></tr></table></figure><p>后，点击下图的托盘提示，跳转到 Headscale 的提示页面</p><p><img src="/./tailscale-howto/tailscale_login.png"></p><p><img src="/./tailscale-howto/tailscale_jump_page.png"></p><p>然后打开 Headscale UI 的 Device 页面 （例如，<code>https://your.example.com/web/devices.html</code>）增加 User 后增加相应 Device 即可。</p><h2 id="附录：全量服务端配置"><a href="#附录：全量服务端配置" class="headerlink" title="附录：全量服务端配置"></a>附录：全量服务端配置</h2><ul><li><code>your.example.com</code> 是用来 host Tailscale 的你的域名，其应该有正确配置的 A 和 AAAA 记录。</li><li><code>your_email@example.com</code> 是你的邮箱。</li><li><code>intra.example.com</code> 是 MagicDNS 前缀，Tailscale 网络内的客户端在连接到 Tailscale 网络后，可以通过 <code>主机名.intra.example.com</code> 解析到彼此的网内 IP 地址。这里推荐采用自己域名的子域名，这样以避免和互联网上的可能域名冲突。</li></ul><h3 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="./docker-compose.yaml"></a><code>./docker-compose.yaml</code></h3><p>这里最后会暴露 80，443 两个端口。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">headscale:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">headscale/headscale:v0.23.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">headscale</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 80 is to be forwarded by caddy, and hence not exposed</span></span><br><span class="line">           <span class="comment"># only need to expose others locally</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:9090:9090&quot;</span>  <span class="comment"># /metrics</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:50443:50443&quot;</span>  <span class="comment"># grpc api</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/libreliu/headscale/config:/etc/headscale</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">headscale_data:/var/lib/headscale</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">serve</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hs-net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">headscale-ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/gurucomputing/headscale-ui:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">headscale-ui</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8443&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hs-net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">caddy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">caddy:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">caddy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Caddyfile:/etc/caddy/Caddyfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">caddy_data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">caddy_config:/config</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hs-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hs-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">caddy_data:</span></span><br><span class="line">  <span class="attr">caddy_config:</span></span><br><span class="line">  <span class="attr">headscale_data:</span></span><br></pre></td></tr></table></figure><h3 id="Caddyfile"><a href="#Caddyfile" class="headerlink" title="./Caddyfile"></a><code>./Caddyfile</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    email your_email@example.com  # Provide a valid email for ACME notifications.</span><br><span class="line">    admin off  # Disable Caddy&#x27;s admin API if not needed.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Route for Headscale UI</span><br><span class="line">your.example.com &#123;</span><br><span class="line">    reverse_proxy /web* http://headscale-ui:8080</span><br><span class="line">    reverse_proxy * http://headscale:80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="config-config-yaml"><a href="#config-config-yaml" class="headerlink" title="./config/config.yaml"></a><code>./config/config.yaml</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"># headscale will look for a configuration file named `config.yaml` (or `config.json`) in the following order:</span><br><span class="line">#</span><br><span class="line"># - `/etc/headscale`</span><br><span class="line"># - `~/.headscale`</span><br><span class="line"># - current working directory</span><br><span class="line"></span><br><span class="line"># The url clients will connect to.</span><br><span class="line"># Typically this will be a domain like:</span><br><span class="line">#</span><br><span class="line"># https://myheadscale.example.com:443</span><br><span class="line">#</span><br><span class="line">server_url: https://your.example.com:443</span><br><span class="line"></span><br><span class="line"># Address to listen to / bind to on the server</span><br><span class="line">#</span><br><span class="line"># For production:</span><br><span class="line">listen_addr: 0.0.0.0:80</span><br><span class="line">#listen_addr: 127.0.0.1:8080</span><br><span class="line"></span><br><span class="line"># Address to listen to /metrics, you may want</span><br><span class="line"># to keep this endpoint private to your internal</span><br><span class="line"># network</span><br><span class="line">#</span><br><span class="line">#metrics_listen_addr: 127.0.0.1:9090</span><br><span class="line">metrics_listen_addr: 0.0.0.0:9090</span><br><span class="line"></span><br><span class="line"># Address to listen for gRPC.</span><br><span class="line"># gRPC is used for controlling a headscale server</span><br><span class="line"># remotely with the CLI</span><br><span class="line"># Note: Remote access _only_ works if you have</span><br><span class="line"># valid certificates.</span><br><span class="line">#</span><br><span class="line"># For production:</span><br><span class="line">#grpc_listen_addr: 0.0.0.0:50443</span><br><span class="line">grpc_listen_addr: 127.0.0.1:50443</span><br><span class="line"></span><br><span class="line"># Allow the gRPC admin interface to run in INSECURE</span><br><span class="line"># mode. This is not recommended as the traffic will</span><br><span class="line"># be unencrypted. Only enable if you know what you</span><br><span class="line"># are doing.</span><br><span class="line">grpc_allow_insecure: false</span><br><span class="line"></span><br><span class="line"># The Noise section includes specific configuration for the</span><br><span class="line"># TS2021 Noise protocol</span><br><span class="line">noise:</span><br><span class="line">  # The Noise private key is used to encrypt the</span><br><span class="line">  # traffic between headscale and Tailscale clients when</span><br><span class="line">  # using the new Noise-based protocol.</span><br><span class="line">  private_key_path: /var/lib/headscale/noise_private.key</span><br><span class="line"></span><br><span class="line"># List of IP prefixes to allocate tailaddresses from.</span><br><span class="line"># Each prefix consists of either an IPv4 or IPv6 address,</span><br><span class="line"># and the associated prefix length, delimited by a slash.</span><br><span class="line"># It must be within IP ranges supported by the Tailscale</span><br><span class="line"># client - i.e., subnets of 100.64.0.0/10 and fd7a:115c:a1e0::/48.</span><br><span class="line"># See below:</span><br><span class="line"># IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71</span><br><span class="line"># IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33</span><br><span class="line"># Any other range is NOT supported, and it will cause unexpected issues.</span><br><span class="line">prefixes:</span><br><span class="line">  v6: fd7a:115c:a1e0::/48</span><br><span class="line">  v4: 100.64.0.0/10</span><br><span class="line"></span><br><span class="line">  # Strategy used for allocation of IPs to nodes, available options:</span><br><span class="line">  # - sequential (default): assigns the next free IP from the previous given IP.</span><br><span class="line">  # - random: assigns the next free IP from a pseudo-random IP generator (crypto/rand).</span><br><span class="line">  allocation: sequential</span><br><span class="line"></span><br><span class="line"># DERP is a relay system that Tailscale uses when a direct</span><br><span class="line"># connection cannot be established.</span><br><span class="line"># https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp</span><br><span class="line">#</span><br><span class="line"># headscale needs a list of DERP servers that can be presented</span><br><span class="line"># to the clients.</span><br><span class="line">derp:</span><br><span class="line">  server:</span><br><span class="line">    # If enabled, runs the embedded DERP server and merges it into the rest of the DERP config</span><br><span class="line">    # The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">    # Region ID to use for the embedded DERP server.</span><br><span class="line">    # The local DERP prevails if the region ID collides with other region ID coming from</span><br><span class="line">    # the regular DERP config.</span><br><span class="line">    region_id: 999</span><br><span class="line"></span><br><span class="line">    # Region code and name are displayed in the Tailscale UI to identify a DERP region</span><br><span class="line">    region_code: &quot;headscale&quot;</span><br><span class="line">    region_name: &quot;Headscale Embedded DERP&quot;</span><br><span class="line"></span><br><span class="line">    # Listens over UDP at the configured address for STUN connections - to help with NAT traversal.</span><br><span class="line">    # When the embedded DERP server is enabled stun_listen_addr MUST be defined.</span><br><span class="line">    #</span><br><span class="line">    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/</span><br><span class="line">    stun_listen_addr: &quot;0.0.0.0:3478&quot;</span><br><span class="line"></span><br><span class="line">    # Private key used to encrypt the traffic between headscale DERP</span><br><span class="line">    # and Tailscale clients.</span><br><span class="line">    # The private key file will be autogenerated if it&#x27;s missing.</span><br><span class="line">    #</span><br><span class="line">    private_key_path: /var/lib/headscale/derp_server_private.key</span><br><span class="line"></span><br><span class="line">    # This flag can be used, so the DERP map entry for the embedded DERP server is not written automatically,</span><br><span class="line">    # it enables the creation of your very own DERP map entry using a locally available file with the parameter DERP.paths</span><br><span class="line">    # If you enable the DERP server and set this to false, it is required to add the DERP server to the DERP map using DERP.paths</span><br><span class="line">    automatically_add_embedded_derp_region: true</span><br><span class="line"></span><br><span class="line">    # For better connection stability (especially when using an Exit-Node and DNS is not working),</span><br><span class="line">    # it is possible to optionally add the public IPv4 and IPv6 address to the Derp-Map using:</span><br><span class="line">    ipv4: 1.2.3.4</span><br><span class="line">    ipv6: 2001:db8::1</span><br><span class="line"></span><br><span class="line">  # List of externally available DERP maps encoded in JSON</span><br><span class="line">  urls:</span><br><span class="line">    - https://controlplane.tailscale.com/derpmap/default</span><br><span class="line"></span><br><span class="line">  # Locally available DERP map files encoded in YAML</span><br><span class="line">  #</span><br><span class="line">  # This option is mostly interesting for people hosting</span><br><span class="line">  # their own DERP servers:</span><br><span class="line">  # https://tailscale.com/kb/1118/custom-derp-servers/</span><br><span class="line">  #</span><br><span class="line">  # paths:</span><br><span class="line">  #   - /etc/headscale/derp-example.yaml</span><br><span class="line">  paths: []</span><br><span class="line"></span><br><span class="line">  # If enabled, a worker will be set up to periodically</span><br><span class="line">  # refresh the given sources and update the derpmap</span><br><span class="line">  # will be set up.</span><br><span class="line">  auto_update_enabled: true</span><br><span class="line"></span><br><span class="line">  # How often should we check for DERP updates?</span><br><span class="line">  update_frequency: 24h</span><br><span class="line"></span><br><span class="line"># Disables the automatic check for headscale updates on startup</span><br><span class="line">disable_check_updates: false</span><br><span class="line"></span><br><span class="line"># Time before an inactive ephemeral node is deleted?</span><br><span class="line">ephemeral_node_inactivity_timeout: 30m</span><br><span class="line"></span><br><span class="line">database:</span><br><span class="line">  # Database type. Available options: sqlite, postgres</span><br><span class="line">  # Please note that using Postgres is highly discouraged as it is only supported for legacy reasons.</span><br><span class="line">  # All new development, testing and optimisations are done with SQLite in mind.</span><br><span class="line">  type: sqlite</span><br><span class="line"></span><br><span class="line">  # Enable debug mode. This setting requires the log.level to be set to &quot;debug&quot; or &quot;trace&quot;.</span><br><span class="line">  debug: false</span><br><span class="line"></span><br><span class="line">  # GORM configuration settings.</span><br><span class="line">  gorm:</span><br><span class="line">    # Enable prepared statements.</span><br><span class="line">    prepare_stmt: true</span><br><span class="line"></span><br><span class="line">    # Enable parameterized queries.</span><br><span class="line">    parameterized_queries: true</span><br><span class="line"></span><br><span class="line">    # Skip logging &quot;record not found&quot; errors.</span><br><span class="line">    skip_err_record_not_found: true</span><br><span class="line"></span><br><span class="line">    # Threshold for slow queries in milliseconds.</span><br><span class="line">    slow_threshold: 1000</span><br><span class="line"></span><br><span class="line">  # SQLite config</span><br><span class="line">  sqlite:</span><br><span class="line">    path: /var/lib/headscale/db.sqlite</span><br><span class="line"></span><br><span class="line">    # Enable WAL mode for SQLite. This is recommended for production environments.</span><br><span class="line">    # https://www.sqlite.org/wal.html</span><br><span class="line">    write_ahead_log: true</span><br><span class="line"></span><br><span class="line">  # # Postgres config</span><br><span class="line">  # Please note that using Postgres is highly discouraged as it is only supported for legacy reasons.</span><br><span class="line">  # See database.type for more information.</span><br><span class="line">  # postgres:</span><br><span class="line">  #   # If using a Unix socket to connect to Postgres, set the socket path in the &#x27;host&#x27; field and leave &#x27;port&#x27; blank.</span><br><span class="line">  #   host: localhost</span><br><span class="line">  #   port: 5432</span><br><span class="line">  #   name: headscale</span><br><span class="line">  #   user: foo</span><br><span class="line">  #   pass: bar</span><br><span class="line">  #   max_open_conns: 10</span><br><span class="line">  #   max_idle_conns: 10</span><br><span class="line">  #   conn_max_idle_time_secs: 3600</span><br><span class="line"></span><br><span class="line">  #   # If other &#x27;sslmode&#x27; is required instead of &#x27;require(true)&#x27; and &#x27;disabled(false)&#x27;, set the &#x27;sslmode&#x27; you need</span><br><span class="line">  #   # in the &#x27;ssl&#x27; field. Refers to https://www.postgresql.org/docs/current/libpq-ssl.html Table 34.1.</span><br><span class="line">  #   ssl: false</span><br><span class="line"></span><br><span class="line">### TLS configuration</span><br><span class="line">#</span><br><span class="line">## Let&#x27;s encrypt / ACME</span><br><span class="line">#</span><br><span class="line"># headscale supports automatically requesting and setting up</span><br><span class="line"># TLS for a domain with Let&#x27;s Encrypt.</span><br><span class="line">#</span><br><span class="line"># URL to ACME directory</span><br><span class="line">acme_url: https://acme-v02.api.letsencrypt.org/directory</span><br><span class="line"></span><br><span class="line"># Email to register with ACME provider</span><br><span class="line">acme_email: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Domain name to request a TLS certificate for:</span><br><span class="line">tls_letsencrypt_hostname: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Path to store certificates and metadata needed by</span><br><span class="line"># letsencrypt</span><br><span class="line"># For production:</span><br><span class="line">tls_letsencrypt_cache_dir: /var/lib/headscale/cache</span><br><span class="line"></span><br><span class="line"># Type of ACME challenge to use, currently supported types:</span><br><span class="line"># HTTP-01 or TLS-ALPN-01</span><br><span class="line"># See [docs/tls.md](docs/tls.md) for more information</span><br><span class="line">tls_letsencrypt_challenge_type: HTTP-01</span><br><span class="line"># When HTTP-01 challenge is chosen, letsencrypt must set up a</span><br><span class="line"># verification endpoint, and it will be listening on:</span><br><span class="line"># :http = port 80</span><br><span class="line">tls_letsencrypt_listen: &quot;:http&quot;</span><br><span class="line"></span><br><span class="line">## Use already defined certificates:</span><br><span class="line">tls_cert_path: &quot;&quot;</span><br><span class="line">tls_key_path: &quot;&quot;</span><br><span class="line"></span><br><span class="line">log:</span><br><span class="line">  # Output formatting for logs: text or json</span><br><span class="line">  format: text</span><br><span class="line">  level: info</span><br><span class="line"></span><br><span class="line">## Policy</span><br><span class="line"># headscale supports Tailscale&#x27;s ACL policies.</span><br><span class="line"># Please have a look to their KB to better</span><br><span class="line"># understand the concepts: https://tailscale.com/kb/1018/acls/</span><br><span class="line">policy:</span><br><span class="line">  # The mode can be &quot;file&quot; or &quot;database&quot; that defines</span><br><span class="line">  # where the ACL policies are stored and read from.</span><br><span class="line">  mode: file</span><br><span class="line">  # If the mode is set to &quot;file&quot;, the path to a</span><br><span class="line">  # HuJSON file containing ACL policies.</span><br><span class="line">  path: &quot;&quot;</span><br><span class="line"></span><br><span class="line">## DNS</span><br><span class="line">#</span><br><span class="line"># headscale supports Tailscale&#x27;s DNS configuration and MagicDNS.</span><br><span class="line"># Please have a look to their KB to better understand the concepts:</span><br><span class="line">#</span><br><span class="line"># - https://tailscale.com/kb/1054/dns/</span><br><span class="line"># - https://tailscale.com/kb/1081/magicdns/</span><br><span class="line"># - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/</span><br><span class="line">#</span><br><span class="line"># Please note that for the DNS configuration to have any effect,</span><br><span class="line"># clients must have the `--accept-dns=true` option enabled. This is the</span><br><span class="line"># default for the Tailscale client. This option is enabled by default</span><br><span class="line"># in the Tailscale client.</span><br><span class="line">#</span><br><span class="line"># Setting _any_ of the configuration and `--accept-dns=true` on the</span><br><span class="line"># clients will integrate with the DNS manager on the client or</span><br><span class="line"># overwrite /etc/resolv.conf.</span><br><span class="line"># https://tailscale.com/kb/1235/resolv-conf</span><br><span class="line">#</span><br><span class="line"># If you want stop Headscale from managing the DNS configuration</span><br><span class="line"># all the fields under `dns` should be set to empty values.</span><br><span class="line">dns:</span><br><span class="line">  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).</span><br><span class="line">  # Only works if there is at least a nameserver defined.</span><br><span class="line">  magic_dns: true</span><br><span class="line"></span><br><span class="line">  # Defines the base domain to create the hostnames for MagicDNS.</span><br><span class="line">  # This domain _must_ be different from the server_url domain.</span><br><span class="line">  # `base_domain` must be a FQDN, without the trailing dot.</span><br><span class="line">  # The FQDN of the hosts will be</span><br><span class="line">  # `hostname.base_domain` (e.g., _myhost.example.com_).</span><br><span class="line">  base_domain: intra.example.com</span><br><span class="line"></span><br><span class="line">  # List of DNS servers to expose to clients.</span><br><span class="line">  nameservers:</span><br><span class="line">    global:</span><br><span class="line">      - 1.1.1.1</span><br><span class="line">      - 1.0.0.1</span><br><span class="line">      - 2606:4700:4700::1111</span><br><span class="line">      - 2606:4700:4700::1001</span><br><span class="line"></span><br><span class="line">      # NextDNS (see https://tailscale.com/kb/1218/nextdns/).</span><br><span class="line">      # &quot;abc123&quot; is example NextDNS ID, replace with yours.</span><br><span class="line">      # - https://dns.nextdns.io/abc123</span><br><span class="line"></span><br><span class="line">    # Split DNS (see https://tailscale.com/kb/1054/dns/),</span><br><span class="line">    # a map of domains and which DNS server to use for each.</span><br><span class="line">    split:</span><br><span class="line">      &#123;&#125;</span><br><span class="line">      # foo.bar.com:</span><br><span class="line">      #   - 1.1.1.1</span><br><span class="line">      # darp.headscale.net:</span><br><span class="line">      #   - 1.1.1.1</span><br><span class="line">      #   - 8.8.8.8</span><br><span class="line"></span><br><span class="line">  # Set custom DNS search domains. With MagicDNS enabled,</span><br><span class="line">  # your tailnet base_domain is always the first search domain.</span><br><span class="line">  search_domains: []</span><br><span class="line"></span><br><span class="line">  # Extra DNS records</span><br><span class="line">  # so far only A-records are supported (on the tailscale side)</span><br><span class="line">  # See https://github.com/juanfont/headscale/blob/main/docs/dns-records.md#Limitations</span><br><span class="line">  extra_records: []</span><br><span class="line">  #   - name: &quot;grafana.myvpn.example.com&quot;</span><br><span class="line">  #     type: &quot;A&quot;</span><br><span class="line">  #     value: &quot;100.64.0.3&quot;</span><br><span class="line">  #</span><br><span class="line">  #   # you can also put it in one line</span><br><span class="line">  #   - &#123; name: &quot;prometheus.myvpn.example.com&quot;, type: &quot;A&quot;, value: &quot;100.64.0.3&quot; &#125;</span><br><span class="line"></span><br><span class="line">  # DEPRECATED</span><br><span class="line">  # Use the username as part of the DNS name for nodes, with this option enabled:</span><br><span class="line">  # node1.username.example.com</span><br><span class="line">  # while when this is disabled:</span><br><span class="line">  # node1.example.com</span><br><span class="line">  # This is a legacy option as Headscale has have this wrongly implemented</span><br><span class="line">  # while in upstream Tailscale, the username is not included.</span><br><span class="line">  use_username_in_magic_dns: false</span><br><span class="line"></span><br><span class="line"># Unix socket used for the CLI to connect without authentication</span><br><span class="line"># Note: for production you will want to set this to something like:</span><br><span class="line">unix_socket: /var/run/headscale/headscale.sock</span><br><span class="line">unix_socket_permission: &quot;0770&quot;</span><br><span class="line">#</span><br><span class="line"># headscale supports experimental OpenID connect support,</span><br><span class="line"># it is still being tested and might have some bugs, please</span><br><span class="line"># help us test it.</span><br><span class="line"># OpenID Connect</span><br><span class="line"># oidc:</span><br><span class="line">#   only_start_if_oidc_is_available: true</span><br><span class="line">#   issuer: &quot;https://your-oidc.issuer.com/path&quot;</span><br><span class="line">#   client_id: &quot;your-oidc-client-id&quot;</span><br><span class="line">#   client_secret: &quot;your-oidc-client-secret&quot;</span><br><span class="line">#   # Alternatively, set `client_secret_path` to read the secret from the file.</span><br><span class="line">#   # It resolves environment variables, making integration to systemd&#x27;s</span><br><span class="line">#   # `LoadCredential` straightforward:</span><br><span class="line">#   client_secret_path: &quot;$&#123;CREDENTIALS_DIRECTORY&#125;/oidc_client_secret&quot;</span><br><span class="line">#   # client_secret and client_secret_path are mutually exclusive.</span><br><span class="line">#</span><br><span class="line">#   # The amount of time from a node is authenticated with OpenID until it</span><br><span class="line">#   # expires and needs to reauthenticate.</span><br><span class="line">#   # Setting the value to &quot;0&quot; will mean no expiry.</span><br><span class="line">#   expiry: 180d</span><br><span class="line">#</span><br><span class="line">#   # Use the expiry from the token received from OpenID when the user logged</span><br><span class="line">#   # in, this will typically lead to frequent need to reauthenticate and should</span><br><span class="line">#   # only been enabled if you know what you are doing.</span><br><span class="line">#   # Note: enabling this will cause `oidc.expiry` to be ignored.</span><br><span class="line">#   use_expiry_from_token: false</span><br><span class="line">#</span><br><span class="line">#   # Customize the scopes used in the OIDC flow, defaults to &quot;openid&quot;, &quot;profile&quot; and &quot;email&quot; and add custom query</span><br><span class="line">#   # parameters to the Authorize Endpoint request. Scopes default to &quot;openid&quot;, &quot;profile&quot; and &quot;email&quot;.</span><br><span class="line">#</span><br><span class="line">#   scope: [&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;, &quot;custom&quot;]</span><br><span class="line">#   extra_params:</span><br><span class="line">#     domain_hint: example.com</span><br><span class="line">#</span><br><span class="line">#   # List allowed principal domains and/or users. If an authenticated user&#x27;s domain is not in this list, the</span><br><span class="line">#   # authentication request will be rejected.</span><br><span class="line">#</span><br><span class="line">#   allowed_domains:</span><br><span class="line">#     - example.com</span><br><span class="line">#   # Note: Groups from keycloak have a leading &#x27;/&#x27;</span><br><span class="line">#   allowed_groups:</span><br><span class="line">#     - /headscale</span><br><span class="line">#   allowed_users:</span><br><span class="line">#     - alice@example.com</span><br><span class="line">#</span><br><span class="line">#   # If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.</span><br><span class="line">#   # This will transform `first-name.last-name@example.com` to the user `first-name.last-name`</span><br><span class="line">#   # If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following</span><br><span class="line">#   user: `first-name.last-name.example.com`</span><br><span class="line">#</span><br><span class="line">#   strip_email_domain: true</span><br><span class="line"></span><br><span class="line"># Logtail configuration</span><br><span class="line"># Logtail is Tailscales logging and auditing infrastructure, it allows the control panel</span><br><span class="line"># to instruct tailscale nodes to log their activity to a remote server.</span><br><span class="line">logtail:</span><br><span class="line">  # Enable logtail for this headscales clients.</span><br><span class="line">  # As there is currently no support for overriding the log server in headscale, this is</span><br><span class="line">  # disabled by default. Enabling this will make your clients send logs to Tailscale Inc.</span><br><span class="line">  enabled: false</span><br><span class="line"></span><br><span class="line"># Enabling this option makes devices prefer a random port for WireGuard traffic over the</span><br><span class="line"># default static port 41641. This option is intended as a workaround for some buggy</span><br><span class="line"># firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.</span><br><span class="line">randomize_client_port: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2025&amp;#x2F;02&amp;#x2F;28: 修复了笔误，感谢 @taoky。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Tailscale-介绍&quot;&gt;&lt;a href=&quot;#Tailscale-介绍&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>炼丹炉被黑始末 (a.k.a. 这下服务器变回转寿司了，最美味的一集)</title>
    <link href="https://blog.libreliu.info/intrusion-investigation/"/>
    <id>https://blog.libreliu.info/intrusion-investigation/</id>
    <published>2024-02-27T16:00:00.000Z</published>
    <updated>2024-02-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>炼丹炉被黑了，以下是事情经过：</p><h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><ul><li><p>2024&#x2F;2&#x2F;27：师兄发现在实验室服务器上登陆的网络通被网络信息中心留言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">您好！</span><br><span class="line"></span><br><span class="line">您使用的IP地址 xxx.xxx.xx.xxx 存在通信异常行为，</span><br><span class="line">请尽快对系统进行处理，否则网络信息中心中心将暂停该机的对外通信。</span><br><span class="line"></span><br><span class="line">科大网络信息中心 (联系方式略)</span><br><span class="line"></span><br><span class="line">异常行为：</span><br><span class="line">xxx.xxx.xx.xx大量查询域名ircx.us.too,怀疑该IP已被入侵并被远程控制。</span><br></pre></td></tr></table></figure><p>留言共有两条：分别为 2024&#x2F;2&#x2F;21 20:44 和 2024&#x2F;2&#x2F;27 09:31 所留，均提示高频的 IRC 服务器域名 DNS 查询。</p><p>我简单用 <code>tcpdump -i lo port 53</code> 看了一下，发现了一秒钟多次的 DNS 查询。因为使用了 <code>systemd-resolved</code>，DNS 服务器为 systemd 的 127.0.0.53，故可以在本地回环链路上观察到。</p><p>经过观察，主要有到 <code>ircx.us.to</code>, <code>irc.dal.net</code>, <code>irc.undernet.org</code> 三个域名的查询，每秒查询超过 100 次。</p><p>显然，服务器应该是被黑了。</p></li><li><p>2024&#x2F;2&#x2F;28：在 @taoky 的帮助下进行了比较详尽的调查，花费了一个晚上。</p></li></ul><h2 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h2><p>该服务器位于科大校园网内，以 100Mbps 以太网链路接入管科楼，拥有学校的 IPv4 和 IPv6 地址，没有专门的网络通，需要上网时同学会登陆自己的网络通账号。</p><p>服务器为 Ubuntu 20.04 LTS，插有 10 (9?) 块 RTX3090 显卡。平常同学们通过 ssh 公钥登陆，或通过 (密码 + TOTP Code) 进行登陆（采用 <code>libpam-google-authenticator</code>，参考 <a href="https://ubuntu.com/tutorials/configure-ssh-2fa#2-installing-and-configuring-required-packages">link</a>）。</p><p>服务器共有 25 个用户，其中 5 个拥有 sudo 权限，3 个位于 docker 组。Docker daemon 运行在 root。</p><p>利用 <code>netstat -nlp</code> 可以看到上面有 pgyvpn，ZeroTier 等程序。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>大概的分析时间线如下：</p><h3 id="确定哪个进程在发出-DNS-请求"><a href="#确定哪个进程在发出-DNS-请求" class="headerlink" title="确定哪个进程在发出 DNS 请求"></a>确定哪个进程在发出 DNS 请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -np | grep 127.0.0.53:53 | grep udp</span><br><span class="line">udp        0      0 127.0.0.1:41511         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp      768      0 127.0.0.1:43814         127.0.0.53:53           ESTABLISHED 5973/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:44384         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:46012         127.0.0.53:53           ESTABLISHED 1989649/[           </span><br><span class="line">udp      768      0 127.0.0.1:52710         127.0.0.53:53           ESTABLISHED 5975/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:55295         127.0.0.53:53           ESTABLISHED 1989647/[           </span><br><span class="line">udp      768      0 127.0.0.1:55728         127.0.0.53:53           ESTABLISHED 5976/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:55801         127.0.0.53:53           ESTABLISHED 1986059/[kwor       </span><br><span class="line">udp        0      0 127.0.0.1:56095         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:57082         127.0.0.53:53           ESTABLISHED 2178005/[           </span><br><span class="line">udp        0      0 127.0.0.1:58772         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:59061         127.0.0.53:53           ESTABLISHED 1995387/[           </span><br><span class="line">udp        0      0 127.0.0.1:59165         127.0.0.53:53           ESTABLISHED 1986012/[           </span><br><span class="line">udp        0      0 127.0.0.1:60684         127.0.0.53:53           ESTABLISHED -                   </span><br></pre></td></tr></table></figure><p>可以看到怀疑对象有 PID 为 5976 和 1989649 等几个进程。</p><p>不过，登登登登：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps aux | grep 5975</span><br><span class="line">lzt        40314  0.0  0.0  19764  2856 pts/11   S+   22:41   0:00 grep --color=auto 5975</span><br></pre></td></tr></table></figure><p>这要拜 Rootkit 所赐，因为 <code>/etc/ld.so.preload</code> 里面加入了一些内容。不过也没事，可以用静态链接的 busybox 来看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./busybox cat /etc/ld.so.preload</span><br><span class="line">/usr/local/lib/dbus-collector/libdbus_x86_64.so</span><br><span class="line">/usr/local/lib/network.so</span><br><span class="line">$ sudo ./busybox ps aux | grep 5975</span><br><span class="line"> 5975 zx        5:43 ./nobody nmop</span><br><span class="line">44054 lzt       0:00 grep --color=auto 5975</span><br><span class="line">$ sudo ./busybox readlink -f /proc/5975/exe</span><br><span class="line">/home/zx/.cpan/nobody</span><br></pre></td></tr></table></figure><p>仔细检查，共有下面的用户拥有 .cpan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/spf/.cpan</span><br><span class="line">/home/xy/.cpan</span><br><span class="line">/home/zx/.cpan</span><br></pre></td></tr></table></figure><p>另外观察一下另外几个进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./busybox readlink -f /proc/1986059/exe</span><br><span class="line">/usr/bin/crond</span><br><span class="line">$ sudo ./busybox readlink -f /proc/1989647/exe</span><br><span class="line">/usr/bin/a</span><br><span class="line"># 下同</span><br></pre></td></tr></table></figure><h2 id="cron-日志暴露的内容"><a href="#cron-日志暴露的内容" class="headerlink" title="cron 日志暴露的内容"></a>cron 日志暴露的内容</h2><p>另外，在 journalctl 的 cron 条目里面可以额外发现一些信息：</p><details>  <summary>太长了，点这里观看</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">2月 28 22:53:01 GPU crontab[62015]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:54:01 GPU crontab[63492]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65423]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65424]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65427]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65425]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65428]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65429]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65430]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65423]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:55:01 GPU CRON[65424]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:55:01 GPU crontab[65438]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65425]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:56:01 GPU CRON[67335]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67338]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67334]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67339]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67336]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67340]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67342]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67334]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:56:01 GPU CRON[67335]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:56:01 GPU CRON[67336]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:56:01 GPU crontab[67351]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69561]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69564]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69562]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69560]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69565]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69566]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69567]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69562]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:57:01 GPU CRON[69560]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:57:01 GPU CRON[69561]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:58:01 GPU CRON[70918]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70917]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70919]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70920]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70921]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70923]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70922]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70924]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70919]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:58:01 GPU CRON[70918]: pam_unix(cron:session): session closed for user root</span><br></pre></td></tr></table></figure></details><p>这里可以额外看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/shm/.m-1013/dbus-collector.seed</span><br><span class="line">/root/.cpan/.cache/update</span><br><span class="line">/.dbus/auto</span><br></pre></td></tr></table></figure><p>三个脚本。</p><h2 id="用户账户的信息"><a href="#用户账户的信息" class="headerlink" title="用户账户的信息"></a>用户账户的信息</h2><p>可以看到被篡改的 <code>passwd</code> 和 <code>group</code>；木马甚至贴心的留了 <code>passwd-</code> 和 <code>group-</code> 作为备份…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ diff /etc/passwd /etc/passwd-</span><br><span class="line">78d77</span><br><span class="line">&lt; ghost:x:0:0::/:/bin/bash</span><br><span class="line">$ diff /etc/group /etc/group-</span><br><span class="line">1c1</span><br><span class="line">&lt; root:x:0:</span><br><span class="line">---</span><br><span class="line">&gt; root:x:0:bin</span><br><span class="line">21c21</span><br><span class="line">&lt; sudo:x:27:omnisky,chz,lzt,gjf,hy,nobody,bin</span><br><span class="line">---</span><br><span class="line">&gt; sudo:x:27:omnisky,chz,lzt,gjf,hy,nobody</span><br></pre></td></tr></table></figure><p><code>lastlog</code> 中提供了一些登陆信息。其中 <code>ghost</code> (a.k.a. <code>root</code>) 账户于 2 月 26 日被另一科大 IP 地址的主机登陆。由网络信息中心的相关老师查询得知上面登陆着其它 lab 的网络通。</p><p><code>ghost            pts/2    xxx.xxx.xxx.xx   一 2月 26 02:42:02 +0800 2024</code></p><blockquote><p>与 root 时间相同。</p></blockquote><h2 id="日志和文件修改时间"><a href="#日志和文件修改时间" class="headerlink" title="日志和文件修改时间"></a>日志和文件修改时间</h2><p>syslog 已经被 rotate, auth.log 被 rotate 或者被入侵程序删除了。</p><p>auth 里面可以发现 1 月 28 号就有 crontab 活动了：</p><details>  <summary>太长了，点这里观看</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Jan 28 00:00:01 GPU CRON[524365]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524366]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524367]: pam_unix(cron:session): session opened for user zx by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524368]: pam_unix(cron:session): session opened for user zx by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524369]: pam_unix(cron:session): session opened for user spf by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524365]: pam_unix(cron:session): session closed for user root</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524366]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524367]: pam_unix(cron:session): session closed for user zx</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524368]: pam_unix(cron:session): session closed for user zx</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524369]: pam_unix(cron:session): session closed for user spf</span><br></pre></td></tr></table></figure></details><h2 id="其他异常文件"><a href="#其他异常文件" class="headerlink" title="其他异常文件"></a>其他异常文件</h2><p>根目录多了很多花里胡哨的东西。</p><details>  <summary>太长了，点这里观看</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ ./busybox ls -alh /</span><br><span class="line">total 13M    </span><br><span class="line">drwxr-xr-x   26 root     root        4.0K Feb 28 11:22 .</span><br><span class="line">drwxr-xr-x   26 root     root        4.0K Feb 28 11:22 ..</span><br><span class="line">drwxr-xr-x    3 10000    jyx         4.0K Feb 25 17:28 .dbus</span><br><span class="line">lrwxrwxrwx    1 root     root           7 Jan 10  2023 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x    4 root     root        4.0K Dec  1  2019 boot</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 cdrom</span><br><span class="line">drwxr-xr-x   11 root     root        4.0K Dec  1  2019 data</span><br><span class="line">drwxr-xr-x   24 root     root        4.0K Dec  1  2019 data1</span><br><span class="line">drwxr-xr-x    4 root     root        4.0K Dec  1  2019 data2</span><br><span class="line">drwxr-xr-x   19 root     root        5.6K Dec  1  2019 dev</span><br><span class="line">drwxr-xr-x  149 root     root       12.0K Feb 28 23:44 etc</span><br><span class="line">-rw-r--r--    1 root     root        8.6M Feb 25 17:03 good</span><br><span class="line">drwxr-xr-x   31 root     root        4.0K Feb 28 10:21 home</span><br><span class="line">-rwxr-xr-x    1 root     root       61.4K Dec  1  2019 kwk</span><br><span class="line">lrwxrwxrwx    1 root     root           7 Jan 10  2023 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx    1 root     root           9 Jan 10  2023 lib32 -&gt; usr/lib32</span><br><span class="line">lrwxrwxrwx    1 root     root           9 Jan 10  2023 lib64 -&gt; usr/lib64</span><br><span class="line">lrwxrwxrwx    1 root     root          10 Jan 10  2023 libx32 -&gt; usr/libx32</span><br><span class="line">drwx------    2 root     root       16.0K Dec  1  2019 lost+found</span><br><span class="line">drwxr-xr-x    3 root     root        4.0K Dec  1  2019 media</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 mnt</span><br><span class="line">-rwxr-xr-x    1 root     root        4.0M Dec  1  2019 mx</span><br><span class="line">drwxr-xr-x   24 root     root        4.0K Dec  1  2019 old_os</span><br><span class="line">drwxr-xr-x    7 root     root        4.0K Dec  1  2019 opt</span><br><span class="line">dr-xr-xr-x 1422 root     root           0 Dec  1  2019 proc</span><br><span class="line">drwx------   12 root     root        4.0K Feb 28 23:44 root</span><br><span class="line">drwxr-xr-x   39 root     root        1.3K Feb 29 00:29 run</span><br><span class="line">lrwxrwxrwx    1 root     root           8 Jan 10  2023 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   11 root     root        4.0K Dec  1  2019 snap</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 srv</span><br><span class="line">dr-xr-xr-x   13 root     root           0 Dec  1  2019 sys</span><br><span class="line">drwxrwxrwt  647 root     root      148.0K Feb 29 00:30 tmp</span><br><span class="line">drwxr-xr-x   14 root     root        4.0K Dec  1  2019 usr</span><br><span class="line">drwxr-xr-x   16 root     root        4.0K Dec  1  2019 var</span><br><span class="line">drwxrwxr-x    2 root     root        4.0K Feb 28 11:26 x</span><br></pre></td></tr></table></figure></details><p>多了 <code>/x</code>，<code>/mx</code> 和 <code>/kwk</code>，<code>/good</code>，<code>/.dbus</code>。</p><h2 id="crontab-分析"><a href="#crontab-分析" class="headerlink" title="crontab 分析"></a>crontab 分析</h2><details>  <summary>太长了，点这里观看</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ls -alh /var/spool/cron/crontabs/</span><br><span class="line">total 28K</span><br><span class="line">drwx-wx--T 2 root crontab 4.0K 2月  26 13:57 .</span><br><span class="line">drwxr-xr-x 3 root root    4.0K 8月  31  2022 ..</span><br><span class="line">-rw------- 1 root crontab  291 2月  25 17:28 root</span><br><span class="line">-rw------- 1 spf  crontab  277 2月  17  2023 spf</span><br><span class="line">-rw------- 1 xy   crontab  233 2月  17  2023 xy</span><br><span class="line">-rw------- 1 yyy  crontab  261 2月  26 13:57 yyy</span><br><span class="line">-rw------- 1 zx   crontab  343 2月  20  2023 zx</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/yyy</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (- installed on Mon Feb 26 13:57:19 2024)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line"># DO NOT REMOVE THIS LINE. dbus-kernel</span><br><span class="line">* * * * * /dev/shm/.m-1013/dbus-collector.seed</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/root</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (/tmp/crontab.ZblArV/crontab installed on Sun Feb 25 17:28:18 2024)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">* * * * * /.dbus/auto &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/zx</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (.autobotchk1676891606017226.97733 installed on Mon Feb 20 19:13:26 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">0,10,20,30,40,50 * * * * /home/zx/.cpan/dumb.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">0,10,20,30,40,50 * * * * /home/zx/.cpan/nmop.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/spf</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (.autobotchk1676636637503791.1778717 installed on Fri Feb 17 20:23:57 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">0,10,20,30,40,50 * * * * /home/spf/.cpan/spf.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/xy</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (cron installed on Fri Feb 17 18:26:23 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">* * * * * /home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></details><p>其中 <code>/home/xy/.cpan/.cache/update</code> 脚本的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">if test -r /home/xy/.cpan/.cache/mech.pid; then</span><br><span class="line">pid=$(cat /home/xy/.cpan/.cache/mech.pid)</span><br><span class="line">if $(kill -CHLD $pid &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">then</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">cd /home/xy/.cpan/.cache</span><br><span class="line">./run &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure><p>其实就是调用 run 的，然后 run 来启动 botnet 的客户端。</p><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><blockquote><p>Special thanks to @taoky.</p></blockquote><ul><li><code>/kwk</code>: <a href="https://www.virustotal.com/gui/file/6e4d58a1fe5d7add270d5819ac8e8c17a0aff8d928be185d563b569759972979">VirusTotal</a><ul><li>会把自己假装成 <code>[kworker/0:0]</code></li><li>作为 IRCBot 连接到 <code>#ddoser</code> 频道</li></ul></li><li><code>/mx</code>: <a href="https://www.virustotal.com/gui/file/c21368ef860eaef0ac1c259f1fb584ab752044824021d8ca9455b41c44f2b08a">VirusTotal</a><ul><li>加壳了的 golang 程序</li></ul></li><li><code>/good</code> 是个 tar.gz，里面看起来是那个 “dbus” 程序，可以用来挖门罗币<ul><li><code>README</code>: <del>最担心你不会用恶意软件的一集</del><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(: I MAKE THIS FOR FREE, SHARE IT IF YOU LIKE :)</span><br><span class="line">  ==========================================</span><br><span class="line">            noname but not nobody</span><br><span class="line"></span><br><span class="line">This miner can run as root or user :)</span><br><span class="line"></span><br><span class="line">Simple &amp; easy to use. No naughty backdoor.</span><br><span class="line"></span><br><span class="line">Commands :</span><br><span class="line">----------</span><br><span class="line">1. Create config.json first, use : ./mkcfg &lt;Mining Pool:Port&gt; &lt;Worker ID&gt; &lt;Wallet&gt;</span><br><span class="line">2. Start the mining : ./start</span><br><span class="line"></span><br><span class="line">Note :</span><br><span class="line">------</span><br><span class="line">For proxy, use : ./mkcfg &lt;Mining Pool Proxy:Port&gt; &lt;Worker ID&gt; &lt;Wallet&gt;</span><br><span class="line"></span><br><span class="line">Extra :</span><br><span class="line">------</span><br><span class="line">32       = Change into 32-bit</span><br><span class="line">64       = Change into 64-bit</span><br><span class="line">power-on = Extra command :D</span><br><span class="line"></span><br><span class="line">Source files from https://github.com/xmrig (has no virus except you&#x27;re gay)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>dbus/bash</code>: <a href="https://www.virustotal.com/gui/file/e9422ff3a83835b47aac93912eca4de2c5d361d0a743672bf7ae6621ea10c226">VirusTotal</a></li><li><code>dbus/hide</code>: <a href="https://www.virustotal.com/gui/file/b21d43db4ea65ac178199d1aed1fea0352de0f268a46fbc13fcb719ce50042c9">VirusTotal</a></li><li><code>dbus/power-on</code>: <a href="https://www.virustotal.com/gui/file/738abe5627539b952768e19135db62aac37469e6c9a4f08b29e61bee30ef6cdf">VirusTotal</a><ul><li>作为 IRCBot 连接到 <code>#kaiten</code> 频道<blockquote><p>“Kaiten”这个名称源自日语，意为“回转寿司”，可能是因为这种恶意软件就像回转寿司那样在受控系统之间“旋转”指令。通过IRC频道，攻击者可以远程控制和指挥受感染的机器进行各种活动，包括但不限于发动DDoS攻击、窃取数据、安装更多的恶意软件等。</p><p><strong>“这下服务器变回转寿司了，最美味的一集”</strong> (courtesy @taoky)</p></blockquote></li><li>会把自己假装成 <code>[kworker/0:0]</code></li><li>可以执行一系列 DDoS 攻击和 remote code execution 命令</li></ul></li><li><code>xtra/</code>:<ul><li><code>centos</code> <a href="https://www.virustotal.com/gui/file/efebb75160eda563e3684619d0ace367366b18bb180fcdbbdbe83269fd530e28">VirusTotal</a></li><li><code>ubuntu</code> <a href="https://www.virustotal.com/gui/file/137f0a89bd16dd0fcc89229bf6de37a230d49e812b47b4482aff6db45b7ac74a">VirusTotal</a></li><li><code>32</code> <a href="https://www.virustotal.com/gui/file/b63b26edbaf0a95cb34d72cfe5aef3ee3c8a565b98faa1ee51c3694b10720837">VirusTotal</a></li><li><code>64</code> <a href="https://www.virustotal.com/gui/file/a7155491bcde2c4bc89f9f37d03c668e32cdb15ad992dd8c3d96b709b494a542">VirusTotal</a></li></ul></li></ul></li><li><code>/home/spf/.cpan/</code>: 一个 botnet 程序，里面一堆 Tcl 脚本和一些可执行文件<ul><li><code>hide</code>: <a href="https://www.virustotal.com/gui/file/e560ae6672fc7c09bfb72f6a1939f0b03108ed5b0a7d2ef1f5c49211e9d6d02c">VirusTotal</a></li><li><code>nobody</code>: 无检出，strings 一把看起来像 Tcl 解释器 + 一些奇怪东西，<a href="https://www.virustotal.com/gui/file/3fcfaa232e3471c5d40c9396507291d3be34eaafb60f44fd243f23974bd5f001">VirusTotal</a></li></ul></li><li><code>/dev/shm/.m-1013/dbus-collector</code>: <a href="https://www.virustotal.com/gui/file/21c6dfcbd865b57cf5a15f4dc9498e378a7ccec7bbea9ff446884a9b5cb572ec/">VirusTotal</a></li><li><code>/x</code>: 端口扫描和 SSH 暴力攻击程序<ul><li><code>x/ban</code>: <a href="https://www.virustotal.com/gui/file/2ef26484ec9e70f9ba9273a9a7333af195fb35d410baf19055eacbfa157ef251">VirusTotal</a></li><li><code>x/m</code>: <a href="https://www.virustotal.com/gui/file/9aa8a11a52b21035ef7badb3f709fa9aa7e757788ad6100b4086f1c6a18c8ab2">VirusTotal</a></li><li><code>x/SSH</code>: <a href="https://www.virustotal.com/gui/file/6163a3ca3be7c3b6e8449722f316be66079207e493830c1cf4e114128f4fb6a4">VirusTotal</a></li></ul></li><li><code>/usr/local/lib/dbus-collector/libdbus_x86_64.so</code>: <a href="https://www.virustotal.com/gui/file/2aed4d101703a74dcc0f5c51506cc376136872c864fc0484a5684cda9c81685b">VirusTotal</a><ul><li>尝试隐藏 <code>dbus_collector</code>，通过 hook readdir{64} 并且解析是否是对 <code>/proc</code> 的列目录；如果是，则返回去掉自己结果的列目录结果，从而达到在 ps 和 htop 等工具中隐藏的目的</li></ul></li><li><code>/usr/local/lib/network.so</code>: <a href="https://www.virustotal.com/gui/file/987d390480b55dcf61e18106b326e706a7a14c7cb6c8f13c35a5b90e068166b6">VirusTotal</a><ul><li>尝试隐藏自己，通过 hook readdir{64} 并且解析是否是对 <code>/proc</code> 的列目录；如果是，则返回去掉自己结果的列目录结果，从而达到在 ps 和 htop 等工具中隐藏的目的</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>病毒已经有 root 权限</li><li>由于发现的比较晚，很多日志 rotate 了，并且日志没有配置实时发送到远程服务器等，导致基本很难断定最初的入侵是什么时候发生的。不过基本可以确定，病毒最早在 1 月 28 日或之前就已经黑进系统了。</li><li>系统里面一共有四种类型的病毒：挖矿病毒，DDoS肉鸡病毒，远程控制病毒，SSH扫描病毒；同时，有病毒有隐藏功能，会在 &#x2F;etc&#x2F;ld.so.preload 里面写上自己的动态库，导致所有动态链接的程序运行前均调用病毒程序</li><li>远程控制病毒会互相连接，并且存在通过authorized_keys互相跳转的可能性；但是auth.log已经看不到那么远的日志了，可能是被rotate或者删除了</li><li>可以通过publickey方式登陆服务器的账户最好检查一下自己的主机是否已经中毒（因为publickey跳转是一种可能的感染路径，虽然没有读 code 证实）</li></ol><p>远程控制病毒用的是 IRC 和黑客以及其他节点保持连接，并且存在对方进一步下载其它payload（比如，勒索病毒）的可能性。</p><blockquote><p>此时只能建议大家赶紧备份数据到自己的机器，同时注意服务器上所有的可执行程序都应该认为是<em>不可信任的</em>：即，存在被病毒感染的可能性。有些存在任意代码执行的文件格式也存在被入侵的理论可能（比如 torch 非 safetensor 的 checkpoint 文件）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;炼丹炉被黑了，以下是事情经过：&lt;/p&gt;
&lt;h2 id=&quot;流水账&quot;&gt;&lt;a href=&quot;#流水账&quot; class=&quot;headerlink&quot; title=&quot;流水账&quot;&gt;&lt;/a&gt;流水账&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2024&amp;#x2F;2&amp;#x2F;27：师兄发现在实验室服务器上登陆</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mesa radv 源码阅读（一）: 如何跟踪图形栈、Vulkan Loader、Mesa 派发机制</title>
    <link href="https://blog.libreliu.info/mesa-radv-digestion/"/>
    <id>https://blog.libreliu.info/mesa-radv-digestion/</id>
    <published>2023-07-01T16:00:00.000Z</published>
    <updated>2023-07-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>变更记录:</p><ul><li>2023-02-11: 开始写作本文</li><li>2023-02-16: 基本完成</li><li>2023-07-02: 移出草稿区</li></ul></blockquote><p>Mesa radv 全称 Mesa Vulkan Radeon 驱动，用于 Linux 桌面平台下 AMD Radeon 独立和集成显示卡的 Vulkan 用户态驱动支持。本文主要为备忘性质，记录笔者调试和跟踪代码过程中的发现。</p><p>笔者本人接触 Linux 图形栈的时间并不很长，其中很多地方还不甚明了，如有缺漏之处，请批评指正。</p><p>您可以在博客对应的<a href="https://github.com/libreliu/libreliu.github.io">仓库</a> 的 Issue 区和我取得联系。</p><blockquote><p>本文的实验均开展于截至写作时最新版本的 Arch Linux。<br>使用的主要软件版本如下：</p><ul><li>mesa 22.3.3<ul><li><a href="https://gitlab.freedesktop.org/mesa/mesa/">https://gitlab.freedesktop.org/mesa/mesa/</a></li></ul></li><li>vulkan-icd-loader 1.3.240<ul><li><a href="https://github.com/KhronosGroup/Vulkan-Loader">https://github.com/KhronosGroup/Vulkan-Loader</a></li></ul></li></ul></blockquote><h2 id="前言：如何跟踪-Linux-图形栈？"><a href="#前言：如何跟踪-Linux-图形栈？" class="headerlink" title="前言：如何跟踪 Linux 图形栈？"></a>前言：如何跟踪 Linux 图形栈？</h2><p>截至目前，笔者认为图形栈的跟踪和开发，较常规的 Linux 服务端开发等工作要更为复杂。</p><p>这种复杂性主要来源于：</p><ol><li>厂商图形实现是高度定制化的，在通用图形 API (e.g. Vulkan, OpenGL) 下，厂商有很大的自由度来填补从用户程序图形 API 到真正向图形处理器发送命令的过程<ul><li>e.g. AMD 的 mesa Vulkan 开源驱动 radv 会经过 vulkan-icd-loader 到 mesa 到 libdrm 到内核态 amdgpu</li></ul></li><li>用户的图形应用程序还需要经过窗口系统和混成器 (compositor) 才能显示到屏幕上，图形实现需要和混成器紧密配合<ul><li>X11 (DIX, DDX), GLX, DRI2, DRI3, Wayland, egl…</li><li>历史包袱比较多</li></ul></li></ol><p>除此之外，上面的两个方面，其中各个环节的接口文档都不甚清晰，且接口演进也比较频繁，很多时候需要「一竿子捅到底」，将各个库和软件的源码连在一起阅读，才知道真正发生了什么。</p><h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><p>针对这种情况，首先需要比较方便的 C&#x2F;C++ 源码阅读软件，笔者目前使用的是 OpenGrok。</p><p>该软件对源码的语义理解并不很强，因为其仅仅是采用 ctags 的方法进行简单的解析，对于需要经过预处理器的一些嵌入的宏 （比如 <code>#define WSI_CB(cb) PFN_vk##cb cb</code> 这种样式的成员定义宏）支持并不好。其优势主要体现在跳转快速 (HTML 链接点击即跳转)，以及还算方便的 Full search 功能（比如要搜索某个函数指针成员 <code>wait</code> 在哪里被调用，可以搜 <code>&quot;-&gt;wait&quot;</code> 和 <code>&quot;.wait&quot;</code>）。某种意义上，笔者认为该软件可以认为是本地部署的、可以看不仅仅是内核的软件代码的增强版本 <a href="https://elixir.bootlin.com/">elixir</a>。</p><blockquote><p>其实感觉可以做一个用 Arch Linux 的 makepkg 构建过程中生成 <code>compile_commands.json</code> 并且用这个信息来指导源码阅读的工作流，最好信息都可以离线 bake 然后静态的托管到某些网站上。目前我还没发现有这样的工具存在。</p><p>TODO: 调研<a href="https://github.com/KDAB/codebrowser">静态的 CodeBrowser</a>。</p></blockquote><p>另一个比较有用的准备工作是，把一个软件包的依赖的源码全部下载下来放在一起，统一放到 OpenGrok 里面，这样可以极大加速跨软件包的符号和定义的查找工作。</p><blockquote><p>这里我选择 Arch Linux 的 pacman 包作为起点进行依赖查找。</p><p>值得注意的是，Arch 的包管理模型中有 “虚拟包” 的概念，比如 <code>opengl-driver</code> 可以被 depend 和 provide，但是并不对应一个具体的包；这样的依赖很多时候需要人工去 resolve。</p><p>TODO: 等整套工具比较完善之后，写一篇博客介绍如何将系列包的源码全部拉下来。</p></blockquote><h3 id="动态跟踪"><a href="#动态跟踪" class="headerlink" title="动态跟踪"></a>动态跟踪</h3><p>另一个十分有用的步骤自然是运行时的行为跟踪了。</p><p>行为跟踪主要是采用 GDB + debuginfod + (感兴趣的软件包的) <code>-debug</code> 软件包。</p><p>在没有加载调试符号的情况下，GDB 的 <code>step</code> 似乎会直接越过外部函数，这种时候可以考虑 <code>layout asm</code> 看汇编，用 <code>stepi</code> 进到 call 指令里面去，GDB 此时的 backtrace 会打印出该函数所在地址对应的动态链接库 (当然，应该是从进程地址空间信息 <code>/proc/&lt;PID&gt;/maps</code> 反查的)，但具体的函数则不详。动态链接库信息可以用来让你想想到底是什么东西缺符号。</p><p>正确配置的 debuginfod 可以完成自动拉取加载的动态链接库的符号的工作，不过要看到源码本身还是需要安装 debug 包。</p><blockquote><p>安装好 -debug 包后，对应的源码会在 <code>/usr/src/debug/</code> 下。</p></blockquote><p>debug 包的主要获取方法有两种，详情可以参考 <a href="https://wiki.archlinux.org/title/Debugging/Getting_traces">Debugging&#x2F;Getting traces - ArchWiki</a>：</p><ol><li>特定的 Archlinux mirror<ul><li><a href="https://geo.mirror.pkgbuild.com/">https://geo.mirror.pkgbuild.com/</a></li><li>但是个别包似乎会出现 debug 包内源码不全的情况，如 <code>vulkan-icd-loader</code>，不清楚具体原因；方法 2 无此问题</li></ul></li><li>自己编译</li></ol><p>关于如何编译 debug 包，值得简单记两笔。</p><p>打 debug 包需要 </p><ol><li>拉 PKGBUILD <ul><li>可以考虑用 <code>asp</code> 这个工具自动从 GitHub (https 的话需要配合 <code>proxychains</code> 科学上网) 上面拉对应的 recipe </li><li><a href="https://xyne.dev/projects/pbget/">pbget</a> 这个工具不知道是否可以用于自动化的把依赖项目的 recipe 全部拉下来 (?)<ul><li>我自己测试是不行，不过是用 Python 3 + pyalpm 写的，有一定的研究和修改价值</li></ul></li></ul></li><li>进行编译<ul><li><a href="https://wiki.archlinux.org/title/DeveloperWiki:Building_in_a_clean_chroot">ArchWiki</a> 推荐使用 clean chroot 编译，这样也方便设定单独的 makepkg 的设置 </li><li>使用 Wiki 中描述的，方便的方法如下：<ol><li>安装 devtools 包 </li><li>更改 chroot 环境内的 makepkg 配置，启用 OPTIONS 中的 debug 和 strip<ul><li><code>/usr/share/devtools/makepkg-$&#123;arch&#125;.conf</code> 这里 arch 选择 x86_64</li><li>(optional) 把并行编译的 -j 也设置好，不过有些构建系统会自动检测并启用并行编译</li></ul></li><li>在有 PKGBULID 的文件夹下面运行 <code>extra-x86_64-build</code>，然后装源码包和二进制包 （pacman -U)<ul><li>包检查不过去没啥事；两个包都要装上，因为调试符号匹配的时候应该是有一个随机生成的 UUID 来做的</li><li>如果想给 makepkg 传参需要加两个 –，比如 <code>extra-x86_64-build -- -- --skippgpcheck</code></li></ul></li></ol></li></ul></li></ol><p>在看 elfutils 的时候同时看到了一个工具 <code>eu-stack</code>，可以用来截取某个进程当前时刻所有线程的栈信息，并且可以加选项 <code>-m</code> 来用 debuginfod 进行符号查找。</p><p>感觉在分析 GUI 程序高 CPU 占用的性能分析的场合，<code>eu-stack</code> 可以作为一种采样手段使用。</p><h2 id="Vulkan-Loader"><a href="#Vulkan-Loader" class="headerlink" title="Vulkan Loader"></a>Vulkan Loader</h2><p>Vulkan Loader 是垫在各个 Vulkan 驱动和用户程序中间的层，主要用来解决多设备枚举使用的问题。</p><h3 id="驱动枚举"><a href="#驱动枚举" class="headerlink" title="驱动枚举"></a>驱动枚举</h3><p>Vulkan Loader 有默认的 ICD (Installable Client Driver) 的<a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-discovery-on-linux">搜索路径</a>，向系统中安装的驱动程序会通过在给定的 ICD 路径（可能是文件夹，也可能是 Windows 注册表）中写入信息的方式来向 Vulkan Loader 报告自己的信息。</p><p>例如，<code>/usr/share/vulkan/icd.d/radeon_icd.x86_64.json</code> 中的信息如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ICD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;api_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.3.230&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;library_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/lib/libvulkan_radeon.so&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file_format_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，核心的信息是 <code>library_path</code>。(Ref: <a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-manifest-file-format">LoaderDriverInterface.md @ Vulkan-Loader</a>)</p><p>另一种传入 ICD 信息的方法是 <code>VK_DRIVER_FILES</code> 环境变量（<a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderInterfaceArchitecture.md#elevated-privilege-caveats">不过在 root 权限下无效</a>），可以通过指定这个变量的方式，强制 Vulkan Loader 只考虑某些路径。</p><p>比如 <code>VK_DRIVER_FILES=/usr/share/vulkan/icd.d/radeon_icd.x86_64.json vulkaninfo</code> 可以只启用 mesa radv 实现。</p><h3 id="驱动入口发现"><a href="#驱动入口发现" class="headerlink" title="驱动入口发现"></a>驱动入口发现</h3><p>每个驱动要实现 <code>vk_icdGetInstanceProcAddr</code> 这个调用，和 (&gt;&#x3D; Version 4) <code>vk_icdGetPhysicalDeviceProcAddr</code> 这个调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(VKAPI_PTR *PFN_vkVoidFunction)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的调用，如 vkCreateInstance，会把第一个参数置为空</span></span><br><span class="line"><span class="comment">// 先用这个调用拿到 `vkGetDeviceProcAddr`，再进行 device level 的调用</span></span><br><span class="line">VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL <span class="title function_">vk_icdGetInstanceProcAddr</span><span class="params">(</span></span><br><span class="line"><span class="params">   VkInstance instance,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span>* pName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要用于 VkPhysicalDevice 为第一个参数的 Vulkan API 派发</span></span><br><span class="line"><span class="comment">// - 否则 Vulkan Loader 会认为这个命令是 logical device command，</span></span><br><span class="line"><span class="comment">//   从而尝试传入 VkDevice 对象 </span></span><br><span class="line"><span class="comment">// 典型用途是一些 loader 不知道的物理设备扩展</span></span><br><span class="line"><span class="comment">// (&gt;= Version 7) 这个接口需要可以从 vk_icdGetInstanceProcAddr 获得</span></span><br><span class="line">PFN_vkVoidFunction <span class="title function_">vk_icdGetPhysicalDeviceProcAddr</span><span class="params">(</span></span><br><span class="line"><span class="params">   VkInstance instance,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span>* pName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>有些厂商会在同一个库里面实现几套 API 的用户态实现 (e.g. <code>nvidia_icd.json</code> 中的 <code>libGLX_nvidia.so.0</code>)，但驱动程序不能把 Vulkan 官方的函数名占用掉。</p><p>动态链接到 Vulkan Loader 的<strong>用户程序</strong>是通过系统例程 (<code>dlsym</code> 或者 <code>GetProcAddress</code>) 获得 <code>vkGetInstanceProcAddr</code> 和 <code>vkGetDeviceProcAddr</code> 两个函数的地址并且调用的方式来枚举其它 Vulkan API 调用的函数地址的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, <span class="type">const</span> <span class="type">char</span>* pName)</span><br><span class="line">PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, <span class="type">const</span> <span class="type">char</span>* pName)</span><br></pre></td></tr></table></figure><p>Loader 的 <code>vkGetInstanceProcAddr</code> 的行为在<a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-unknown-physical-device-extensions">官方文档</a>中有记录。</p><p>简单来说，就是用 <code>vk_icdGetInstanceProcAddr</code> 一路往下找，找到的会记录在跳转表中，之后在 terminator 那边可以直接跳转过去，不用再获取。</p><h3 id="驱动-Vulkan-对象句柄要求"><a href="#驱动-Vulkan-对象句柄要求" class="headerlink" title="驱动 Vulkan 对象句柄要求"></a>驱动 Vulkan 对象句柄要求</h3><blockquote><p>Ref: <a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-dispatchable-object-creation">https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-dispatchable-object-creation</a></p></blockquote><p>另一个值得了解的是 Vulkan 对象模型。<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-objectmodel-overview">3.3 Object Model @ Vulkan Spec</a> 中提到，Vulkan API 层面提供的 <code>VkXXXXX</code> 等类型均为 Vulkan 对象的句柄，句柄分为可分派的 (dispatchable) 和不可分派的 (non-dispatchable) 两种。</p><ul><li>可分派句柄 <code>VK_DEFINE_HANDLE()</code>: 指向某对用户不可见的具体实现类型的指针<ul><li>截至 Vulkan SDK 1.3.236 有 <code>VkInstance</code>, <code>VkPhysicalDevice</code>, <code>VkDevice</code>, <code>VkQueue</code>, <code>VkCommandBuffer</code></li></ul></li><li>不可分派句柄 <code>VK_DEFINE_NON_DISPATCHABLE_HANDLE()</code>：64-bit 整数类型，具体意义由实现决定<ul><li>如果开启了 <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#private-data">Private Data</a> 扩展的话，显然也得是指向内部实现类型的某指针（类似可分派句柄）</li><li>否则，实现可以决定在这 64-bit 里面直接编码好信息，不用指针</li></ul></li></ul><p>在此基础上，Vulkan Loader 要求驱动程序返回可分派句柄时：</p><ol><li>句柄作为指针指向的内部实现的前 <code>sizeof(uintptr)</code> 个字节要空出来，留待 Vulkan Loader 将这一位置的值替换成跳转表地址<ul><li>这也要求，指向的内部实现需要是 POD 的，否则可能会有虚表等结构加在实例前面，和这一要求冲突</li></ul></li><li>这个空出来的位置，需要调用 <code>include/vulkan/vk_icd.h</code> 中的 <code>set_loader_magic_value</code> 设置成 <code>ICD_LOADER_MAGIC</code> (目前是 <code>0x01CDC0DE</code>)，Vulkan Loader 拿到之后会用 <code>valid_loader_magic_value</code> 来检测驱动程序是否正确实现了这一要求</li></ol><h3 id="特例-WSI-扩展"><a href="#特例-WSI-扩展" class="headerlink" title="特例: WSI 扩展"></a>特例: WSI 扩展</h3><blockquote><p>Ref: <a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#handling-khr-surface-objects-in-wsi-extensions">https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#handling-khr-surface-objects-in-wsi-extensions</a></p></blockquote><p>在下面的平台上，<code>VkSurfaceKHR</code> 可以由 Vulkan Loader 负责创建和销毁：</p><ul><li>Wayland, XCB, Xlib</li><li>Windows</li><li>Android, MacOS, QNX</li></ul><p>对相应的 <code>vkCreateXXXSurfaceKHR</code> 调用，Loader 创建 VkIcdSurfaceXXX 结构，驱动程序拿到 <code>VkSurfaceKHR</code> 后可以将其视为到 <code>VkIcdSurfaceXXX</code> 的指针。</p><p>不过，如果驱动想自己接管，暴露所有 WSI KHR 要求的接口给驱动就可以了 (创建销毁，枚举 Surface 相关属性、呈现模式，创建交换链)。</p><h2 id="Mesa-Vulkan-radv"><a href="#Mesa-Vulkan-radv" class="headerlink" title="Mesa Vulkan radv"></a>Mesa Vulkan radv</h2><p>Mesa 是一个相对比较庞大的项目。</p><p>本次要看的 Mesa Vulkan radv 驱动的代码主要分布在：</p><ul><li><code>src/amd/vulkan/</code>: radv_ 开头的主要代码</li><li><code>src/vulkan</code>: 驱动公共设施</li></ul><p>Mesa 的构建系统使用 Meson，<code>src/amd/vulkan/meson.build</code> 中的 <code>libvulkan_radeon</code> 就是构建出的 radv 驱动动态链接库了。</p><h3 id="函数派发"><a href="#函数派发" class="headerlink" title="函数派发"></a>函数派发</h3><blockquote><p>Ref: <a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/docs/vulkan/dispatch.rst">https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/docs/vulkan/dispatch.rst</a></p></blockquote><p>我们先看 <code>vk_icdGetInstanceProcAddr</code> 的派发流程：</p><ul><li><code>vk_icdGetInstanceProcAddr</code> (src&#x2F;amd&#x2F;vulkan&#x2F;radv_device.c)</li><li><code>radv_GetInstanceProcAddr</code>  (src&#x2F;amd&#x2F;vulkan&#x2F;radv_device.c)</li><li><code>vk_instance_get_proc_addr</code> (src&#x2F;vulkan&#x2F;runtime&#x2F;vk_instance.c)</li></ul><p>传入的 <code>radv_instance_entrypoints</code> 是一个全局变量，给出了 Instance Level 的驱动实现的函数指针。其<strong>内容</strong>是在构建过程中生成的 <code>src/amd/vulkan/radv_entrypoints.c</code> 中赋值的，而<strong>类型</strong>则是在构建过程中生成的 <code>src/vulkan/util/vk_dispatch_table.h</code> 中定义的 <code>vk_instance_entrypoint_table</code> 类型的结构体。</p><p><code>radv_entrypoints.c</code> 定义了很多 <code>radv_XXXX</code> 形式的弱符号，并且将这些符号凑成了</p><ul><li><code>radv_instance_entrypoints</code></li><li><code>radv_physical_device_entrypoints</code></li><li><code>radv_device_entrypoints</code></li><li><code>sqtt_device_entrypoints</code></li><li><code>metro_exodus_device_entrypoints</code></li><li><code>rra_device_entrypoints</code></li></ul><p>几张表，表中填写了全部弱符号的值。根据弱符号的性质，如果程序中的其他地方没有定义相应的函数，对应的值就会为空。</p><p><code>vk_dispatch_table.h</code> 和 <code>vk_dispatch_table.c</code> 本身是用 <code>vk_dispatch_table_gen.py</code> 和 Vulkan Registry XML 生成出来的。</p><p>而常用的这几个派发用的函数都是在生成的 <code>vk_dispatch_table.c</code> 中定义的：</p><ul><li><code>vk_instance_dispatch_table_get_if_supported</code></li><li><code>vk_physical_device_dispatch_table_get_if_supported</code></li><li><code>vk_device_dispatch_table_get_if_supported</code></li></ul><p>如果对应的函数实际上没有实现 (比如 <code>radv_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI</code> 这个华为公司的扩展显然就没有)，那么前面几个派发表查询函数查询的结果就会为 NULL。</p><p>至于 CreateDevice 等处出现的 <code>vk_instance_dispatch_table</code>，则是多个 entrypoint table “综合”的结果，这样就可以实现比如 <code>radv_xxx</code> 没有就回退到 <code>vk_common_xxx</code> 的效果。</p><h3 id="vk-common-xxx"><a href="#vk-common-xxx" class="headerlink" title="vk_common_xxx"></a><code>vk_common_xxx</code></h3><p>一些公共入口点，里面包含了：</p><ul><li>用 <code>VkFoo2()</code> 实现 <code>VkFoo()</code> 的一些替代逻辑，这样驱动就可以把老的接口删掉，由中间层来做兼容</li><li>VkFence，VkSemaphore 和 VkQueueSubmit2 的默认实现<ul><li>当然，也需要驱动提供一些东西，比如 <code>vk_sync_type</code> 的实现</li></ul></li></ul><h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><ul><li><code>radv_physical_device</code>: <del>万物之始</del><ul><li><code>radv_CreateDevice</code></li></ul></li><li>句柄操作：<ul><li><code>VK_DEFINE_HANDLE_CASTS</code>: 定义（带自己搓的类型检查的）转换函数</li><li><code>VK_FROM_HANDLE</code>：从 <code>VkXXX</code> 转到 Mesa 驱动自己的结构体的句柄</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;变更记录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2023-02-11: 开始写作本文&lt;/li&gt;
&lt;li&gt;2023-02-16: 基本完成&lt;/li&gt;
&lt;li&gt;2023-07-02: 移出草稿区&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mesa </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>可能是史上最详尽的 QEM 网格简化算法解释</title>
    <link href="https://blog.libreliu.info/qem-mesh-simplification/"/>
    <id>https://blog.libreliu.info/qem-mesh-simplification/</id>
    <published>2023-04-10T16:00:00.000Z</published>
    <updated>2023-04-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QEM 算法（<a href="http://dl.acm.org/citation.cfm?id=288280">Garland and Heckbert [1998]</a>）是网格简化领域的经典算法。</p><h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><p><a href="https://github.com/byreave/MeshSimplification-QEM">GitHub - byreave&#x2F;MeshSimplification-QEM: A C++implementation of QEM algorithm.</a></p><p><a href="https://github.com/WZFish/QEM-MeshSimplification">GitHub - WZFish&#x2F;QEM-MeshSimplification</a></p><p><a href="https://github.com/songrun/SeamAwareDecimater">GitHub - songrun&#x2F;SeamAwareDecimater: Mesh simplification with UV’s boundary preserved</a></p><p><a href="https://github.com/MeshFrame/MeshFrame/blob/master/Examples/MeshSimplifyQEM/mesh.cpp">GitHub - MeshFrame&#x2F;MeshFrame: A light-weighted, efficient and header-only mesh processing frame work</a></p><h2 id="QEM-Original"><a href="#QEM-Original" class="headerlink" title="QEM Original"></a>QEM Original</h2><blockquote><p>出现于文章 <a href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">Surface Simplification Using Quadric Error Metrics</a> 中</p></blockquote><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>设现在有网格 $ M &#x3D; (V, F) $，规定<strong>可收缩顶点对</strong>为</p><ol><li>原网格中的边</li><li>$ \| v_1 - v_2\| < \epsilon $ 的顶点对 $ (v_1, v_2) $</li></ol><p>对每个三角形 $ F_i $，设构成该三角形的三个顶点为 $ v_0, v_1, v_2 $，则 $ F_i $ 上的点 $ v_f $ 满足方程</p>$$(\vec v_f- \vec v_0) \cdot \vec n = 0 \Rightarrow \vec v_f \cdot \vec n - \vec {v_0} \cdot \vec n = 0$$<p>其中面法线 $ \vec n $ 满足</p>$$\vec {n} =  \frac{(\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0)}{\| (\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0) \|}$$<p>空间中任意一点 $ v $ 到平面 $ F_i $ 的距离的平方为</p>$$\begin{aligned}d^2(v, F_i) &= \| (\vec v-\vec v_0) \cdot \vec n \|^2 \\&= (n^\mathbf{T} v - n^\mathbf{T} v_0 )^2 \\&= v^\mathbf{T} (nn^\mathbf{T}) v - 2 n^\mathbf{T} v_0 n^\mathbf{T}v + (n^\mathbf{T} v_0)^2\end{aligned}$$<p>定义</p>$$\begin{aligned}{\bf A}_{3\times 3} &= n n^\mathbf{T}\\ d &= -n^\mathbf{T} v_0 \\\vec b_{3 \times 1} &= d n \\c &= d^2\end{aligned}$$<p>则</p>$$d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c$$<p>这个距离平方也可以写成齐次形式</p>$$d^2(v, F_i) = h^\mathbf{T} {\bf Q} h \\\text{where} \ {\bf Q}_{4\times4} = \begin{pmatrix} {\bf A}_{3 \times 3} & b_{3 \times 1} \\ b^\mathbf{T} _{1 \times 3}& c_{1 \times 1} \end{pmatrix} \ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}$$<p>所以，对于每一个平面 $ F_i $，都可以定义一个二次型 $ Q_{F_i}(v) &#x3D; h^\mathbf{T} \mathbf{Q} h $，其为任意一点 $ v$ 到该平面距离的平方。</p><p>对于顶点 $ v $，该顶点到相邻的所有表面的距离平方和可以表示为 $ \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i}(v) &#x3D; (\sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i})(v) $ 。</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>QEM 算法的框架如下：</p><ul><li><p>每个顶点 $ v_i $ 按上面的方法赋予一个 Q 矩阵，$ Q_{v_i} &#x3D; \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i} $</p></li><li><p>收缩 $(v_i, v_j)$ 边到 $ v’ $ 时，定义这次收缩的代价为 $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$；每次全局的选择最小代价的边进行收缩</p><ul><li>如何选择 $ v’ $？有 Optimal Placement 和 Subset Placement 两种形式：<ol><li><p>(<strong>Optimal Placement</strong>) $ {\bf A} $ 可逆时</p><p>令 $ \frac{\partial}{\partial v}(v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c) &#x3D; 0 $，解得 $ v_\text{optimal} &#x3D; -{\bf A}^{-1} b $ </p></li><li><p>(<strong>Subset Placement</strong>) $ {\bf A} $ 不可逆时，选择两个端点或中点；看哪个 edge loss 小</p></li></ol></li></ul></li><li><p>收缩后的顶点 $ v’ $ 更新</p><blockquote><p>这里对算法有两种理解，第一种是按初始计算的方法重新按邻面赋予 Q 矩阵（这样就是一个完全 local 的方法），第二种理解是合并两个顶点，则将对应的 Q 矩阵也进行合并。</p><p>文章中的做法是<strong>第二种理解</strong>，从文章提到 implicit track sets of planes 可以知道。不过在 Discussion 处也讨论了这种做法的问题：</p></blockquote></li></ul><blockquote><p><em>Second, the information accumulated in the quadrics is essentially implicit, which can at times be problematic. Suppose we join together two cubes and would like to remove the planes associated with the now defunct interior faces. Not only is it, in general, difficult to determine what faces are defunct, there is no clear way to reliably remove the appropriate planes from the quadrics. As a result, our algorithm does not do as good a job at simplification with aggregation as we would like.</em></p></blockquote><ul><li>$ Q_{v'} = Q_{v_1} + Q_{v_2} $</li></ul><p>值得注意的是， $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$ 会导致一些 double counting 的现象发生，即有些公共面构造的 Q 分量被重复求和了。但作者提到，这样的重复对效果的影响有限。</p><blockquote><p>这里引用了 Donald E. Knuth. The Art of Computer Programming, volume 1. Addison Wesley, Reading, MA, Third edition, 1997.</p><p>不是很懂高德纳老爷子和 inclusion-exclusion rule 对效果的改善的关系…</p></blockquote><h3 id="Preserving-Boundaries"><a href="#Preserving-Boundaries" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>对于不希望边界移动的情况，可以首先标记将边标记为<strong>正常边</strong>和<strong>边界边</strong>两种（这个边界边不一定需要是真的网格边界，只是比较不希望移动的边）。</p><p>对于标记为<strong>边界边</strong>的边 $(v_1, v_2)$，令和其相邻的所有面的 Q 矩阵中增加一项反映到垂直于该平面、且过该<strong>边界边</strong>的一个平面的距离平方的项。</p><p>设边界边 $(v_1, v_2)$，不妨设某个相邻的三角形 $ F_i $ 的三个顶点为 $v_1, v_2, v_3$，则与之相对的边界平面 $ F_{B_i} $ 可以计算如下</p>$$n_{F_i} = \operatorname{normalize}{ \left((v_2 - v_1) \times (v_3 - v_1) \right)} \\n_{F_{B_i}} = \operatorname{normalize}{\left( n_{F_i} \times (v_2 - v_1) \right)} \\\forall v \in F_{B_i},\ \vec {n_{F_{B_i}}} \cdot (\vec v - \vec {v_1}) = 0 \Rightarrow \vec {n_{F_{B_i}}} \cdot \vec v +(- \vec {n_{F_{B_i}}} \cdot \vec {v_1}) = 0$$<p>则到边界平面 $ F_{B_i} $ 的距离平方计算如下：</p>$$d^2(v, F_{B_i}) = h^\mathbf{T} \mathbf{Q} h \\\text{where} \ {\bf Q}_{4\times4} = \begin{pmatrix}{\bf A}_{3 \times 3} & b_{3 \times 1} \\b^\mathbf{T} _{1 \times 3}& c_{1 \times 1}\end{pmatrix} = \begin{pmatrix}n_{F_{B_i}}n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) {n_{F_{B_i}}} \\(- n_{F_{B_i}} \cdot {v_1}) n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) ^2\end{pmatrix}\ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}$$<p>把他加入到相邻面的 Q 矩阵中，最后就会进入各个边的 Q 矩阵。</p><h2 id="Appearance-Preserving-QEM"><a href="#Appearance-Preserving-QEM" class="headerlink" title="Appearance Preserving QEM"></a>Appearance Preserving QEM</h2><blockquote><p>出现于文章 <a href="https://www.cs.cmu.edu/~garland/Papers/quadric2.pdf">Simplifying Surfaces with Color and Texture using Quadric Error Metrics</a> 中</p></blockquote><p>对于<strong>连续</strong>的顶点属性来说，可以通过把他们加入向量中一起优化的方法来解决。这种方法本质上是原来 QEM 的推广，将原来的到平面的距离推广为了到平面上三点的位置和其它顶点属性共同确定的<strong>超平面</strong>的距离。</p><p>同时，本文中调整了<strong>可收缩顶点对</strong>的定义，将其限制在了原三角网格中的边的范围内，因为可靠性不够好。</p><blockquote><p>Our experience has shown that, while greedy edge contraction produces consistently good results on many kinds of models, greedy contraction of arbitrary pairs is not as robust and does not perform as consistently.</p></blockquote><h3 id="Formulation-1"><a href="#Formulation-1" class="headerlink" title="Formulation"></a>Formulation</h3><p>将上面的三角形 $ F_i $ 的各个顶点 $ v_i $ 从 $ \mathbb{R}^3 $ 推广到 $ \mathbb{R}^n $，我们知道 3 个 $ \mathbb{R}^n $ 中的点（非线性相关）仍然确定一个 $ \mathbb{R}^2 $ 平面，这个平面的两个<strong>标准正交</strong>基向量 $ e_1 $，$ e_2 $ 可以用 Schmidt 正交化的办法得到：</p>$$\begin{aligned}e_1 &= \operatorname{normalize}{(v_2-v_1)} \\e_2 &= \operatorname{normalize}{((v_3 - v_1) - (e_1 \cdot (v_3 - v_1)) e_1)}\end{aligned}$$<p>这样，对于 $ v \in \mathbb{R}^n $，有</p>$$\begin{aligned}d^2(v, F_i) &= \| v - v_1 \|^2 - ((v-v_1)\cdot e_1)^2 - ((v-v_1)\cdot e_2)^2 \\&= (v-v_1)^{\bf T}(v-v_1) - ((v-v_1)^{\bf T}e_1)(e_1^{\bf T}(v-v_1)) - ((v-v_1)^{\bf T}e_2)(e_2^{\bf T}(v-v_1)) \\&= (v^{\bf T} v - v_1^{\bf T}v-v^{\bf T} v_1 + v^{\bf T}_1 v_1) - \\& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - v^{\bf T}e_1 e_1^{\bf T} v_1 + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - v^{\bf T}e_2 e_2^{\bf T} v_1 + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v)^{\bf T} + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)^{\bf T}  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v) + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(v^{\bf T}_1 e_1 e_1^{\bf T} + v^{\bf T}_1 e_2 e_2^{\bf T}-v_1^{\bf T}) v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(e_1 e_1^{\bf T}v_1 +e_2 e_2^{\bf T} v_1 - v_1)^{\bf T} v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2((e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1)^{\bf T} v + (v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2)\end{aligned}$$<p>仿照前面，整理成 Q 矩阵的形式</p>$$d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c \\\text{where}\ \left\{\begin{aligned}{\bf A}_{n\times n} &= {\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T} \\{\bf b}_{n\times 1} &= (e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1 \\c_{1\times 1} &= v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2\end{aligned}\right.$$<h3 id="Preserving-Boundaries-1"><a href="#Preserving-Boundaries-1" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>将原始的 QEM 边界处理方法直接搬到 $ \mathbb{R}^n $ 会比较困难，因为 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面有很多个。</p><blockquote><p>平面在 $ \mathbb{R}^n $ 中即为一个 $ \mathbb{R}^2 $ 子空间，垂直于该平面的向量现在构成一个“法空间”（其为 $ \mathbb{R} ^n &#x2F; \mathbb{R} ^2 $ 的商空间），其维数为 $ n - 2 $，那 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面 $ \iff $  $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点和一个法空间中的点  $ \Rightarrow $ 这样的平面至少有 $ n - 2 $ 个</p></blockquote><p>所以，这里考虑直接锁边界。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./qem-mesh-simplification/image-20230420220930080.png" alt="image-20230420220930080"></p><p>0.5 ratio</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;QEM </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SPIR-V 初探 (一) - Fragment Shader</title>
    <link href="https://blog.libreliu.info/play-with-spirv/"/>
    <id>https://blog.libreliu.info/play-with-spirv/</id>
    <published>2023-03-28T16:00:00.000Z</published>
    <updated>2023-03-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要关注 SPIR-V 1.6。</p><p>前面分支 &#x2F; 循环 &#x2F; 函数等测试主要是在 Fragment 这种 OpEntrypoint 下调用的子函数内部进行测试的。</p><p>下面的实验基本使用 <a href="https://shader-playground.timjones.io/">Shader Playground</a> 的 glslang trunk (上面写使用的 2022-09-19 的版本)，其中：</p><ul><li>Shader stage 选择 <strong>frag</strong></li><li>Target 选择 Vulkan 1.3</li><li>Output format 选择 SPIR-V</li></ul><h3 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h3><ul><li><a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a></li><li><a href="https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2">https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2</a></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>通过例子来学习 SPIR-V 会比较快捷，也比较容易理解。</p><p>SPIR-V 本身是 SSA 形式的 IR，且指令 format 较为规整，易于解析 (虽然大家都是调库，也不会用手解析 SPIR-V 的)。</p><p>规范文档参考：</p><ul><li><a href="https://registry.khronos.org/SPIR-V/">Khronos SPIR-V Registry</a></li><li><a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html">SPIR-V Unified Specifications</a></li></ul><p>同时推荐用 <a href="https://shader-playground.timjones.io/">Shader Playground</a> 来方便直接看到 SPIR-V Disassembly。</p><p>据博主本人测试，OpenAI 的 GPT-4 有<strong>不错</strong>的 SPIR-V 到 GLSL 反汇编能力。</p></blockquote><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>从反汇编结果可以看到，SPIR-V Module 有比较整齐的形式，事实上这些形式是规定好的：<a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_logical_layout_of_a_module">Logical Layout of a Module - SPIR-V Specification</a>。</p><h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.6</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 6                                                  ; Bound; where all &lt;id&gt;s in this module are</span><br><span class="line">                                                            ; guaranteed to satisfy 0 &lt; id &lt; Bound</span><br><span class="line">; Schema: 0                                                 ; Instruction Schema; Reserved, not used for now</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450                ; Addressing model = Logical</span><br><span class="line">                                                            ; Logical 模式下面，指针只能从已有的对象中创建，指针的地址也都是假的</span><br><span class="line">                                                            ;   （也就是说，不能把指针的值拷贝到别的变量中去）</span><br><span class="line">                                                            ; 也有一些带有物理指针的 Addressing Model 和相应的 Memory Model</span><br><span class="line">                                                            ;   =&gt; 留待后文探索</span><br><span class="line">                                                            ; Memory Model = GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot;           ; Execution Model = Fragment</span><br><span class="line">                                                            ; Entrypoint = %main (用 OpFunction 定义的某个 Result ID)</span><br><span class="line">                                                            ; Name = &quot;main&quot; (Entrypoint 要有一个字符串名字)</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft        ; The coordinates decorated by FragCoord</span><br><span class="line">                                                            ; appear to originate in the upper left,</span><br><span class="line">                                                            ; and increase toward the right and downward.</span><br><span class="line">                                                            ; Only valid with the Fragment Execution Model.</span><br><span class="line">               OpSource ESSL 310                            ; 标记源语言; ESSL = OpenGL ES Shader Language</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><blockquote><p>这里会发现 %main 这个 result id 是在后面定义的，但是前面却引用到了。</p><p>对于 <code>SPV_OPERAND_TYPE_ID</code>, <code>SPV_OPERAND_TYPE_MEMORY_SEMANTICS_ID</code>, <code>SPV_OPERAND_TYPE_SCOPE_ID</code> 来说，正常都需要先定义（是某个指令的 result id）再引用，但是可以前向定义的指令除外。</p><p>可前向定义的指令可以参考 <a href="https://github.com/KhronosGroup/SPIRV-Tools/blob/1021ec302f568cd83fee9f4eaa763dadb66e40b0/source/val/validate_id.cpp#L49">source&#x2F;val&#x2F;validate_id.cpp:L122 @ SPIRV-Tools</a>，其中包括：</p><ul><li>全部的 <code>OpTypeXXX</code> 类指令</li><li>其它一大堆，主要是执行模式等 metadata、Decorate、分支、device side invoke 等<ul><li>可以参考 <code>spvOperandCanBeForwardDeclaredFunction (source/operand.cpp @ SPIRV-Tools)</code> 这个函数</li></ul></li></ul></blockquote><h3 id="简单的函数"><a href="#简单的函数" class="headerlink" title="简单的函数"></a>简单的函数</h3><p>函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Circle</span><span class="params">( vec2 uv, vec2 p, <span class="type">float</span> r, <span class="type">float</span> blur )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = length(uv - p);</span><br><span class="line">    <span class="type">float</span> c = smoothstep(r, r-blur, d);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">%1 = OpExtInstImport &quot;GLSL.std.450&quot;                        ; 引入外部指令集</span><br><span class="line">%float = OpTypeFloat 32</span><br><span class="line">%v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Function_v2float = OpTypePointer Function %v2float</span><br><span class="line">%_ptr_Function_float = OpTypePointer Function %float       ; 定义指针类型，指向的变量的 Storage Class 为 Function</span><br><span class="line">%10 = OpTypeFunction %float %_ptr_Function_v2float %_ptr_Function_v2float %_ptr_Function_float %_ptr_Function_float</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line">%Circle_vf2_vf2_f1_f1_ = OpFunction %float None %10        ; 返回值类型 %float，Function Control 类型无</span><br><span class="line">                                                           ; 函数类型 %10 - float (vec2, vec2, float, float)</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float  ; 拿到各个 parameter 的 result id</span><br><span class="line">          %p = OpFunctionParameter %_ptr_Function_v2float  </span><br><span class="line">          %r = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">       %blur = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">         %16 = OpLabel                                     ; 一个基本块的开始 (2.2.5. Control Flow)</span><br><span class="line">          %d = OpVariable %_ptr_Function_float Function    ; 定义 float 变量, Storage Class 为 Function </span><br><span class="line">          %c = OpVariable %_ptr_Function_float Function    ; =&gt; 变量可以被 OpLoad / OpStore</span><br><span class="line">         %39 = OpLoad %v2float %uv                         ; 结果类型 %v2float, 装载 %uv 变量的值</span><br><span class="line">         %40 = OpLoad %v2float %p</span><br><span class="line">         %41 = OpFSub %v2float %39 %40                     ; Operand2 - Operand1，结果类型 %v2float</span><br><span class="line">         %42 = OpExtInst %float %1 Length %41              ; Execute an instruction in an imported set of extended instructions</span><br><span class="line">                                                           ; Set (也就是这里的 %1) is the result of an OpExtInstImport instruction.</span><br><span class="line">                                                           ; 后面的 Set 中的 Instruction 是 “Length”，操作数是 %41</span><br><span class="line">               OpStore %d %42                              ; 存到 %d 变量的存储中</span><br><span class="line">         %44 = OpLoad %float %r</span><br><span class="line">         %45 = OpLoad %float %r</span><br><span class="line">         %46 = OpLoad %float %blur</span><br><span class="line">         %47 = OpFSub %float %45 %46                       ; %blur - %r</span><br><span class="line">         %48 = OpLoad %float %d</span><br><span class="line">         %49 = OpExtInst %float %1 SmoothStep %44 %47 %48  ; SmoothStep(%r, %blur - %r, %d)</span><br><span class="line">               OpStore %c %49</span><br><span class="line">         %50 = OpLoad %float %c</span><br><span class="line">               OpReturnValue %50                           ; 不返回值的话使用 OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><h3 id="函数的-in-x2F-out-参数"><a href="#函数的-in-x2F-out-参数" class="headerlink" title="函数的 in &#x2F; out 参数"></a>函数的 in &#x2F; out 参数</h3><p>函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inoutTest</span><span class="params">(in vec2 uv, out <span class="type">float</span> o1, in <span class="type">float</span> i2, out vec2 o2)</span> &#123;</span><br><span class="line">    o2 = uv;</span><br><span class="line">    o1 = i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">         %v1 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %t1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %t2 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %v2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">      %param = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">    %param_0 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %24 = OpLoad %v2float %v1</span><br><span class="line">               OpStore %param %24</span><br><span class="line">         %27 = OpLoad %float %t2</span><br><span class="line">               OpStore %param_1 %27</span><br><span class="line">         %29 = OpFunctionCall %void %inoutTest_vf2_f1_f1_vf2_ %param %param_0 %param_1 %param_2</span><br><span class="line">         %30 = OpLoad %float %param_0   ; 可以看到，就是实现了 %param_0 变量内值的变化</span><br><span class="line">               OpStore %t1 %30</span><br><span class="line">         %31 = OpLoad %v2float %param_2</span><br><span class="line">               OpStore %v2 %31</span><br><span class="line">               OpStore %fragColor %38</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br><span class="line">%inoutTest_vf2_f1_f1_vf2_ = OpFunction %void None %10</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line">         %o1 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %i2 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %o2 = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line"></span><br><span class="line">         %16 = OpLabel</span><br><span class="line">         %17 = OpLoad %v2float %uv</span><br><span class="line">               OpStore %o2 %17</span><br><span class="line">         %18 = OpLoad %float %i2</span><br><span class="line">               OpStore %o1 %18</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">testIf</span><span class="params">(<span class="type">float</span> range)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (range &lt; <span class="number">1.0</span>)</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line"> %testIf_f1_ = OpFunction %int None %22</span><br><span class="line">      %range = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %25 = OpLabel                                    ; 基本块开始</span><br><span class="line">        %c_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %c_0 %int_0</span><br><span class="line">         %68 = OpLoad %float %range                       </span><br><span class="line">         %71 = OpFOrdLessThan %bool %68 %float_1          ; check if %68 (loaded from %range) &lt; %float_1</span><br><span class="line">               OpSelectionMerge %73 None                  ; Declare a structured selection</span><br><span class="line">                                                          ; This instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.</span><br><span class="line">                                                          ; Selection Control = None; 这里可以给 Hint 提示此分支是否应该 remove</span><br><span class="line">                                                          ; 并且指定 Merge Block 为 %73，也就是分支结束的地方</span><br><span class="line">               OpBranchConditional %71 %72 %75            ; 如果 %71 为 true, 则跳到 %72 标号，否则跳到 %75 标号 - 标志基本块结束</span><br><span class="line">         %72 = OpLabel                                    ; </span><br><span class="line">               OpStore %c_0 %int_1</span><br><span class="line">               OpBranch %73                               ; Unconditional branch to %73</span><br><span class="line">         %75 = OpLabel</span><br><span class="line">               OpStore %c_0 %int_2</span><br><span class="line">               OpBranch %73</span><br><span class="line">         %73 = OpLabel</span><br><span class="line">         %77 = OpLoad %int %c_0</span><br><span class="line">               OpReturnValue %77</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><code>OpSelectionMerge</code></li><li><code>OpBranchConditional</code></li><li>两个基本块最后 <code>OpBranch</code> 到出口</li></ol><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>Merge Instruction: <code>OpSelectionMerge</code> 或者 <code>OpLoopMerge</code> 两者之一，用在</li><li>Header Block: 包含 Merge Instruction 的 Block<ul><li>Loop Header: Merge Instruction 是 <code>OpLoopMerge</code> 的 Header Block</li><li>Selection Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpBranchConditional</code> 是终止指令的 Header Block</li><li>Switch Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpSwitch</code> 是终止指令的 Header Block</li></ul></li><li>Merge Block: 在 Merge Instruction 作为 Merge Block 操作数的 Block</li><li>Break Block: 含有跳转到被 Loop Header 的 Merge Instruction 定义为 Merge Block 的 Block</li><li>Continue Block: 含有跳转到 <code>OpLoopMerge</code> 指令的 Continue Target 的 Block</li><li>Return Block: 包含 <code>OpReturn</code> 或者 <code>OpReturnValue</code> 的 Block</li></ul><blockquote><p>GPT-4: 在 SPIR-V 中，Merge Block 是一个特定类型的基本块（Basic Block），用于控制流程结构中收敛控制流的位置。当你在 SPIR-V 中使用分支结构（如 if-else 语句、循环等）时，Merge Block 表示在这些分支结构末端的汇合点。</p><p>SPIR-V 中的控制流结构使用特殊的操作码（如 OpSelectionMerge、OpLoopMerge）来定义。这些操作码告诉编译器如何解释控制流图（Control Flow Graph，CFG）。Merge Block 用于表示这些控制流结构的结束位置，它是控制流从不同路径重新合并到一条路径的地方。例如，一个 if-else 语句会有两个分支，这两个分支在 Merge Block 之后合并为单个执行路径。</p></blockquote><h4 id="while-循环-无-break"><a href="#while-循环-无-break" class="headerlink" title="while 循环 - 无 break"></a>while 循环 - 无 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None                 ; Declare a structured loop.</span><br><span class="line">                                                        ; This instruction must immediately precede</span><br><span class="line">                                                        ; either an OpBranch or OpBranchConditional </span><br><span class="line">                                                        ; instruction. </span><br><span class="line">                                                        ; That is, it must be the second-to-last </span><br><span class="line">                                                        ; instruction in its block.</span><br><span class="line">                                                        ; Merge Block = %87</span><br><span class="line">                                                        ; Continue target = %88</span><br><span class="line">               OpBranch %89</span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0     ; 有符号比较; if %90 (=count) &gt;= %int_0 (0)</span><br><span class="line">               OpBranchConditional %91 %86 %87          ; %91 == true ? jump to %86 : jump to %87 (FINISH)</span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93                         ; sum = sum + 1</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95                       ; count = count - 1</span><br><span class="line">               OpBranch %88</span><br><span class="line">         %88 = OpLabel</span><br><span class="line">               OpBranch %85                             ; 无条件回到 Loop 头</span><br><span class="line">         %87 = OpLabel</span><br><span class="line">         %96 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %96</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>相当于翻译成了如下格式的 SPIR-V：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%header_block = OpLabel</span><br><span class="line">                OpLoopMerge %merge_block %continue_block</span><br><span class="line">                OpBranch %loop_body</span><br><span class="line"></span><br><span class="line">   %loop_test = OpLabel</span><br><span class="line">                OpLoopMerge %loop_merge %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cond = ...          ; Some calculations</span><br><span class="line">                OpBranchConditional %loop_cond %loop_body %loop_merge</span><br><span class="line">   </span><br><span class="line">   %loop_body = OpLabel</span><br><span class="line">                ...          ; Some codes inside loop body</span><br><span class="line">                OpBranch %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cont = OpLabel</span><br><span class="line">                OpBranch %loop_test</span><br><span class="line"></span><br><span class="line">  %loop_merge = OpLabel</span><br><span class="line">                ...          ; The &quot;following&quot; basic block</span><br></pre></td></tr></table></figure><h4 id="while-循环-带-break"><a href="#while-循环-带-break" class="headerlink" title="while 循环 - 带 break"></a>while 循环 - 带 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None</span><br><span class="line">               OpBranch %89</span><br><span class="line"></span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0</span><br><span class="line">               OpBranchConditional %91 %86 %87</span><br><span class="line"></span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95</span><br><span class="line">         %96 = OpLoad %int %count</span><br><span class="line">         %97 = OpIEqual %bool %96 %int_2</span><br><span class="line">               OpSelectionMerge %99 None              ; If 的 Merge Block = %99</span><br><span class="line">               OpBranchConditional %97 %98 %99</span><br><span class="line"></span><br><span class="line">         %98 = OpLabel</span><br><span class="line">               OpBranch %87                           ; =&gt; break out of the loop =&gt; emit instruction</span><br><span class="line">                                                      ;    to branch to while&#x27;s merge block</span><br><span class="line"></span><br><span class="line">         %99 = OpLabel                                ; 正常走 =&gt; 到达 while 末尾 =&gt; emit 到 while</span><br><span class="line">               OpBranch %88                           ; 的 Continue Block</span><br><span class="line"></span><br><span class="line">         %88 = OpLabel                                ; Continue Block </span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %87 = OpLabel                                ; Merge Block</span><br><span class="line">        %101 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %101</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>break 作为一个基本块末尾，直接 emit 无条件 branch 来跳到 while 循环的 merge block。</li></ul><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>GLSL 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testFor</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">%testFor_i1_ = OpFunction %int None %27</span><br><span class="line">    %count_0 = OpFunctionParameter %_ptr_Function_int</span><br><span class="line"></span><br><span class="line">         %33 = OpLabel</span><br><span class="line">      %sum_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">          %i = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum_0 %int_0</span><br><span class="line">               OpStore %i %int_0</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %109 = OpLabel</span><br><span class="line">               OpLoopMerge %111 %112 None</span><br><span class="line">               OpBranch %113</span><br><span class="line"></span><br><span class="line">        %113 = OpLabel</span><br><span class="line">        %114 = OpLoad %int %i</span><br><span class="line">        %115 = OpLoad %int %count_0</span><br><span class="line">        %116 = OpSLessThan %bool %114 %115</span><br><span class="line">               OpBranchConditional %116 %110 %111</span><br><span class="line"></span><br><span class="line">        %110 = OpLabel</span><br><span class="line">        %117 = OpLoad %int %sum_0</span><br><span class="line">        %118 = OpIAdd %int %117 %int_1</span><br><span class="line">               OpStore %sum_0 %118</span><br><span class="line">               OpBranch %112</span><br><span class="line"></span><br><span class="line">        %112 = OpLabel                              ; Continuation Block</span><br><span class="line">        %119 = OpLoad %int %i                       ; for 循环的循环结束操作放到了这里</span><br><span class="line">        %120 = OpIAdd %int %119 %int_1</span><br><span class="line">               OpStore %i %120</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %111 = OpLabel                              ; Merge Block</span><br><span class="line">        %121 = OpLoad %int %sum_0</span><br><span class="line">               OpReturnValue %121</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>Continuation Block 处现在 emit 了循环后维护操作</li></ul><h3 id="Uniform、BuiltIn-等其它-Scope-的变量"><a href="#Uniform、BuiltIn-等其它-Scope-的变量" class="headerlink" title="Uniform、BuiltIn 等其它 Scope 的变量"></a>Uniform、BuiltIn 等其它 Scope 的变量</h3><blockquote><p><code>OpSource</code>, <code>OpName</code>, <code>OpMemberName</code> 属于调试信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Anonymous uniform block - Import member names to shader directly</span></span><br><span class="line">layout(binding = <span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 outColor;</span><br><span class="line">layout(location = <span class="number">0</span>) in vec4 vertColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will not work:</span></span><br><span class="line"><span class="comment">// layout(binding = 0) uniform vec3 lightPos;</span></span><br><span class="line"><span class="comment">//  &#x27;non-opaque uniforms outside a block&#x27; : not allowed when using GLSL for Vulkan </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mainImage</span><span class="params">(out vec4 c, in vec2 f, in vec3 lightPos)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, lightPos);&#125;</span><br></pre></td></tr></table></figure><h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input &#x2F; Output"></a>Input &#x2F; Output</h4><blockquote><p>所有可选 Decoration 可以参考 <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration</a></p></blockquote><p>对于 gl_FragCoord：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">                      OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">      %gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure><p>对于 Input Variable：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %vertColor &quot;vertColor&quot;</span><br><span class="line">                      OpDecorate %vertColor Location 0</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">                      %vertColor = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure><p>对于 Output Variable：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                       OpName %outColor &quot;outColor&quot;</span><br><span class="line">                       OpDecorate %outColor Location 0</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">           %outColor = OpVariable %_ptr_Output_v4float Output</span><br></pre></td></tr></table></figure><p>使用时直接 <code>OpLoad</code> 就可以。</p><h4 id="Uniform-Block-Anonymous"><a href="#Uniform-Block-Anonymous" class="headerlink" title="Uniform Block (Anonymous)"></a>Uniform Block (Anonymous)</h4><blockquote><p>匿名的 Uniform Block，其成员是被引入了 Global Scope 的。</p><p>可以作为 OpenGL 的 uniforms outside a block 的平替。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniBlock &quot;uniBlock&quot;</span><br><span class="line">               OpMemberName %uniBlock 0 &quot;lightPos&quot;</span><br><span class="line">               OpMemberName %uniBlock 1 &quot;someOtherFloat&quot;</span><br><span class="line">               OpName %_ &quot;&quot;</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0             ; Structure type = %uniBlock</span><br><span class="line">                                                                 ; Member = 0</span><br><span class="line">                                                                 ; Decoration = Offset</span><br><span class="line">                                                                 ; Byte Offset = 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block                        ; Apply only to a structure type to establish</span><br><span class="line">                                                                 ; it is a memory interface block</span><br><span class="line">               OpDecorate %_ DescriptorSet 0                     ; Apply only to a variable. </span><br><span class="line">                                                                 ; Descriptor Set is an unsigned 32-bit integer </span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc. </span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">               OpDecorate %_ Binding 0                           ; Apply only to a variable.</span><br><span class="line">                                                                 ; Binding Point is an unsigned 32-bit integer</span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc.</span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float                      ; 后面指定所有成员的类型，这里是 &#123;vec3, float&#125;</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock         ; Storage Class = Uniform</span><br><span class="line">          %_ = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_v3float = OpTypePointer Uniform %v3float</span><br><span class="line"></span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %_ %int_0     ; Create a pointer into a composite object.</span><br><span class="line">                                                                 ; Base = %_, Indexes = &#123;%int_0&#125;</span><br><span class="line">                                                                 ; Each index in Indexes</span><br><span class="line">                                                                 ; - must have a scalar integer type</span><br><span class="line">                                                                 ; - is treated as signed</span><br><span class="line">                                                                 ; - if indexing into a structure, must be an </span><br><span class="line">                                                                 ;   OpConstant whose value is in bounds for selecting a member</span><br><span class="line">                                                                 ; - if indexing into a vector, array, or matrix, </span><br><span class="line">                                                                 ;   with the result type being a logical pointer type,</span><br><span class="line">                                                                 ;   causes undefined behavior if not in bounds.</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure><h4 id="Uniform-Block-Named"><a href="#Uniform-Block-Named" class="headerlink" title="Uniform Block (Named)"></a>Uniform Block (Named)</h4><p>把上面的示例程序里面的 <code>uniform uniBlock</code> 类型的不具名 Uniform Block 加一个实例名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout(binding=<span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125; uniInst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..skip some lines..</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, uniInst.lightPos);&#125;</span><br></pre></td></tr></table></figure><p>下面是相关的 SPIR-V：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniInst &quot;uniInst&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block</span><br><span class="line">               OpDecorate %uniInst DescriptorSet 0</span><br><span class="line">               OpDecorate %uniInst Binding 0</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %uniInst %int_0</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure><p>可以看到，主要区别是 <code>%_</code> 变成了 <code>%uniInst</code>，其实就是 OpName 从 <code>&quot;&quot;</code> 变成了 <code>&quot;uniInst&quot;</code>，这样 SPIR-V 反汇编工具生成的反汇编能更好看一些而已。真正的 Result ID 等的逻辑关系都是没有变化的。</p><blockquote><p>当然，不知道反射库依赖不依赖 <code>OpName</code>，当然去掉了也不是没法反射就是了，只要 layout 一样，怼上去就得了。</p></blockquote><h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p>GLSL 源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (binding = <span class="number">1</span>) uniform sampler2D samplerColor;</span><br><span class="line">layout (binding = <span class="number">2</span>) uniform texture2D tex;</span><br><span class="line">layout (binding = <span class="number">3</span>) uniform sampler samp;</span><br><span class="line">layout (location = <span class="number">0</span>) in vec2 inUV;</span><br><span class="line">layout (location = <span class="number">1</span>) in <span class="type">float</span> inLodBias;</span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    vec4 color = texture(samplerColor, inUV, inLodBias);</span><br><span class="line">      vec4 color2 = texture(sampler2D(tex, samp), inUV, inLodBias);</span><br><span class="line">    outFragColor = color + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 40</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %inUV %inLodBias %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %color &quot;color&quot;</span><br><span class="line">               OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">               OpName %inUV &quot;inUV&quot;</span><br><span class="line">               OpName %inLodBias &quot;inLodBias&quot;</span><br><span class="line">               OpName %color2 &quot;color2&quot;</span><br><span class="line">               OpName %tex &quot;tex&quot;</span><br><span class="line">               OpName %samp &quot;samp&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">               OpDecorate %samplerColor Binding 1</span><br><span class="line">               OpDecorate %inUV Location 0</span><br><span class="line">               OpDecorate %inLodBias Location 1</span><br><span class="line">               OpDecorate %tex DescriptorSet 0</span><br><span class="line">               OpDecorate %tex Binding 2</span><br><span class="line">               OpDecorate %samp DescriptorSet 0</span><br><span class="line">               OpDecorate %samp Binding 3</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Function_v4float = OpTypePointer Function %v4float</span><br><span class="line">         %10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">         %11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line">    %v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Input_v2float = OpTypePointer Input %v2float</span><br><span class="line">       %inUV = OpVariable %_ptr_Input_v2float Input</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line">  %inLodBias = OpVariable %_ptr_Input_float Input</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">        %tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line">         %27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">       %samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %color = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">     %color2 = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">         %14 = OpLoad %11 %samplerColor</span><br><span class="line">         %18 = OpLoad %v2float %inUV</span><br><span class="line">         %21 = OpLoad %float %inLodBias</span><br><span class="line">         %22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br><span class="line">               OpStore %color %22</span><br><span class="line">         %26 = OpLoad %10 %tex</span><br><span class="line">         %30 = OpLoad %27 %samp</span><br><span class="line">         %31 = OpSampledImage %11 %26 %30</span><br><span class="line">         %32 = OpLoad %v2float %inUV</span><br><span class="line">         %33 = OpLoad %float %inLodBias</span><br><span class="line">         %34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br><span class="line">               OpStore %color2 %34</span><br><span class="line">         %37 = OpLoad %v4float %color</span><br><span class="line">         %38 = OpLoad %v4float %color2</span><br><span class="line">         %39 = OpFAdd %v4float %37 %38</span><br><span class="line">               OpStore %outFragColor %39</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>总结如下：</p><ul><li>Sampler (<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpName %samp &quot;samp&quot;</span><br><span class="line">OpDecorate %samp DescriptorSet 0</span><br><span class="line">OpDecorate %samp Binding 3</span><br><span class="line"></span><br><span class="line">%27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">%samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br></pre></td></tr></table></figure></li><li>Sampled Image (<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OpName %tex &quot;tex&quot;</span><br><span class="line">OpDecorate %tex DescriptorSet 0</span><br><span class="line">OpDecorate %tex Binding 2</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">%tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%26 = OpLoad %10 %tex</span><br><span class="line">%30 = OpLoad %27 %samp</span><br><span class="line">%31 = OpSampledImage %11 %26 %30</span><br><span class="line">%32 = OpLoad %v2float %inUV</span><br><span class="line">%33 = OpLoad %float %inLodBias</span><br><span class="line">%34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br></pre></td></tr></table></figure></li><li>Combined Image Sampler (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">OpDecorate %samplerColor Binding 1</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%14 = OpLoad %11 %samplerColor</span><br><span class="line">%18 = OpLoad %v2float %inUV</span><br><span class="line">%21 = OpLoad %float %inLodBias</span><br><span class="line">%22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意关于 OpImage 和 OpSampledImage 的特殊规则：</p><ul><li>All <code>OpSampledImage</code> instructions must be in the same block in which their Result <code>&lt;id&gt;</code> are consumed. Result <code>&lt;id&gt;</code> from <code>OpSampledImage</code> instructions must not appear as operands to <code>OpPhi</code> instructions or <code>OpSelect</code> instructions, or any instructions other than the image lookup and query instructions specified to take an operand whose type is OpTypeSampledImage.</li><li>在 <code>spvtools::opt::InstrumentPass::MovePreludeCode @ source/opt/instrument_pass.cpp (SPIRV-Tools)</code> 中对该要求进行了处理。</li></ul></blockquote><h3 id="Storage-Buffer"><a href="#Storage-Buffer" class="headerlink" title="Storage Buffer"></a>Storage Buffer</h3><blockquote><p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap14.html#descriptorsets-storagebuffer">14.1.7. Storage Buffer</a></p></blockquote><blockquote><p>我的一个疑惑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[]; </span><br><span class="line">    <span class="type">float</span> someEndingVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以，参考 https://github.com/KhronosGroup/SPIRV-Guide/blob/master/chapters/access_chains.md</span></span><br><span class="line"><span class="comment">// 的例子</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （应该）可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure></blockquote><p>GLSL 源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectData</span> &#123;</span></span><br><span class="line">    vec4 model;</span><br><span class="line">    <span class="type">float</span> moreData;</span><br><span class="line">    vec4 padThis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WritableData</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> testData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br><span class="line"></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">1</span>) buffer myWritableBufferType &#123;</span><br><span class="line">    WritableData datas[];</span><br><span class="line">&#125; writableBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="type">int</span>(gl_FragCoord.x * <span class="number">1000</span>);</span><br><span class="line">    outFragColor = objectBuffer.objects[index].model;</span><br><span class="line">    writableBuffer.datas[index].testData = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 42</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %gl_FragCoord %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %index &quot;index&quot;</span><br><span class="line">               OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpName %WritableData &quot;WritableData&quot;</span><br><span class="line">               OpMemberName %WritableData 0 &quot;testData&quot;</span><br><span class="line">               OpName %myWritableBufferType &quot;myWritableBufferType&quot;</span><br><span class="line">               OpMemberName %myWritableBufferType 0 &quot;datas&quot;</span><br><span class="line">               OpName %writableBuffer &quot;writableBuffer&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line">               OpMemberDecorate %WritableData 0 Offset 0</span><br><span class="line">               OpDecorate %_runtimearr_WritableData ArrayStride 4</span><br><span class="line">               OpMemberDecorate %myWritableBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %myWritableBufferType BufferBlock</span><br><span class="line">               OpDecorate %writableBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %writableBuffer Binding 1</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">%gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line"> %float_1000 = OpConstant %float 1000</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_v4float = OpTypePointer Uniform %v4float</span><br><span class="line">%WritableData = OpTypeStruct %float</span><br><span class="line">%_runtimearr_WritableData = OpTypeRuntimeArray %WritableData</span><br><span class="line">%myWritableBufferType = OpTypeStruct %_runtimearr_WritableData</span><br><span class="line">%_ptr_Uniform_myWritableBufferType = OpTypePointer Uniform %myWritableBufferType</span><br><span class="line">%writableBuffer = OpVariable %_ptr_Uniform_myWritableBufferType Uniform</span><br><span class="line">  %float_123 = OpConstant %float 123</span><br><span class="line">%_ptr_Uniform_float = OpTypePointer Uniform %float</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %index = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %16 = OpAccessChain %_ptr_Input_float %gl_FragCoord %uint_0</span><br><span class="line">         %17 = OpLoad %float %16</span><br><span class="line">         %19 = OpFMul %float %17 %float_1000</span><br><span class="line">         %20 = OpConvertFToS %int %19</span><br><span class="line">               OpStore %index %20</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br><span class="line">         %32 = OpLoad %v4float %31</span><br><span class="line">               OpStore %outFragColor %32</span><br><span class="line">         %38 = OpLoad %int %index</span><br><span class="line">         %41 = OpAccessChain %_ptr_Uniform_float %writableBuffer %int_0 %38 %int_0</span><br><span class="line">               OpStore %41 %float_123</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line"></span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable    ; 如果可变则无此 decorate</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData           ; Declare a new run-time array type.</span><br><span class="line">                                                                   ; Its length is not known at compile time.</span><br><span class="line">                                                                   ; See OpArrayLength for getting the Length</span><br><span class="line">                                                                   ; of an array of this type.</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line"></span><br><span class="line">; 访问</span><br><span class="line">; 使用 OpAccessChain 指令，该指令是 base, indices... 格式</span><br><span class="line">; 此例子： objectBuffer[0 th][index th][0 th] 来获得 model 的指针，该指针之后可以 load / store</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br></pre></td></tr></table></figure><h3 id="Atomic-操作"><a href="#Atomic-操作" class="headerlink" title="Atomic 操作"></a>Atomic 操作</h3><blockquote><p><a href="https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc">https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc</a></p></blockquote><p>GLSL 源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) buffer statsBufferType &#123;</span><br><span class="line">    <span class="type">int</span> totalInvocations;</span><br><span class="line">&#125; statsBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// returns the value before the add</span></span><br><span class="line">    <span class="type">int</span> globalIdx = atomicAdd(statsBuffer.totalInvocations, <span class="number">1</span>);</span><br><span class="line">    outFragColor = vec4(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPIR-V 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 26</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %globalIdx &quot;globalIdx&quot;</span><br><span class="line">               OpName %statsBufferType &quot;statsBufferType&quot;</span><br><span class="line">               OpMemberName %statsBufferType 0 &quot;totalInvocations&quot;</span><br><span class="line">               OpName %statsBuffer &quot;statsBuffer&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpMemberDecorate %statsBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %statsBufferType BufferBlock</span><br><span class="line">               OpDecorate %statsBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %statsBuffer Binding 0</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">%statsBufferType = OpTypeStruct %int</span><br><span class="line">%_ptr_Uniform_statsBufferType = OpTypePointer Uniform %statsBufferType</span><br><span class="line">%statsBuffer = OpVariable %_ptr_Uniform_statsBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_int = OpTypePointer Uniform %int</span><br><span class="line">      %int_1 = OpConstant %int 1</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_1 = OpConstant %uint 1</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line">         %25 = OpConstantComposite %v4float %float_1 %float_1 %float_1 %float_1</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">  %globalIdx = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %14 = OpAccessChain %_ptr_Uniform_int %statsBuffer %int_0</span><br><span class="line">         %19 = OpAtomicIAdd %int %14 %uint_1 %uint_0 %int_1             ; Pointer = %14</span><br><span class="line">                                                                        ; Memory Scope = %uint_1 = 1</span><br><span class="line">                                                                        ; =&gt; Scope is the current device</span><br><span class="line">                                                                        ; Semantics = %uint_0 = 0</span><br><span class="line">                                                                        ; =&gt; None (relaxed)</span><br><span class="line">                                                                        ; Value = %uint_1 = 1</span><br><span class="line">               OpStore %globalIdx %19</span><br><span class="line">               OpStore %outFragColor %25</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure><blockquote><p>Memory Scope: <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-</a></p></blockquote><h2 id="Coming-soon"><a href="#Coming-soon" class="headerlink" title="Coming soon"></a>Coming soon</h2><ul><li>Matrix 类型</li><li>导数 <code>dFdx</code> &#x2F; <code>dFdy</code> &amp; <code>discard</code><ul><li><a href="https://github.com/gpuweb/gpuweb/issues/361">https://github.com/gpuweb/gpuweb/issues/361</a></li><li><a href="http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/">http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/</a></li></ul></li><li>Group Ops</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文主要关注 SPIR-V 1.6。&lt;/p&gt;
&lt;p&gt;前面分支 &amp;#x2F; 循环 &amp;#x2F; 函数等测试主要是在 Fragment 这种 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Automatic Mesh and Shader Level of Detail</title>
    <link href="https://blog.libreliu.info/paper-reading/auto-shader-mesh-lod/"/>
    <id>https://blog.libreliu.info/paper-reading/auto-shader-mesh-lod/</id>
    <published>2023-02-20T16:00:00.000Z</published>
    <updated>2023-02-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。</p><p>文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮后得到结果。</p><p>针对交替优化耗时较长的问题，文章中还提出了“分别优化”的算法。该算法会首先分别对网格和 Shader 独立的进行简化，得到一系列质量单调下降的 Shader 和网格变体列，然后再针对每个距离组选择合适的网格和 Shader 对。为了让 LOD 组间的变化尽可能平滑，文章还设置了最平滑的 LOD 切换路线的查找，以及 LOD 组数量的优化操作。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul><li>网格简化和 LOD 生成</li><li>Shader 简化和 LOD 生成</li><li>基于外观的联合优化</li></ul><h2 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>对于 Shader 和网格简化问题，定义三元组 $ (M_i, S_i, d_i) $，其中</p><ul><li>$ M_i $ 为原网格 $ M $ 的第 $ i $ 个简化变体</li><li>$ S_i $ 为原 Shader $ S $ 的第 $ i $ 个简化变体 </li><li>$ d_i $ 为距相机的距离</li></ul><p>定义 $ \epsilon_a(i) $ 为简化 $ (M_i, S_i, d_i) $ 变体的绝对图像误差，其定义为</p>$$\epsilon_a (i) = \int_H \| f(M_i, S_i, d_i) - \bar{f}(M, S, d_i) \| dH$$<p>这里的作为误差模型的积分域 $ H &#x3D; V \times U \times X \times Y $ ，其中</p><ul><li>$ V $ 为离散的若干个 view direction</li><li>$ U $ 若干 Shader uniform 参数，如光照方向</li><li>$ X \times Y $ 为图像空间的两个维度</li></ul><p>这里的范数是 pixelwise RGB $ L^2 $ 范数。</p><p>另外，定义 $ \epsilon_t(i) $ 为两个简化组之间的视觉差异：</p>$$\epsilon_t (i) = \int_H \| f(M_i, S_i, d_{i+1}) - f(M_{i+1}, S_{i+1}, d_{i+1}) \| dH$$<p>这样，LOD 优化问题就可以看作下面的数学问题：</p>$$\mathop{\arg \min}_{M_i, S_i, d_i} t = Cost ( f(M_i, S_i, d_i) ) \\\mathrm{s.t.}\quad \epsilon_a(i) < e_a (d_i) \cdot s_{d_i}$$<p>其中 Cost 为在该网格上应用此 Shader 进行着色的时间开销，$ e_a (d_i) $ 为在 $ d_i $ 距离的 absolute per-pixel error bound， $ s_{d_i} $ 为距离 $ d_i $ 时网格 $ M_i $ 的投影大小，</p><p>其中 $ e_a(d) $ 采用前面工作提出的一个启发函数：</p>$$e_a(d) = (\frac{d-d_{near}}{d_{far} - d_{near}})^Q \cdot e_{max}$$<p>其中</p><ul><li>$ d_{near} $ 和 $ d_{far} $ 是设置的视景体参数</li><li>$ e_{max} $ 是 maximum absolute per pixel error bound<ul><li>也就是关于 $ e_t(i) $ 的积分项关于积分域里面各个部分的最大值</li></ul></li><li>$ Q \in [0, 1] $ 反映了对误差的容忍程度</li></ul><h3 id="交替优化"><a href="#交替优化" class="headerlink" title="交替优化"></a>交替优化</h3><h4 id="Shader-简化"><a href="#Shader-简化" class="headerlink" title="Shader 简化"></a>Shader 简化</h4><blockquote><p>这里的 Shader 简化工作主要参考了前面的文章：</p><ul><li>[3] Y. He, T. Foley, N. Tatarchuk, and K. Fatahalian, “A system for rapid, automatic shader level-of-detail,” ACM Trans. on Graph. (TOG), vol. 34, no. 6, p. 187, 2015.</li><li>[8] R. Wang, X. Yang, Y. Yuan, W. Chen, K. Bala, and H. Bao, “Automatic shader simplification using surface signal approximation,” ACM Trans. on Graph. (TOG), vol. 33, no. 6, p. 226, 2014.</li><li>[18] F. Pellacini, “User-configurable automatic shader simplification,”<br>ACM Trans. Graph., vol. 24, no. 3, pp. 445–452, 2005</li><li>[21] P. Sitthi-Amorn, N. Modly, W. Weimer, and J. Lawrence, “Genetic programming for shader simplification,” in ACM Transactions on Graphics (TOG), vol. 30, no. 6. ACM, 2011, p. 152.</li></ul></blockquote><ol><li>将 Vertex Shader 和 Fragment Shader 转换为抽象语法树 (AST) 和程序依赖图 (PDG)</li><li>应用不同的化简规则来生成简化 Shader<ul><li>Operation Removal: 将 $ op(a, b) $ 省略为 $ a $ 或 $ b $</li><li>Code Transformation: 将 per-pixel 的 pixel shader 操作移动到 per-vertex 或 per-tessellated-vertex 的操作来减少计算量</li><li>Moving to parameter: 将参数用其均值替换（$ n \to average(n) $），并且替换到 “parameter stage” 中进行计算（详见 [3]），并将均值作为结果送入 GPU Shader 中</li></ul></li></ol><blockquote><p>本文并没有对 Shader 本身的优化方面做出额外的创新。这些方法主要来源于 [3] 这篇文章。</p></blockquote><h4 id="Mesh-简化"><a href="#Mesh-简化" class="headerlink" title="Mesh 简化"></a>Mesh 简化</h4><blockquote><p>Mesh 简化工作：</p><ul><li>[4] M. Garland and P. S. Heckbert, “Surface simplification using<br>quadric error metrics,” in Proceedings of the 24th annual conference on<br>Computer graphics and interactive techniques. ACM Press&#x2F;AddisonWesley Publishing Co., 1997, pp. 209–216.</li><li>[7] P. Lindstrom and G. Turk, “Image-driven simplification,” ACM<br>Transactions on Graphics (ToG), vol. 19, no. 3, pp. 204–241, 2000</li></ul></blockquote><p>主要用了 [7] 中的 Image-driven simplification 的方法。这个方法是基于顶点对折叠的，每次折叠选择使 image error 升高最低的一对顶点。</p><blockquote><p><strong>QEM</strong></p><p><a href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a><br><a href="http://mgarland.org/research/quadrics.html">http://mgarland.org/research/quadrics.html</a><br><a href="https://blog.csdn.net/lafengxiaoyu/article/details/72812681">https://blog.csdn.net/lafengxiaoyu/article/details/72812681</a></p><p>QEM 是 SIGGRAPH’97 提出的经典算法，截至现在已经有大约 5000 次引用。</p></blockquote><h4 id="交替优化-1"><a href="#交替优化-1" class="headerlink" title="交替优化"></a>交替优化</h4><p>给定网格 $ M $ 和 Shader $ S $，</p><ol><li>搞 Shader 优化 (然后生成一堆变体 $ S_i $)</li><li>对于每个在 Pareto frontier 上的 $ S_i $，利用该 Shader 进行相应的 Mesh 简化，使得新的 $ M_j $ 在满足质量要求 (也就是 error &lt;&#x3D; absolute error bound) 的情况下为最简<blockquote><p>Pareto frontier 上的 $ S_i $ 满足</p><ul><li>不存在另一个 Shader，他的性能一样，质量更好</li><li>不存在另一个 Shader，他的质量一样，性能更好</li></ul></blockquote></li><li>将这些 $ (M_j, S_i) $ 按渲染性能排序，取前 20% 作为种子进入下一轮迭代</li></ol><h3 id="分别优化"><a href="#分别优化" class="headerlink" title="分别优化"></a>分别优化</h3><h4 id="生成网格变体"><a href="#生成网格变体" class="headerlink" title="生成网格变体"></a>生成网格变体</h4><p>因为没有任何关于简化后 Shader 的信息，所以作者此处采用原 Shader 进行着色后 supersampled &#x2F; filtered 的图片作为 loss 环节进行网格简化。</p><p>因为某些边简化之后对视觉表现没有什么影响，所以这里只选取 K (实现中 K &#x3D; 500) 个有较大 error 变化的简化网格作为候选变体。</p><h4 id="生成-Shader-变体"><a href="#生成-Shader-变体" class="headerlink" title="生成 Shader 变体"></a>生成 Shader 变体</h4><p>理论上，对于不同的场景配置 (简化网格 &amp; 距离配置)，最优的 Shader 变体是不同的。</p><p>但是，因为</p><ol><li>First, as has been proven in prior work [3], the performance and error of shader variants can be predicted instead of being actually evaluated. In this way, we do not need to actually render every shader variant under all scene configurations.<blockquote><p>在 [3] 中，性能的预测是通过一种简单的启发函数，即 <code>scalar fp ops + 100 * texture ops</code> 来预测的（不同 Shader stage 有不同权重，parameter 数量有额外惩罚）</p><p>error 的评价是通过 error cache 和偶尔的重新 evaluate 来实现的</p></blockquote></li><li>Second, we noted that for one shader variant with one simplified mesh, the shading errors at distances could be approximated by filtering the rendered image at the closest distance.<blockquote><p>通过在最近距离生成着色结果，再进行 filter 来模拟在远处的结果</p></blockquote></li><li>Finally, we further observed that although these Pareto frontiers may change with scene configurations, the shader variants on Pareto frontiers are similar at similar distances and with similarly simplified meshes. <blockquote><p>Pareto 面上的 shader 变体基本上是比较稳定的，随着场景配置的变化不是很多</p></blockquote></li></ol><p>所以，作者最后只选择<strong>有代表性的距离</strong>和<strong>有代表性的简化网格</strong>来计算最优 Shader 变体，而不是穷举所有场景配置。</p><p>作者选择均匀的从 N 组距离组里面选择 4 组，然后每个距离组里面选择 10 个前面的简化网格（即 Pareto 面左右的十个），就得到了 40 个组合。然后用 genetic programming 的优化方法来得到每个 (距离, 网格) 组上的最优简化 Shader。这些优化好的 Shader 变体都放到一个数组里面。</p><p>然后，作者近似的认为整个问题是一个凸区域上找可行域边界的问题，所以只需要 1D search，而不需要遍历 2D 区域。</p><p>然后，再用 find smooth path 的技术来获得比较连续的 LOD transition。</p><blockquote><p>具体来说，就是每个边的权重是在边界处的图像损失，这样图像损失小的转换会更容易被选中。</p></blockquote><p>最后，合并区别不大的 LOD 组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。&lt;/p&gt;
&lt;p&gt;文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | 平衡精确度和预测范围的黑盒 GPU 性能建模</title>
    <link href="https://blog.libreliu.info/paper-reading/cross-machine-black-box-GPU-perf-modeling/"/>
    <id>https://blog.libreliu.info/paper-reading/cross-machine-black-box-GPU-perf-modeling/</id>
    <published>2023-02-15T16:00:00.000Z</published>
    <updated>2023-02-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章提出了一种跨机器，黑盒，基于微测试 (microbenchmark) 的方法来解析的对不同实现变体的 OpenCL kernel 的执行时间进行预测和最优 kernel 选择。</p><p>简单来说，本文大的思路是，收集一些 kernel 中出现的<strong>特征</strong>和对应特征在运行时会出现的<strong>频率</strong>，利用 microbenchmark 在目标平台上测量这些<strong>特征</strong>每次出现会花费的运行时间，再用一个（多重）线性模型来拟合最后的运行时间。</p><p>由于文章比较长，此处将文章的大概结构列举如下：</p><ul><li>Section 1: 简介</li><li>Section 2: 解释性的例子</li><li>Section 3: 本文贡献概况</li><li>Section 4: 本文采用的假设和局限性</li><li>Section 5: <strong>收集 kernel 统计信息</strong></li><li>Section 6: <strong>建模 kernel 执行时间</strong></li><li>Section 7: <strong>校准模型参数</strong></li><li>Section 8: 结果展示</li><li>Section 9: 作者调研到的、其它相关的性能建模方法</li></ul><h2 id="本文的假设和局限性"><a href="#本文的假设和局限性" class="headerlink" title="本文的假设和局限性"></a>本文的假设和局限性</h2><p>本文提到的一些 assumptions：</p><ul><li>(usefulness) 可以帮助用户理解给定机器的性能特性，并且给优化器提供变体性能数据预测参考，同时降低需要在目标系统实际测量的数据数量</li><li>(accuracy) 根据检索到的相关文献显示，在本文提及的 GPU kernel 性能预测问题上，没有方法可以一致的获得小于个位数的预测误差，所以本文也设定这样的目标</li><li>(cost-explanatory): 和其它基于排名的方法不同 (Chen et al. (2018))，虽然本文优化的目标是在各种变体中进行选择，但是本文中模型的主要输出为运行时间，且采用比较可解释的线性模型进行建模</li></ul><p>本文提到的一些局限：</p><ul><li>硬件资源的利用率：<ul><li>硬件资源的利用率会影响最终的性能。比如，峰值浮点性能受 SIMD lane 使用率影响，片上状态存储器 (VGPR, Scratchpad Memory) 会影响调度槽位的利用率，进而影响延迟隐藏的能力</li><li>不过，采用本文的方法，基本的性能损失系数是比较容易解释和估计的。比如，实际的内存带宽利用率，以及峰值 FLOP&#x2F;s</li><li>即使无法达到硬件资源的全部利用，对于硬件资源利用率随参数变化相对稳定的场合，本文的模型仍然可以适用。不过对于变化的情况，让本文提出的模型适用的唯一可行方法，就是将模型的粒度调低到类似 SIMD lane 的水平，这样利用率的变化就不再相关了。ECM 系列模型就是这样考虑这个问题的。<blockquote><p>?</p></blockquote></li><li>为了简化的处理这个问题，本文采用 workgroup size 恒定为 256 的参数设定。</li></ul></li><li>程序建模上的简化：<ul><li>本文的模型中，主要检测的是基于某种特殊类别的操作 (e.g. 浮点操作，特殊类型的访存) 和检测到该特征出现的次数，其中次数被建模为 non-data-dependent 的一个特征。<ul><li>Polyhedrally-given loop domain?</li></ul></li><li>所有分支指令都假设两个分支均会执行，即假设 GPU 采用 masking 的方式进行执行。<blockquote><p>文章认为这和 GPU 的行为是匹配的，不过显然不完全是。较新的 GPU 是同时支持 branching 和 masking 的。masking 存在的意义是对于短分支来说，可以不打断流水线。</p></blockquote></li></ul></li><li>内存访问开销评估：<ul><li>内存访问的开销受到程序访问的局部性，以及对于 banked memory 来说的 bank 竞争问题的影响。</li><li>本文将内存访问切分成了两种：<ul><li>对于各个程序都常见的，比较简单的访存模式，用 Section 6.1.1 的办法按 interlane stride, utilization radio 和 data width 进行分类<blockquote><p>quasi-affine? </p></blockquote></li><li>对于更复杂的访存模式，在 Section 7.1.1 中提供一种单独抽出来在循环里面按该模式进行访存，并且进行测量的机制</li></ul></li></ul></li><li>平台无关：<ul><li>本文提出的系统作用于 OpenCL 上，但是相似的系统在 CUDA 上也可以比较轻松的实现。</li></ul></li></ul><h2 id="收集-kernel-统计信息"><a href="#收集-kernel-统计信息" class="headerlink" title="收集 kernel 统计信息"></a>收集 kernel 统计信息</h2><h3 id="计算每个特征的预期出现次数"><a href="#计算每个特征的预期出现次数" class="headerlink" title="计算每个特征的预期出现次数"></a>计算每个特征的预期出现次数</h3><p>前面提到，本文假设程序中出现的所有循环，其循环次数和本次运行所使用的数据无关，即 non-data-dependent。</p><p>这种情况下，如果要求解循环体中每个语句的运行次数，简单的做法是将所有循环展开，不过这样效率会比较低。事实上，此处可以把问题看作：在 $ d $ 维的整数空间 $ \mathrm{Z}^d $ 中，可行区域是由一些约束条件构成的超平面截出来的一个子区域，某个语句的循环次数就是在该子区域中整数格点的数目。</p><p>文章汇总提到，用 <code>barvinok</code> 和 <code>isl</code> 库一起，可以解决前面这个数循环体内语句执行次数的问题，其中 <code>barvinok</code> 是基于 Barvinok 算法的，这是一个比较高效的、计算有理凸多胞形中的格点数目的算法。</p><p>当然，还要分析好一条语句内真正进行计算或数据搬运的相应特征和次数。</p><blockquote><p>为什么要抽象成有理凸多胞形？ 这是因为真正循环的次数和 Kernel 本身的一些参数，以及 Kernel 的 Launch parameters 也有关系，这里希望带着这些参数做符号计算，让模型更有用一些（比如说，优化这些参数会变得容易）</p></blockquote><h3 id="计数粒度-count-granularity"><a href="#计数粒度-count-granularity" class="headerlink" title="计数粒度 (count granularity)"></a>计数粒度 (count granularity)</h3><p>计数粒度设计的思路是，计数出来的次数尽可能贴近真实 GPU 硬件中所执行操作的次数。</p><p>比如，我们知道，在 OpenCL 的调度模型中，每个 <code>sub-group</code> 会尽可能匹配 GPU 调度的最小单位，并且视硬件能力 <code>sub-group</code> 内部会支持一些 reduce 和 scatter 等原语，并且算数指令一般也是以 <code>sub-group</code> 为粒度进行调度和实现的。这样，算术指令就应该以 <code>sub-group</code> 为粒度计数。</p><p>当然，具体 <code>sub-group</code> 的数目是依赖具体的 Kernel launch parameters 的，不过这里对前面参数的依赖是多项式形式的 (比如 <code>work-group count / 32</code>），所以可以作为一个含参的量，让前面的循环次数计算也成为一个含参的值。</p><!-- TOOD: check this paragraph --><p>粒度有如下三种：</p><ul><li>per work-item<ul><li>同步障操作 (barrier synchronization)</li></ul></li><li>per sub-group （subgroup size 需要用户提供）<ul><li>片上操作：算数指令和 local memory 访问</li><li>uniform 访问：global memory 访问，但是 <code>lid(0)</code> stride 0，即多个线程访问同一块内存区域</li></ul></li><li>per work-group （没有给出例子）</li></ul><blockquote><p>这里的讨论很不详细，需要和下面一起看</p></blockquote><h2 id="建模-kernel-执行时间"><a href="#建模-kernel-执行时间" class="headerlink" title="建模 kernel 执行时间"></a>建模 kernel 执行时间</h2>$$T_\text{wall}({\bf n}) = \text{feat}^\text{out}({\bf n}) \approx g(\text{feat}^\text{in}_0({\bf n}), ..., \text{feat}^\text{in}_j({\bf n}), p_0, ..., p_k)$$<p>其中：</p><ul><li>$ {\bf n} $ 是整个计算过程中为常数的、仅与各种变体相关的整数向量</li><li>$ \text{feat}^\text{in}_j({\bf n}) $ 是某种单元特征的出现次数（比如单精度 FP32 乘法数）</li><li>$ p_i $ 是硬件相关的校正参数</li><li>$ g $ 是用户提供的可微函数</li></ul><h3 id="kernel-特征"><a href="#kernel-特征" class="headerlink" title="kernel 特征"></a>kernel 特征</h3><h4 id="数据移动特征"><a href="#数据移动特征" class="headerlink" title="数据移动特征"></a>数据移动特征</h4><p>对于大多数计算 kernel 来说，数据搬运所占的开销是大头。</p><p>内存访问模式：</p><ul><li>内存类别：global &#x2F; local</li><li>访问类型：load &#x2F; store</li><li>the local and global strides along each thread axis in the array index<ul><li>也就是说，每次 <code>gid(0)</code>, <code>gid(1)</code>, <code>lid(0)</code>, <code>lid(1)</code> 自增一的时候，对 array 数组访问的偏移要分别增加多少</li></ul></li><li>the ratio of the number of element accesses to the number of elements accessed (access-to-footprint ratio, or AFR)<ul><li><code>AFR = 1</code>: every element in the footprint is accessed one time</li><li><code>AFR &gt; 1</code>: some elements are accessed more than once<ul><li>这样 Cache 就可能会对速度有加成了</li></ul></li></ul></li></ul><blockquote><p>文章中提到，解析形式的模型需要建模很多机器细节，比如 workgroup 调度，内存系统架构等，来达到和黑盒模型相似的精度。一个例子是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k_out = <span class="number">0</span>; k_out &lt;= ((<span class="number">-16</span> + n) / <span class="number">16</span>); ++k_out)</span><br><span class="line">  ...</span><br><span class="line">  a_fetch[...] = a[n*(<span class="number">16</span>*gid(<span class="number">1</span>) + lid(<span class="number">1</span>)) + <span class="number">16</span>*k_out + lid(<span class="number">0</span>)];</span><br><span class="line">  b_fetch[...] = b[n*(<span class="number">16</span>*k_out + lid(<span class="number">1</span>)) + <span class="number">16</span>*gid(<span class="number">0</span>) + lid(<span class="number">0</span>)];</span><br></pre></td></tr></table></figure><p>这个例子里面的内存访问模式如下：</p><table><thead><tr><th>Array</th><th>Ratio</th><th>Local strides</th><th>Global strides</th><th>Loop stride</th></tr></thead><tbody><tr><td>a</td><td>n&#x2F;16</td><td>{0:1, 1:n}</td><td>{0:0, 1:n*16}</td><td>16</td></tr><tr><td>b</td><td>n&#x2F;16</td><td>{0:1, 1:n}</td><td>{0:16, 1:0}</td><td>16*n</td></tr></tbody></table><p>这两个例子的性能差距在 5 倍左右。</p></blockquote><p>With this approach, a universal model for all kernels on all hardware based on kernel-level features like ours  could need a prohibitively large number of global memory access features and corresponding measurement kernels. This motivates our decision to allow proxies of “in-situ” memory accesses to be included as features, which in turn motivates our ‘work removal’ code transformation, discussed in Section 7.1.1. This transformation facilitates generation of microbenchmarks exercising memory accesses which match the access patterns found in specific computations by stripping away unrelated portions of the computation in an automated fashion.</p><p>Specifying Data Motion Features in the Model: 弄个 aLD, bLD, f_mem_access_tag</p><p>也可以手动指定，不用运行时测量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Model(</span><br><span class="line">  <span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>显式语法格式如下：<code>&quot;f_mem_access_tag:&lt;mem access tag&gt;_&lt;mem type&gt;_&lt;data type&gt;_&lt;direction&gt;_lstrides:&#123;&lt;local stride constraints&gt;&#125;_gstrides:&#123;&lt;global stride constraints&gt;&#125;_afr:&lt;AFR constraint&gt;&quot;</code></p><h4 id="算术操作特征"><a href="#算术操作特征" class="headerlink" title="算术操作特征"></a>算术操作特征</h4><p>特征：</p><ul><li>操作类型：加法、乘法、指数</li><li>数据类型：float32, float64</li></ul><p>本文中的工作不考虑整数算术特征，因为在模型考虑的 kernel 变体中，整数算术只用在了数组下标计算中。</p><h4 id="同步特征"><a href="#同步特征" class="headerlink" title="同步特征"></a>同步特征</h4><p>特征：</p><ul><li>局部同步障 (local barriers)</li><li>kernel 启动</li></ul><p>这里 Local barriers 是 per work-item 的，然后根据实际程序同步的需要，可能需要进行乘以同时进行同步的 work item 数量。</p><p>简单来说就是，认为参与同步的 thread 越多越耗时。</p><blockquote><p>Recall that the statistics gathering module counts the number of synchronizations encountered by a single work-item, so depending on how a user intends to model execution, they may need to multiply a synchronization feature like local barriers by, e.g., the number of work-groups, a feature discussed in the next section.</p><p>A user might incorporate synchronization features into this model as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><h3 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h3><ul><li>Thread groups feature<ul><li>给定 workgroup count，进行不同 workgroup count 间启动时间补偿</li></ul></li><li>OpenCL wall time feature<ul><li>给定 platform 和 device 下，执行 60 遍获得平均 walltime，作为输出特征</li><li>“We measure kernel execution time excluding any host-device transfer of data.”</li></ul></li></ul><p>一个完整的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_group * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="校准模型参数"><a href="#校准模型参数" class="headerlink" title="校准模型参数"></a>校准模型参数</h2><p>Work Removal Transformation: a code transformation that can extract a set of desired operations from a given computation, while maintaining overall loop structure and sufficient data flow to avoid elimination of further parts of the computation by optimizing compilers</p><p>Work Removal 变换会把 on-chip 工作从 kernel 中去掉，达成两方面目的：</p><ol><li>测试 on-chip work 和 global memory access 各自占用时间，决定是否要进行 latency hiding</li><li>测试某种特殊访存模型的时间占用</li></ol><h3 id="Measurement-kernel-设计"><a href="#Measurement-kernel-设计" class="headerlink" title="Measurement kernel 设计"></a>Measurement kernel 设计</h3><ul><li>Global memory access<ul><li>AFR &#x3D; 1: Fully specified by local strides, global strides, data size<ul><li>That is, patterns that do not produce a write race and not nested inside sequential loops</li><li>Performs global load from each of <em>a variable number of input arrays</em> using the specified access pattern</li><li>Each work-item then stores the sum of the input array values it fetched in a single result array</li><li>Params: data type, global memory array size, work-group dimensions, number of input arrays, thread index strides</li></ul></li><li>AFR &gt; 1:<ul><li>Use <strong>Work Removal Tranformation</strong> to generate dedicated measurement kernel.</li></ul></li></ul></li><li>Arithmetic operations<ul><li>First, have each work-item initialize 32 private variables of the specified data type</li><li>Then, perform a loop in which each iteration updates each variable using the target arithmetic operation on values from other variables<ul><li>This is to create structural dependency</li></ul></li><li>We <strong>unroll the loop by a factor of 64</strong> and <strong>arrange the variable assignment order</strong> to achieve high throughput using the approach found in the Scalable HeterOgeneous Computing (SHOC) OpenCL MaxFlops.cpp benchmark (Danalis et al. 2010).<ul><li>the 32 variable updates are ordered so that <strong>no assignment depends on the most recent four statements</strong><ul><li>32 is used because it permits maximum SIMD lane utilization &amp; prevent from spilling too many registers</li></ul></li><li>we <strong>sum</strong> the 32 variable values and <strong>store the result in a global array</strong> according to a <strong>user-specified memory access pattern</strong><ul><li>(NOTE: The actual cost can be deduced by change the runcount of arithmetic ops)</li><li>include the global store to avoid being optimized away</li></ul></li></ul></li></ul></li><li>Local memory access<ul><li>Tags: data type, global memory array size, iteration count, and workgroup dimensions<ul><li>Data type determines the local data stride</li></ul></li></ul><ol><li>each workitem <strong>initializes one element of a local array</strong> to the data type specified</li><li>Then we have it perform a loop, at each iteration moving a different element from one location in the array to another. <ul><li>We avoid write-races and simultaneous reads from a single memory location, and use an lid(0) stride of 1, avoiding bank conflicts.</li></ul></li><li>After the loop completes, <strong>each work-item writes one value from the shared array to global memory</strong></li></ol></li><li>Other features<ul><li>executes a variable number of local barriers, to measure operation overlapping behaviour (<strong>Section 7.4</strong>)</li><li>Empty kernel launch, to measure kernel launching overhead</li></ul></li></ul><p>文章提出，<em>Using a sufficiently high-fidelity model, we expect that users will be able to differentiate between latency-based costs of a single kernel launch and throughput-related costs that would be incurred in pipelined launches.</em></p><blockquote><p>怎么做？</p></blockquote><h3 id="计算模型参数"><a href="#计算模型参数" class="headerlink" title="计算模型参数"></a>计算模型参数</h3><p>采用最小二乘法来进行拟合，得到 feature 向量中给定 feature 的出现次数和总的运行时间的关系。</p><h3 id="Operation-Overlap-建模"><a href="#Operation-Overlap-建模" class="headerlink" title="Operation Overlap 建模"></a>Operation Overlap 建模</h3><p>Global memory 和 On-chip 的延迟之间是有可能互相隐藏的。</p><p>本文的建模基于简单的想法，即 $ \max (c_{onchip}, c_{gmem}) $，两类操作的时间求 $ \max $ 操作。</p><p>不过 $ \max $ 不是很可导，所以采用一个可微的近似函数来做，详情可以看论文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章提出了一种跨机器，黑盒，基于微测试 (microbenchmark) 的方法来解析的对不同实现变体的 OpenCL kernel 的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Learning from Shader Program Traces</title>
    <link href="https://blog.libreliu.info/paper-reading/learning-from-program-traces/"/>
    <id>https://blog.libreliu.info/paper-reading/learning-from-program-traces/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-01-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Program trace<ul><li>In software engineering, a trace refers to the record of all states that a program visits during its execution, including all instructions and data.</li><li>本文提到的 Shader program trace，只包括中间结果 (<strong>data</strong>)，而不包括程序序列 (<strong>instruction</strong>)。</li></ul></li></ul><p>Since the fragment shader program operates independently per pixel, we can consider the full program trace as a vector of values computed at each pixel – a generalization from simple RGB.</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>输入是用（嵌入到 Python 的） DSL 写的 fragment procedural shader program，翻译成 Tensorflow 程序<ul><li>可以同时输出渲染好的图片和生成的 program trace</li><li>分支展开、循环 unroll</li><li>These policies permit us to express the trace of any shader as a fixed-length vector of the computed scalar values, regardless of the pixel location</li></ul></li></ul><h3 id="输入特征化简"><a href="#输入特征化简" class="headerlink" title="输入特征化简"></a>输入特征化简</h3><ul><li>编译器优化<ul><li>忽略常量值、计算图上重复的节点，因为其在不同 pixel 位置的运行结果应该高度统一</li></ul></li><li>不生成内建函数的 trace</li><li>检测并筛除迭代改进模式的循环中的中间 trace 结果<ul><li>比如，raymarching 找 closest intersection 的迭代</li></ul></li><li>均匀的特征下采样<ul><li>The most straightforward strategy is to subsample the vector by some factor n, retaining only every nth trace feature as ordered in a depth first traversal of the compute graph</li></ul></li><li>其它采样方案 (都不太好用)<ul><li>clustering</li><li>loop subsampling</li><li>first or last</li><li>mean and variance</li></ul></li></ul><p>We <strong>first apply compiler optimizations</strong>, then <strong>subsample the features with a subsampling rate that makes the trace length be most similar to a fixed target length</strong>.</p><p>For all experiments, we target a length of 200, except where specifically noted such as in the simulation example. </p><p>After compiling and executing the shader, we have <strong>for every pixel: a vector of dimension N</strong>: the number of recorded intermediate values in the trace</p><h3 id="特征白化"><a href="#特征白化" class="headerlink" title="特征白化"></a>特征白化</h3><p>主要是为了解决 shader trace 里面的异常值，防止干扰训练和推理。用的是 Scaling + clamping。</p><ul><li>Check if the distribution merits clamping<ul><li>If N &lt;&#x3D; 10, no need to clamp</li><li>Else, do clamp<ul><li>Discard NaN, Inf, -Inf</li><li>let $P_0$ &#x3D; Lowest p’th percentile, $P_1$ &#x3D; highest p’th percentile, superparam $ \gamma $</li><li>Clamp to $ [P_0 − \gamma(P_1− P_0), P_1 + \gamma(P_1 − P_0)] $</li></ul></li><li>Do rescale<ul><li>for each intermediate feature, rescale the clamped values to the fixed range $ [-1,1] $</li><li>Record the bias and scale used (in rescaling)</li></ul></li></ul></li></ul><p>The scale and bias is recorded and used in both training and testing, but the values will be clamped to range<br>[-2, 2] to allow data extrapolation.</p><blockquote><p>感觉有点乱…</p></blockquote><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>1x1 Conv + Feature Reduction (N &#x3D; 200 -&gt; K &#x3D; 48) </li><li>1x1 Conv * 3</li><li>Dilated Convolution (1, 2, 4, 8, 1)</li><li>1x1 Conv * 3 </li><li>1x1 Conv + Feature Reduction (K &#x3D; 48 -&gt; 3, that is, RGB color output)</li></ul><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>$ L_b = L_c + \alpha L_p $</p><ul><li>$ L_c $ 是 RGB 图像上的标准 $ L_2 $ loss</li><li>$ L_p $ 是 <a href="https://arxiv.org/abs/1801.03924">The Unreasonable Effectiveness of Deep Features as a Perceptual Metric</a> 这篇文章中给出的损失函数度量 LPIPS<ul><li>大概就是，做了一个图像相似数据集，弄了很多 distortions 和 CNN 常见任务输出的图片，做 2AFC 和 JND，随后学习这个 metric</li><li><a href="https://zhuanlan.zhihu.com/p/162070277">深度特征度量图像相似度的有效性——LPIPS</a> 这篇知乎文章比较不错</li></ul></li></ul><p>下面还有个 Appendix D，里面有实验的 GAN 的 loss</p><h4 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h4><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>和一个 Baseline 方法 RGBx 对比，这个 Baseline 用的手挑特征 normal, depth, diffuse, specular color (<em>where applicable</em>) 来作为输入进行学习。</p><h3 id="Denoising-fragment-shaders"><a href="#Denoising-fragment-shaders" class="headerlink" title="Denoising fragment shaders"></a>Denoising fragment shaders</h3><p>目标是用 1spp 图像来学习 1000spp 的 reference image。</p><h3 id="Reconstructing-simplified-shaders"><a href="#Reconstructing-simplified-shaders" class="headerlink" title="Reconstructing simplified shaders"></a>Reconstructing simplified shaders</h3><p>这个任务是，从简化后的 Shader 的运行结果中，重建原来 Shader 的运行结果。</p><p>简化 Shader 采用的是 Loop perforation 和 Genetic Programming Simplification。</p><p>用两个 Conditional GAN，分别称为 Spatial GAN 和 Temporal GAN，一个用来从 1spp 的图 $ c_x $ 生成 Ground Truth (原来的 Shader 运行结果) $ c_y $，另一个用来从前面三帧的 1spp 输出 + 前面两帧的 Spatial GAN 的生成器的输出来生成下一帧，也就是用序列 $ \tilde {c_x} $ 生成序列 $ \tilde {c_y} $。</p><blockquote><p>GAN related:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/301309418">四天搞懂生成对抗网络（一）——通俗理解经典GAN</a></li><li><a href="https://zhuanlan.zhihu.com/p/302720602">四天搞懂生成对抗网络（二）——风格迁移的“精神始祖”Conditional GAN</a></li></ul></blockquote><h3 id="Postprocessing-filters"><a href="#Postprocessing-filters" class="headerlink" title="Postprocessing filters"></a>Postprocessing filters</h3><p>学习一些后处理效果的 Shader，如 edge-aware sharpening filter 和 defocus blur 效果。</p><h3 id="Learning-to-approximate-simulation"><a href="#Learning-to-approximate-simulation" class="headerlink" title="Learning to approximate simulation"></a>Learning to approximate simulation</h3><p>学习一些进行模拟的 Shader 将来的运行结果。</p><h2 id="Trace-有效性分析"><a href="#Trace-有效性分析" class="headerlink" title="Trace 有效性分析"></a>Trace 有效性分析</h2><p>这里主要做了两件事：</p><ol><li>哪些 Input feature 比较重要？<ul><li>这里作者采用求 Loss 关于 input trace feature 的一阶导数来评价重要性</li></ul></li><li>挑一个 Subset 来做训练？<ul><li>给定 m 个 feature 的训练 budget，如果要评价任意的 subset，即从 N 个里面抽 m 个来做训练的话，开销太大<ul><li>Oracle: 按 1 中所述重要性评分的前 m 个 input trace feature</li><li>Opponent: 按 1 中所述重要性评分的后 m 个 input trace feature</li><li>Uniform: 随便挑 m 个</li></ul></li><li>发现 Oracle &gt; Opponent &gt; Uniform</li></ul></li><li>多个 Shader 一起学习<ul><li>多个 Shader 一起学习降噪任务，感觉就像训练一个真·denoiser</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Program trace&lt;ul&gt;
&lt;li&gt;In software engineering, a trace refers to</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个示例 Vulkan 程序的全流程记录</title>
    <link href="https://blog.libreliu.info/example-vulkan-app-flow/"/>
    <id>https://blog.libreliu.info/example-vulkan-app-flow/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2022-12-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>一些有用的链接：</p><ul><li><a href="https://www.khronos.org/blog/understanding-vulkan-synchronization">Khronos Blog - Understanding Vulkan Synchronization</a></li><li><a href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/">Yet another blog explaining Vulkan synchronization - Maister’s Graphics Adventures</a></li></ul></blockquote><p>本文主要分析 <a href="https://github.com/glfw/glfw">glfw</a> 库的 <a href="https://github.com/glfw/glfw/blob/57cbded0760a50b9039ee0cb3f3c14f60145567c/tests/triangle-vulkan.c">tests&#x2F;triangle-vulkan.c</a> 文件。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><blockquote><p>Update 2023-02-13: 补上了漏掉的创建逻辑设备的一步 vkCreateDevice</p></blockquote><ul><li>demo_init<ul><li>demo_init_connection<ul><li>glfwSerErrorCallback</li><li>gladLoadVulkanUserPtr: 设定 glad 使用 glfwGetInstanceProcAddress 来装载所有的 Vulkan 函数指针地址</li></ul></li><li>demo_init_vk<ul><li>启用验证层:<ul><li>vkEnumerateInstanceLayerProperties</li><li>demo_check_layers: 检查需要的验证层集合是否存在</li></ul></li><li>glfwGetRequiredInstanceExtensions: 获得需要的平台 Surface 扩展</li><li>准备启用的 Instance 扩展列表<ul><li>VK_EXT_debug_report</li><li>VK_KHR_portability_enumeration</li></ul></li><li>vkCreateInstance</li><li>vkEnumeratePhysicalDevices</li><li>检查设备是否支持 VK_KHR_swapchain<ul><li>vkEnumerateDeviceExtensionProperties</li></ul></li><li>vkCreateDebugReportCallbackEXT</li><li>vkGetPhysicalDeviceProperties</li><li>vkGetPhysicalDeviceQueueFamilyProperties</li><li>vkGetPhysicalDeviceFeatures</li></ul></li></ul></li><li>demo_create_window<ul><li>glfwWindowHint</li><li>glfwCreateWindow</li><li>glfwSetWindowUserPointer</li><li>glfwSetWindowRefreshCallback</li><li>glfwSetFramebufferSizeCallback</li><li>glfwSetKeyCallback</li></ul></li><li>demo_init_vk_swapchain<ul><li>glfwCreateWindowSurface<ul><li>内部调用 vkCreateWin32SurfaceKHR</li></ul></li><li>查找支持 Present 和 Graphics 的 Queue，需要是同一个 Queue<ul><li>vkGetPhysicalDeviceSurfaceSupportKHR</li><li><code>queueFlags &amp; VK_QUEUE_GRAPHICS_BIT</code></li></ul></li><li>demo_init_device<ul><li>vkCreateDevice: 创建 logical device<ul><li>VkDeviceCreateInfo<ul><li><code>.pQueueCreateInfos</code><ul><li><code>.queueFamilyIndex</code></li><li><code>.queueCount</code></li><li><code>.pQueuePriorities</code></li></ul></li><li><code>.ppEnabledLayerNames</code></li><li><code>.ppEnabledExtensionNames</code>: 要启用的设备扩展<blockquote><p>似乎把 Instance 扩展的名字扔进去也行？</p></blockquote></li></ul></li></ul></li></ul></li><li>vkGetDeviceQueue</li><li>选择一个最优的 Surface format<ul><li>vkGetPhysicalDeviceSurfaceFormatsKHR</li></ul></li><li>vkGetPhysicalDeviceMemoryProperties</li></ul></li><li>demo_prepare<ul><li>创建 Command Pool<ul><li>vkCreateCommandPool</li></ul></li><li>分配一个 Command Buffer<ul><li>vkAllocateCommandBuffers<ul><li>VkCommandBufferAllocateInfo:<ul><li><code>.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY</code></li><li><code>.commandBufferCount = 1</code></li></ul></li></ul></li></ul></li><li>demo_prepare_buffers<ul><li>检查 Surface Capabilities 和 Present Modes<ul><li>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</li><li>vkGetPhysicalDeviceSurfacePresentModesKHR</li></ul></li><li>创建交换链<ul><li>计算 Swapchain Image Extent</li><li><code>.preTransform</code> 使用 <code>VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code>，如果没有则使用当前 Surface Transform</li><li><code>.minImageCount</code> 使用 Surface Capabilities 的 minImageCount</li><li><code>.presentMode</code> 选择 <code>VK_PRESENT_MODE_FIFO_KHR</code></li><li>vkCreateSwapchainKHR</li><li>如果有老的交换链： vkDestroySwapchainKHR</li><li>vkGetSwapchainImagesKHR 拿到 VkImage 格式的交换链图像</li><li>为每个交换链图像调用 vkCreateImageView 创建 Color Attachment View<blockquote><p>Componet Swizzle: TODO check spec</p></blockquote></li></ul></li></ul></li><li>demo_prepare_depth<ul><li>vkCreateImage 创建 depth image<ul><li><code>.arrayLayers</code> 可以指定 texture array 的 dimension</li></ul></li><li>vkGetImageMemoryRequirements 获得 image 的内存要求</li><li>选择内存大小和内存类型<ul><li>memory_type_from_properties : todo check this</li></ul></li><li>vkAllocateMemory 分配 image 所需内存，返回 VkDeviceMemory</li><li>vkBindImageMemory 将分配的 VkDeviceMemory 绑定到 VkImage</li><li>demo_set_image_layout<ul><li>如果 <code>demo-&gt;setup_cmd</code> 为空，则<ul><li>调用 vkAllocateCommandBuffers 从 <code>demo-&gt;cmd_pool</code> 中分配 <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> 的 Buffer</li><li>vkBeginCommandBuffer</li></ul></li><li>准备 Image Memory Barrier<ul><li>VkImageMemoryBarrier<ul><li><code>.srcAccessMask = 0</code><ul><li>不需要给 src stage 的任何读&#x2F;写操作 made coherent</li></ul></li><li><code>.dstAccessMask</code>:<ul><li>对于 <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>，设置为 <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code></li></ul></li><li><code>.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED</code>，也就是垃圾数据</li><li><code>.newLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li></ul></li></ul></li><li>录制 Pipeline Barrier<ul><li>vkCmdPipelineBarrier<ul><li><code>srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是 wait for nothing</li><li><code>dstStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是任何下面的指令在开始前都需要等待 Barrier 执行完</li><li>同时传入前面的 Image Mmeory Barrier</li></ul></li></ul></li></ul></li><li>vkCreateImageView 创建深度缓冲对应图像的 ImageView</li></ul></li><li>demo_prepare_textures<ul><li>vkGetPhysicalDeviceFormatProperties 获得 <code>VK_FORMAT_B8G8R8A8_UNORM</code> 的 VkFormatProperties</li><li>对于每张 texture<blockquote><p>用 <code>texture_object</code> 来管理每个 texture</p><ul><li>VkSampler sampler</li><li>VkImage iamge;</li><li>VkImageLayout imageLayout;</li><li>VkDeviceMemory mem;</li><li>VkImageView view;</li><li>int32_t tex_width, tex_height;</li></ul></blockquote><ul><li>如果 sampler 支持（对此种 format 的）线性分块 <code>(props.linearTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul><li>demo_prepare_texture_image with required_props &#x3D; <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code><ul><li>vkCreateImage</li><li>vkGetImageMemoryRequirements</li><li>memory_type_from_properties<ul><li>对设备支持的每种内存类型，枚举其是否符合前面 <code>required_props</code> 的要求</li></ul></li><li>vkAllocateMemory</li><li>vkBindImageMemory</li><li>如果 memory type 有性质 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code><ul><li>vkGetImageSubresourceLayout</li><li>vkMapMemory: 映射到地址空间</li><li>填充之</li><li>vkUnmapMemory</li></ul></li><li>设置 image layout (前面分析过)<ul><li><code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> -&gt; <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code></li><li>demo_set_image_layout</li></ul></li></ul></li></ul></li><li>如果 sampler 不支持对此种 format 的线性分块，但支持 optimal 分块 <code>(props.optimalTilingFeatures &amp;  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul><li>分别准备 host coherent 和 host visible 的 staging texture 和 GPU device local 的 texture<ul><li>demo_prepare_texture_image * 2<ul><li>这里 device local 的显然没能力初始化</li></ul></li><li>注意 memory props</li></ul></li><li>改 layout 以便使用 transfer 命令<ul><li>staging texture: VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</li><li>device local texture: VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</li></ul></li><li>vkCmdCopyImage</li><li>将 device local texture 的 layout 改回来<ul><li>demo_set_image_layout</li></ul></li><li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul><li>vkEndCommandBuffer</li><li>vkQueueSubmit<ul><li>no wait &#x2F; signal semaphores</li></ul></li><li>vkQueueWaitIdle</li><li>vkFreeCommandBuffers</li><li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li></ul></li><li>demo_destroy_texture_image 销毁 staging texture</li></ul></li><li>创建对应的 sampler 和 Image View<ul><li>vkCreateSampler</li><li>vkCreateImageView</li></ul></li></ul></li></ul></li><li>demo_prepare_vertices<blockquote><p>这里直接用了 Host visible &amp; Host coherent 的 memory 作为 vertex buffer<br>而不是 Device local 的，然后单开 staging buffer 做拷贝.</p><p>应该是偷懒了.jpg</p></blockquote><ul><li>vkCreateBuffer<ul><li>with <code>.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code></li></ul></li><li>vkGetBufferMemoryRequirements</li><li>memory_type_from_properties</li><li>vkAllocateMemory</li><li>vkMapMemory</li><li>vkUnmapMemory</li><li>vkBindBufferMemory</li><li>配置一些结构体<ul><li>VkPipelineVertexInputStateCreateInfo<ul><li>VkVertexInputBindingDescription</li><li>VkVertexInputAttributeDescription</li></ul></li></ul></li></ul></li><li>demo_prepare_descriptor_layout<ul><li>vkCreateDescriptorSetLayout<ul><li>VkDescriptorSetLayoutCreateInfo</li><li><code>.pBindings = &amp;layout_binding</code><ul><li>layout_binding: 设置每个 binding 的位置都放什么 - 可以为数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const VkDescriptorSetLayoutBinding layout_binding = &#123;</span><br><span class="line">  .binding = 0,</span><br><span class="line">  .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,</span><br><span class="line">  .descriptorCount = DEMO_TEXTURE_COUNT,</span><br><span class="line">  .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">  .pImmutableSamplers = NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>See also: <a href="https://vkguide.dev/docs/chapter-4/descriptors/">https://vkguide.dev/docs/chapter-4/descriptors/</a></li></ul></li></ul></li><li>vkCreatePipelineLayout<ul><li>VkPipelineLayoutCreateInfo: <code>demo-&gt;pipeline_layout</code><ul><li>指定了到 Descriptor Set Layouts 的数量和数组指针</li></ul></li></ul></li></ul></li><li>demo_prepare_render_pass<ul><li>vkCreateRenderPass<ul><li>VkRenderPassCreateInfo<ul><li><code>.pAttachments</code>: VkAttachmentDescription<ul><li><code>[0]</code>: Color Attachment<ul><li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code> 图像的 sample 数</li><li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code> color &amp; depth 内容在 subpass 开始时如何处理</li><li><code>.storeOp = VK_ATTACHMENT_STORE_OP_STORE</code> color &amp; depth 内容在 subpass 结束后如何处理</li><li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code> stencil 内容在 subpass 开始时如何处理</li><li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code> stencil 内容在 subpass 结束时如何处理</li><li><code>.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 开始前 image subresource 的 layout</li><li><code>.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 结束后 image subresource 将会被自动转换到的 layout</li></ul></li><li><code>[1]</code>: Depth Stencil Attachment<ul><li><code>.format = demo-&gt;depth.format</code></li><li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code></li><li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code></li><li><code>.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li><li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code></li><li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li><li><code>.initialLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li><li><code>.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li></ul></li></ul></li><li><code>.pSubpasses</code>: VkSubpassDescription<blockquote><p>A single render pass can consist of multiple subpasses. Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes">Render passes - Vulkan Tutorial</a></p></blockquote><ul><li><code>.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code> 该 subpass 支持的 pipeline 类型</li><li><code>.pInputAttachments = NULL</code></li><li><code>.pColorAttachments = &amp;color_reference</code><ul><li><code>VkAttachmentReference &#123;.attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[0]</code></li></ul></li><li><code>.pDepthStencilAttachment = &amp;depth_reference</code><ul><li><code>VkAttachmentReference &#123;.attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[1]</code></li></ul></li></ul></li><li><code>.pDependencies</code>: VkSubpassDependency 有多个 subpass 时指定 subpass 间的读写依赖关系<blockquote><p>和 vkCmdPipelineBarrier + VkMemoryBarrier 差不多，区别只是同步作用域限于指定的 subpass 间，而非所有在前在后的操作 (<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#VkSubpassDependency">Vulkan Spec</a>)</p></blockquote></li></ul></li></ul></li></ul></li><li>demo_prepare_pipeline<ul><li>vkCreatePipelineCache: (<em>optional</em> for pipeline creation)<blockquote><p>主要用来供实现缓存编译好的 Pipeline; 可以使用 allocator 限制其缓存数据的大小; 可以创建时导入之前 (应用程序) 的 Cache 等</p></blockquote></li><li>vkCreateGraphicsPipelines<ul><li>VkGraphicsPipelineCreateInfo<ul><li><code>.layout = demo-&gt;pipeline_layout</code></li><li><code>.pVertexInputState</code>: VkPipelineVertexInputStateCreateInfo<ul><li>已经在 <code>demo_prepare_vertices</code> 中准备好</li></ul></li><li><code>.pInputAssemblyState</code>: VkPipelineInputAssemblyStateCreateInfo<ul><li><code>.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code></li></ul></li><li><code>.pRasterizationState</code>: VkPipelineRasterizationStateCreateInfo<ul><li><code>.polygonMode = VK_POLYGON_MODE_FILL</code></li><li><code>.cullMode = VK_CULL_MODE_BACK_BIT</code></li><li><code>.frontFace = VK_FRONT_FACE_CLOCKWISE</code><ul><li>front-facing triangle orientation to be used for culling</li></ul></li><li><code>.depthClampEnable = VK_FALSE</code><ul><li>不启用深度截断</li></ul></li><li><code>.rasterizerDiscardEnable = VK_FALSE</code><ul><li>是否在光栅化阶段前立即丢弃片元</li></ul></li><li><code>.depthBiasEnable = VK_FALSE</code></li><li><code>.lineWidth = 1.0f</code><ul><li>光栅化线段宽度</li></ul></li></ul></li><li><code>.pColorBlendState</code>: VkPipelineColorBlendStateCreateInfo<ul><li><code>.pAttachments</code>: VkPipelineColorBlendAttachmentState，对每个 color attachment 定义 blend state<ul><li><code>[0]</code><ul><li><code>.colorWriteMask = 0xf</code><ul><li>写入 RGBA 全部四个通道 (<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap29.html#framebuffer-color-write-mask">Vulkan Spec</a>)</li></ul></li><li><code>.blendEnable = VK_FALSE</code><ul><li>不启用 Blending，直接写入</li></ul></li></ul></li></ul></li></ul></li><li><code>.pMultisampleState</code>: VkPipelineMultisampleStateCreateInfo<ul><li><code>.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT</code></li><li><code>.pSampleMask = NULL</code></li></ul></li><li><code>.pViewportState</code>: VkPipelineViewportStateCreateInfo<ul><li><code>.viewportCount = 1</code></li><li><code>.scissorCount = 1</code></li><li>不过这里用的 <strong>Dynamic State</strong>，也就是 Viewport 和 Scissor 的信息是在录制 Command Buffer 时提供的，创建 Pipeline 时不提供<ul><li>详情看 <code>.pDynamicState</code></li></ul></li></ul></li><li><code>.pDepthStencilState</code>: VkPipelineDepthStencilStateCreateInfo<ul><li><code>.depthTestEnable = VK_TRUE</code></li><li><code>.depthWriteEnable = VK_TRUE</code></li><li><code>.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL</code></li><li><code>.depthBoundsTestEnable = VK_FALSE</code><ul><li>Samples coverage &#x3D; 0 if outside the bound predetermined</li><li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap28.html#fragops-dbt">28.8. Depth Bounds Test</a></li></ul></li><li><code>.stencilTestEnable = VK_FALSE</code> 下面都是 Stencil test 的参数</li><li><code>.back.failOp = VK_STENCIL_OP_KEEP</code></li><li><code>.back.passOp = VK_STENCIL_OP_KEEP</code></li><li><code>.back.compareOp = VK_COMPARE_OP_ALWAYS</code></li><li><code>.front = ds.back</code></li></ul></li><li><code>.pStages</code>: VkPipelineShaderStageCreateInfo<ul><li><code>[0]</code><ul><li><code>.stage = VK_SHADER_STAGE_VERTEX_BIT</code></li><li><code>.pName = &quot;main&quot;</code></li><li><code>.module = demo_prepare_vs(demo)</code><ul><li>Call demo_prepare_shader_module with vert SPIR-V code<ul><li>vkCreateShaderModule with <code>size_t codeSize</code> &amp; <code>uint32_t *pCode</code></li></ul></li></ul></li></ul></li><li><code>[1]</code><ul><li><code>.stage = VK_SHADER_STAGE_FRAGMENT_BIT</code></li><li><code>.pName = &quot;main&quot;</code></li><li><code>.module = demo_prepare_fs(demo)</code><ul><li>Similar with above</li></ul></li></ul></li></ul></li><li><code>.pDynamicState</code>: VkPipelineDynamicStateCreateInfo<ul><li><code>.pDynamicStates = dynamicStateEnables</code><ul><li>启用了 <code>VK_DYNAMIC_STATE_VIEWPORT</code> 和 <code>VK_DYNAMIC_STATE_SCISSOR</code></li></ul></li></ul></li><li><code>.renderPass</code>: VkRenderPass<br>传入之前创建的 VkRenderPass</li></ul></li></ul></li><li>vkDestroyPipelineCache</li><li>vkDestroyShaderModule * 2<ul><li>删除 vs 和 fs 的两个刚才创建的 Shader Module (<code>demo_prepare_vs</code> &#x2F; <code>demo_prepare_fs</code>)</li></ul></li></ul></li><li>demo_prepare_descriptor_pool<ul><li>vkCreateDescriptorPool<ul><li>VkDescriptorPoolCreateInfo<ul><li><code>.pPoolSizes = &amp;type_count</code><ul><li>VkDescriptorPoolSize<ul><li><code>.type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li><li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>demo_prepare_descriptor_set<ul><li>vkAllocateDescriptorSets：按 Descriptor Set Layouts 从 Descriptor Pool 中分配 Descriptor Sets<ul><li><code>.pSetLayouts = &amp;demo-&gt;desc_layout</code></li><li><code>.descriptorPool = demo-&gt;desc_pool</code></li></ul></li><li>vkUpdateDescriptorSets<br>支持 Write 和 Copy 两种形式的 Descriptor Set 更新请求<ul><li>VkWriteSescriptorSet<ul><li><code>.dstSet = demo-&gt;desc_set</code> 刚分配的 Descriptor Set</li><li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li><li><code>.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li><li><code>.pImageInfo = tex_descs</code><ul><li>VkDescriptorImageInfo: 具体的 Descriptor 内容<ul><li><code>.sampler = demo-&gt;textures[i].sampler</code></li><li><code>.imageView = demo-&gt;textures[i].view</code></li><li><code>.imageLayout = VK_IMAGE_LAYOUT_GENERAL</code><blockquote><p>感觉这里应该是选对应的才对，不知道这样可以不可以</p></blockquote></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>demo_prepare_framebuffers<ul><li>创建 <code>demo-&gt;swapchainImageCount</code> 个 VkFramebuffer<ul><li>vkCreateFramebuffer<ul><li>VkFramebufferCreateInfo<ul><li><code>.renderPass = demo-&gt;renderpass</code></li><li><code>.pAttachments</code>: VkImageView[]<ul><li><code>[0]</code>: Color Attachment, <code>demo-&gt;buffers[i].view</code><ul><li>That is, the swapchain image view</li></ul></li><li><code>[1]</code>: Depth Attachment<ul><li><code>demo-&gt;depth.view</code></li></ul></li></ul></li><li><code>.width</code>, <code>.height</code></li><li><code>.layers = 1</code><blockquote><p>正如 VkImage 创建时也可以选择多 layer 一样，这里也可以；不过 Shader 默认写入第一层，除了 Geometry Shader</p><p>多 layer 的 Image &#x2F; Framebuffer 在 Shader 里面是用的 texture array 的语法来访问的</p></blockquote></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>demo_run<ul><li>glfwWindowShouldClose: 检测窗口的 closing 标志</li><li>glfwPollEvent</li><li>demo_draw<ul><li>vkCreateSemaphore: <code>imageAcquiredSemaphore</code></li><li>vkCreateSemaphore: <code>drawCompleteSemaphore</code></li><li>vkAcquireNextImageKHR<blockquote><p>这里有一个问题，这里返回并不意味着 Present 完成 (推荐做法是 Present 设置 Semaphore，然后等 Semaphore)</p><p>那么，什么情况下这里会 block？<br>也可以参考 <a href="https://stackoverflow.com/questions/64150186/lets-get-swapchains-image-count-straight">Let’s get swapchain’s image count straight - StackOverflow</a></p></blockquote><ul><li><code>timeout = UINT64_MAX</code></li><li><code>semaphore = imageAcquiredSemaphore</code></li><li><code>pImageIndex = &amp;demo-&gt;current_buffer</code>: index of the next image to use<ul><li>完成后会 signal 该 semaphore</li></ul></li><li>返回值<ul><li>VK_ERROR_OUT_OF_DATE_KHR<ul><li>demo_resize: 处理 resize 情况：<strong>Destroy everything</strong><ul><li>vkDestroyFramebuffer</li><li>vkDestroyDescriptorPool</li><li>vkFreeCommandBuffers</li><li>vkDestroyCommandPool</li><li>vkDestroyPipeline</li><li>vkDestroyRenderPass</li><li>vkDestroyPipelineLayout</li><li>vkDestroyDescriptorSetLayout</li><li>vkDestroyBuffer (vertex buffer)</li><li>vkFreeMemory (vertex buffer memory)</li><li>vkDestroyImageView</li><li>vkDestroyImage</li><li>vkDestroySampler</li><li>…</li><li>call <code>demo_prepare</code></li></ul></li><li>demo_draw: 重复调用一下自己</li></ul></li><li>VK_SUBOPTIMAL_KHR: 不是最优，但是也能 present，所以不管</li></ul></li></ul></li><li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul><li>vkEndCommandBuffer</li><li>vkQueueSubmit<ul><li>no wait &#x2F; signal semaphores</li></ul></li><li>vkQueueWaitIdle</li><li>vkFreeCommandBuffers</li><li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li></ul></li><li>demo_draw_build_cmd<ul><li>vkBeginCommandBuffer: <code>demo-&gt;draw_cmd</code></li><li>vkCmdPipelineBarrier<ul><li>Execution barrier 部分<ul><li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li><li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)<blockquote><p><code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> is equivalent to <code>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code> with VkAccessFlags set to 0 when specified in the first synchronization scope, but specifies no stage of execution when specified in the second scope.</p></blockquote></li></ul></li><li>Memory barrier 部分: 对 color attachment 做 layout transition<ul><li>从 <code>VK_IMAGE_LAYOUT_UNDEFINED</code> -&gt; <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li><li><code>.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li></ul></li></ul></li><li>vkCmdBeginRenderPass with <code>VK_SUBPASS_CONTENTS_INLINE</code><blockquote><p><code>VK_SUBPASS_CONTENTS_INLINE</code> specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers must not be executed within the subpass.</p></blockquote><ul><li>VkRenderPassBeginInfo<ul><li><code>.renderPass</code></li><li><code>.framebuffer</code> - 选择<strong>当前</strong>的 framebuffer，我们有 <code>swapchainImageCount</code> 个</li><li><code>.renderArea</code><ul><li><code>.offset.&#123;x, y&#125;</code></li><li><code>.extent.&#123;width, height&#125;</code></li></ul></li><li><code>.pClearValues = clear_values</code> (VkClearValue)<blockquote><p>这里是和 RenderPassCreateInfo 指定的 attachments 相对应的</p><p><code>pClearValues</code> is a pointer to an array of <code>clearValueCount</code> VkClearValue structures containing clear values for each attachment, if the attachment uses a <code>loadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> or if the attachment has a depth&#x2F;stencil format and uses a <code>stencilLoadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.</p></blockquote><ul><li><code>[0] = &#123;.color.float32 = &#123;0.2f, 0.2f, 0.2f, 0.2f&#125;&#125;</code></li><li><code>[1] = &#123;.depthStencil = &#123;demo-&gt;depthStencil, 0&#125;&#125;</code><ul><li><code>demo-&gt;depthStencil</code> 用来加一个“无形的墙”</li></ul></li></ul></li></ul></li></ul></li><li>vkCmdBindPipeline<ul><li><code>pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code></li></ul></li><li>vkCmdBindDescriptorSets<ul><li><code>layout = demo-&gt;pipeline_layout</code><br>Recall: Pipeline layout &lt;&#x3D; Descriptor Set Layouts</li><li>Descriptor Sets</li></ul></li><li>vkCmdSetViewport<ul><li>VkViewport<ul><li><code>.height</code>, <code>.width</code>, <code>.minDepth</code>, <code>.maxDepth</code></li></ul></li></ul></li><li>vkCmdSetScissor<ul><li>VkRect2D<ul><li><code>.extent.&#123;width, height&#125;</code></li><li><code>.offset.&#123;x, y&#125;</code></li></ul></li></ul></li><li>vkCmdBindVertexBuffers<blockquote><p>看 <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp</a> 可能会印象更深刻</p></blockquote><ul><li>firstBinding 参数用于 (CPU 端) 指定绑定到哪里</li></ul></li><li>vkCmdDraw<ul><li><code>vertexCount = 3</code></li><li><code>instanceCount = 1</code></li><li><code>firstVertex = 0</code></li><li><code>firstInstance = 0</code></li></ul></li><li>vkCmdEndRenderPass</li><li>vkCmdPipelineBarrier<ul><li>Execution barrier:<ul><li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li><li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)</li></ul></li><li>Memory barrier:<blockquote><p>正如 transfer，present 也需要 layout 改变</p></blockquote><ul><li><code>.srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li><li><code>.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT</code></li><li><code>.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li><li><code>.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code></li></ul></li></ul></li><li>vkEndCommandBuffer: <code>demo-&gt;draw_cmd</code></li></ul></li><li>vkQueueSubmit<ul><li><code>.pCommandBuffers = &amp;demo-&gt;draw_cmd</code></li><li><code>.pWaitSemaphores = &amp;imageAcquiredSemaphore</code></li><li><code>.pWaitDstStageMask = &amp;pipe_stage_flags</code><ul><li><code>pWaitDstStageMask</code> is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.</li><li>这里设置成了 <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code></li><li>所以，相当于啥也没等</li></ul></li><li><code>.pSignalSemaphores = &amp;drawCompleteSemaphore</code></li></ul></li><li>vkQueuePresentKHR<ul><li>VkPresentInfoKHR<ul><li><code>.pWaitSemaphores = &amp;drawCompleteSemaphore</code></li><li><code>.pSwapchains = &amp;demo-&gt;swapchain</code><ul><li>可以多个，用来支持多个 swapchain 用一个 queue present 操作进行 present</li></ul></li><li><code>.pImageIndices = &amp;demo-&gt;current_buffer</code></li></ul></li><li>返回值<ul><li>VK_ERROR_OUT_OF_DATE_KHR<ul><li>demo_resize</li></ul></li><li>VK_SUBOPTIMAL_KHR<ul><li>啥事不干</li></ul></li></ul></li></ul></li><li>vkQueueWaitIdle</li><li>vkDestroySemaphore: <code>imageAcquiredSemaphore</code></li><li>vkDestroySemaphore: <code>drawCompleteSemaphore</code></li></ul></li><li>demo-&gt;depthStencil 周期改变</li><li>vkDeviceWaitIdle</li><li>如果到了指定的帧数，则 glfwSetWindowShouldClose</li></ul></li><li>demo_cleanup<ul><li>删除一万个东西 (literally)</li><li>glfwDestroyWindow</li><li>glfwTerminate</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一些有用的链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.khronos.org/bl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | 数据驱动的 PRT</title>
    <link href="https://blog.libreliu.info/paper-reading/data-driven-prt/"/>
    <id>https://blog.libreliu.info/paper-reading/data-driven-prt/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文省略了一大堆细节，详情参见论文。</p><p>TODO: 整理清楚各个维数，因为原论文也不甚详细；</p><p>更新后的版本会放到 <a href="https://blog.libreliu.info/paper-reading/data-driven-prt/">这里</a>，如果有。</p></blockquote><h2 id="Recap-Precomputed-Radiance-Transfer"><a href="#Recap-Precomputed-Radiance-Transfer" class="headerlink" title="Recap: Precomputed Radiance Transfer"></a>Recap: Precomputed Radiance Transfer</h2><blockquote><p>本节主要参考<a href="https://www.bilibili.com/video/BV1YK4y1T7yY">GAMES 202 - 高质量实时渲染</a>课程的 Lecture 6 和 Lecture 7</p></blockquote><p>考虑渲染方程</p>$$L({\bf o}) = \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}$$<p>其中</p><ul><li>$ {\bf i}, {\bf o} $ 为入射和出射方向</li><li>$ L({\bf i}), L({\bf o}) $ 为入射和出射 radiance<ul><li>此处<strong>省略了</strong>作为参数的 shading point 位置 $ \bf x $，下同</li></ul></li><li>$ \rho $ 为 BRDF 函数</li><li>$ V $ 为 Visibility 项</li></ul><p>将 $ L({\bf i}) $ 项用级数的有限项进行近似，即</p>$$L({\bf i}) \approx \sum_{i=1}^{n} l_i B_i({\bf i})$$<blockquote><p>其中 $ B_i: S^2 \to \mathbb{R} $ 为基函数</p></blockquote><p>带入得到</p>$$\begin{aligned}L({\bf o}) &= \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\&\approx \sum_i l_i \int_{\mathcal{H}^2} B_i({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\&= \sum_i l_i T_i({\bf o})\end{aligned}$$<p>这里把上面的积分 (“Light transport term”) 记作 $ T_i $.</p><p>这里继续进行展开</p>$$T_i({\bf o}) \approx \sum_{j=1}^{m} t_{ij} B_j({\bf o})$$<p>所以我们得到</p>$$\begin{aligned}L({\bf o}) &\approx \sum_i l_i T_i({\bf o}) \\&\approx \sum_i l_i \left( \sum_j t_{ij} B_j({\bf o}) \right) \\&\approx \sum_j \left( \sum_i l_i t_{ij} \right) B_j({\bf o}) \\\end{aligned}$$<p>也就是说</p>$$L({\bf o}) \approx \begin{bmatrix}l_1 & ... & l_n\end{bmatrix}\begin{bmatrix}t_{11} & ... & t_{1m} \\\vdots & & \vdots \\t_{n1} & ... & t_{nm}\end{bmatrix}\begin{bmatrix}B_1({\bf o}) \\ \vdots \\ B_m({\bf o})\end{bmatrix}$$<p>那么，PRT 的框架就大致如下</p><ol><li><p>预计算</p><ul><li>对每个可能的 shading point $ {\bf x} $<ul><li>计算该物体的环境光在基函数下对应的系数 $ l_i $</li><li>计算该物体光传输展开系数 $ t_{ij} $</li></ul></li></ul><blockquote><p>当然，对于 Image based lighting，一般认为 $ L({\bf i}, {\bf x}) \approx L({\bf i}) $，那某些东西就不需要 per-shading point 存储</p></blockquote></li><li><p>运行时</p><ul><li>根据视角 $ {\bf o} $ 和位置 $ {\bf x} $ 来读取对应的向量并计算</li></ul></li></ol><blockquote><p>对于 Diffuse 物体，$ \rho({\bf i}, {\bf o}) $ 是常数，所以不需要继续展开 $ T_i $ 项</p></blockquote><blockquote><p>Remarks from paper: PRT methods bake the transport matrix using implicit light sources defined by the illumination basis.<br>Those light sources shade the asset with positive and negative radiance values. Hence, a dedicated light transport algorithm is used for them.</p></blockquote><h2 id="本文思路"><a href="#本文思路" class="headerlink" title="本文思路"></a>本文思路</h2><p>本文的框架只考虑<strong>漫反射</strong>，虽然结果上对于不是特别 Glossy 的材质应该都可以应用。</p><p>框架上的思路就是</p><ul><li>间接光 $ L_i({\bf x}; t) $ 和直接光 $ L_d({\bf i}, {\bf x}; t) $ 之间存在线性关系</li><li>框架：<ul><li>将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ I &#x3D; MD $<ul><li>相当于挑了一组基，每个基内部由同一个光照条件下各个位置的 $ L_d $ 组成</li></ul></li><li>对于给定的光照条件 $ x $ （各个位置 $ L_d $的值构成的列向量） ，如何求解 $ L_i $ ？<ul><li>首先把 $ x $ 分解到该 $ D $ 基下，得到系数向量 $ c &#x3D; (D^T D)^{-1} D^T x $</li><li>每个 $ D $ 基我们都存储有对应的输出，所以结果 $ y &#x3D; Mx &#x3D; I(D^T D)^{-1} D^T x $</li></ul></li></ul></li><li>近似：<ul><li>对 $ I $ 进行 SVD 分解并保留前 $ k $ 项，得到近似矩阵 $ I &#x3D; U \Sigma V^T \approx U_n \Sigma_n V_n^T $</li><li>$ y \approx U_n (\Sigma_n V_n^T) (D^T D)^{-1} D^T x $<ul><li>let $ M_n &#x3D; (\Sigma_n V_n^T) (D^T D)^{-1} D^T $</li></ul></li><li>存储 $ U_n $ 和 $ M_n $</li></ul></li><li>运行时：<ul><li>用 G-Buffer 得到 $ \mathcal{X}_D $ 空间上的各 $ L_d({\bf i}, {\bf x}; t) $ 的值</li><li>计算 $ y &#x3D; U_n M_n x $ 的值</li></ul></li></ul><h3 id="估计光传输矩阵"><a href="#估计光传输矩阵" class="headerlink" title="估计光传输矩阵"></a>估计光传输矩阵</h3><p>给定<strong>环境光</strong>条件 $ t \in \mathcal T $，那么在物体表面 $ {\bf x} $ 处，<strong>漫反射</strong>光传输方程的形式如下</p>$$L_i({\bf x}; t) = \frac{1}{2 \pi}\int_{\mathcal{H}^2} L_d({\bf i}, {\bf x}; t) V({\bf i}, {\bf x}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}$$<p>其中，$ L_i({\bf x}; t) $ 被称为间接光， $ L_d({\bf i}, {\bf x}; t) $ 被称为直接光</p><blockquote><p>$ L_d({\bf i}, {\bf x}; t) $ 不考虑环境和物体 inter-reflection; 推导中可以先忽略，虽然实际上对于有 inter-transmission 的情况应该也是可以应用的</p></blockquote><p>现在将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ \mathcal{X}_D $ 和 $ \mathcal{T}_D $ 两有限维空间，那么在这两个空间上， $ L_d $ 和 $ L_i $ 都可以表示为矩阵形式，这里规定每一列的元素在同一个环境光条件 $ {\bf i}, t $ 上。</p><blockquote><p>比如说，都在环境光为某点光源照射的情况； $ L_d({\bf i}, {\bf x}; t) $ 的 $ {\bf i} $ 一般意义上是依赖 $ t $ 的</p></blockquote><p>记得到的两个矩阵为 $ D $ 和 $ I $，则</p>$$I_k = f(D_k) \quad \forall k \in [0, |\mathcal{T}_D|]$$<p>从前面可以看到，这里的 $f$ 是线性算子 (<em>是嘛？</em>)，所以</p>$$I = MD$$<p>又假设我们离散 $ \mathcal T $ 空间离散的很好，那么对任意的环境光条件，<strong>直接光向量</strong> $ x $ 都可以表示成 $ D $ 的线性组合，满足</p>$$x = Dc$$<p>左右乘 $ M $ 得到</p>$$Mx = MDc = Ic$$<p>也就是说 $x$ 产生的间接光照可以用 $I$ 中列向量的线性组合来表示</p><p>因为 $ x &#x3D; Dc $，假设 $ D^T D $ 可逆，那么用左逆得到</p>$$c = (D^T D)^{-1} D^T x$$<p>那么</p>$$y = Mx = Ic = I (D^T D)^{-1} D^T x$$<p>这样就给出了<strong>任意直接光经过光传输</strong>的结果</p><h3 id="间接光基函数"><a href="#间接光基函数" class="headerlink" title="间接光基函数"></a>间接光基函数</h3><p>我们认为，间接光所对应的空间的秩比较低，所以用 SVD 分解然后保留前 $ n $ 项</p>$$I = U \Sigma V^T \approx U_n \Sigma_n V_n^T = U_n C_n$$<p>其中记 $ C_n &#x3D; \Sigma_n V_n^T $</p><p>带回去，得到任意直接光组合经过光传输方程的近似结果</p>$$\begin{aligned}y &\approx U_n C_n (D^T D)^{-1} D^T x \\&\approx U_n M_n x\end{aligned}$$<p>其中 $ M_n &#x3D; C_n (D^T D)^{-1} D^T $</p><h3 id="直接光编码"><a href="#直接光编码" class="headerlink" title="直接光编码"></a>直接光编码</h3><p>如果有需要的话，可以考虑 SH 基函数，详见文章</p><h2 id="对比经典-PRT"><a href="#对比经典-PRT" class="headerlink" title="对比经典 PRT"></a>对比经典 PRT</h2><p>First, because classical PRT restricts the frequency content of the incoming lighting, we can see that the directional light leaks behind the object. Our method <strong>does not restrict the frequency content of incoming light</strong> but rather <strong>the space of possible indirect illumination</strong>.  Hence, we can better reproduce such lighting scenario. </p><p>Furthermore, classical PRT is performed on the vertices of the asset. This can cause interpolation artifacts when the asset is poorly tessellated, and it also links performance to the vertex count. Since we rely on a <strong>meshless approach</strong>, we are free of issues.</p><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p><strong>Sparse Illumination Measurement</strong>. As shown in Section 3.3, the sampling of the measurement points is linked to the achievable lighting dimensionality. Thus, it needs to be sufficiently dense to reproduce the space of observable lighting configurations. It follows that a lighting scenario mixing many light types might require a denser sampling. </p><p><strong>No Directionality</strong>. We reconstruct a diffuse appearance when reconstructing indirect illumination. However, since our method does not depend on the encoding of the measured indirect illumination, it can be extended to reconstruct glossy appearances e.g. directional distributions using directional sampling or any basis such as Spherical Harmonics. However, our method is likely to be restricted to low frequency gloss here and will not work to render specular reflections. </p><p><strong>Large Assets</strong>. Our solution is not designed to handle assets such as levels in a game. Because we handle light transport globally and reduce it with a handful of basis functions, we cannot reconstruct the interconnected interiors or large environments in which the combinatorics of possible illumination is large. For such case, our method would require to be extended to handle modular transfer between disjoint transport solutions (Similar to Loos et al. [2011]).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文省略了一大堆细节，详情参见论文。&lt;/p&gt;
&lt;p&gt;TODO: 整理清楚各个维数，因为原论文也不甚详细；&lt;/p&gt;
&lt;p&gt;更新后的版本会放到 &lt;a href=&quot;https://blog.libreliu.info/paper-reading/data</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | 连续多重重要性采样</title>
    <link href="https://blog.libreliu.info/paper-reading/continuous-mis/"/>
    <id>https://blog.libreliu.info/paper-reading/continuous-mis/</id>
    <published>2022-11-04T16:00:00.000Z</published>
    <updated>2022-11-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章扩展了 Veach 在 1995 年提出的、用于 Monte Carlo 多重重要性采样 (Multiple Importance Sampling)，将其推广到了具有<strong>无限</strong>的<strong>连续</strong>采样策略的情况。</p><h2 id="多重重要性采样-MIS"><a href="#多重重要性采样-MIS" class="headerlink" title="多重重要性采样 (MIS)"></a>多重重要性采样 (MIS)</h2><blockquote><p>本方法比较详细的讨论可以参考 <em>Optimally Combining Sampling Techniques<br>for Monte Carlo Rendering</em> 这篇 SIGGRAPH’95 的论文，是 Veach 和 Guibas 很高引用的文章之一。</p><p>也可以参考 <a href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling">Importance Sampling | PBR Book 3rd</a>，不过里面没有证明。</p></blockquote><p>对于积分</p>$$I = \int_\Omega f(x) dx$$<p>我们希望用 Monte Carlo 采样的方法进行积分值的估计。</p><p>多重重要性采样 (Multiple Importance Sampling, MIS) 的大致思路如下：有 $ m $ 个采样策略，每个采样策略都可以对样本空间 $ \Omega $ 进行采样，并且每种策略都有概率密度函数 $ p_i(x) $。</p><p>对于 Multi-sample MIS，要分别使用每种采样策略<strong>独立</strong>采样 $ n_i $ 次，获得总计 $ \sum_{i&#x3D;1}^{m} n_i $ 个采样，然后使用如下的式子进行积分的估计：</p>$$\langle I \rangle_{mis} = \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})}$$<p>其中 $ x_{i, j} $ 表示第 $ i $ 个采样策略第 $ j $ 次采样获得的值，$ w_i(x) $ 为 $ m $ 个与 MIS 相关的权重函数。</p><p>首先可以证明，这 $ m $ 个权重函数只要满足 $ \sum_{i&#x3D;1}^m w_i(x) &#x3D; 1 $，那么 $ \langle I \rangle_{mis} $ 就是无偏的：</p>$$\begin{aligned}\operatorname{E}[\langle I \rangle_{mis}] &= \operatorname{E}\left[ \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\&= \sum_{i=1}^m \frac{1}{n_i} \operatorname{E}\left[ \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\&= \sum_{i=1}^m \operatorname{E}\left[ \frac{w_i(x_{i,1}) f(x_{i, 1})}{p_i(x_{i,1})} \right] \quad (\because \text{i.i.d})\\&= \sum_{i=1}^m \int_\Omega \frac{w_i(x) f(x)}{p_i(x)} p_i(x) dx \\&= \sum_{i=1}^m \int_\Omega w_i(x) f(x) dx \\&= \int_\Omega \sum_{i=1}^m w_i(x) f(x) dx \\&= \int_\Omega f(x) dx \\&= I\end{aligned}$$<p>那么，哪样的权重会让估计量的方差比较小呢？Veach 和 Guibas 在其论文中，给出了被称为 <strong>Balance Heuristic</strong> 的估计量：</p>$$\hat w_i (x) = \frac{c_i p_i(x)}{\sum_{j=1}^m c_j p_j(x)} \quad \text{where}\ c_i = n_i / \sum_{j=1}^{m} n_j $$<p>并且他们证明了，使用 $ { \hat w_i(x) }<em>{i&#x3D;1}^m $ 作为权重函数构造的估计量 $ \langle \hat I</em>{mis} \rangle $ 和<strong>任意的</strong>权重函数构造的估计量 $ \langle I_{mis} \rangle $ 的方差满足下面的关系：</p>$$\operatorname{V}[\langle \hat I \rangle_{mis}] \le \operatorname{V}[\langle I \rangle_{mis}] + \left( \frac{1}{\min_i n_i} - \frac{1}{\sum_i n_i} \right) I^2 $$<p>这其实在说，Balance Heuristic 从渐进意义上来说是方差比较低的估计。</p><p>有的时候，我们只希望采样一次。这种情况下，我们可以首先以 $P(t&#x3D;i)$ 的概率去采样我们将要使用的采样方法 $t$，然后再使用 MIS 积分估计量：</p>$$\langle I \rangle_{mis} = \frac{w_t(x_{t,1}) f(x_{t,1})}{p_t(x_{t,1}) P(t=i)}$$<p>其中 $ p_t(x_{t,1}) $ 表示采样方法为 $ t $ 情况下抽样到 $ x_{t,1} $ 的条件概率。</p><p>Veach 的论文中证明，Balance Heuristic 在任何 One-sample MIS 的情形下都是最优的权重组合。</p><h2 id="连续多重重要性采样-Continuous-MIS"><a href="#连续多重重要性采样-Continuous-MIS" class="headerlink" title="连续多重重要性采样 (Continuous MIS)"></a>连续多重重要性采样 (Continuous MIS)</h2><p>West 等人将上面的工作进行了进一步的推广：如果现在有连续的无限多种采样策略，那么也可以将 MIS 中的估计量进行推广，得到<strong>连续多重重要性采样</strong> (Continuous Multiple Importance Sampling, CMIS)。</p><p>定义采样方法空间 $ \mathcal{T} $，在其上的每个元素 $ t \in \mathcal{T} $ 都是一种采样策略。</p><p>那么自然可以想到，将 $ w_i(x) $ 推广为一个 $ \mathcal{T} \times \mathcal{X} \to \mathrm{R} $ 的函数 $ w(t, x) $，归一化条件 $ \sum_i w_i(x) &#x3D; 1 $ 推广为 $ \int_\mathcal{T} w(t, x) dt &#x3D; 1 $。</p><p>类似的，可以定义 One-sample CMIS 积分估计量</p>$$\langle I \rangle_{CMIS} = \frac{w(t, x)f(x)}{p(t, x)} = \frac{w(t, x)f(x)}{p(t) p(x|t)}$$<p>其中 $ p(t) $ 是选择策略 $ t $ 的概率密度， $ p(x|t) $ 是在策略 $ t $ 下采样得到 $ x $ 的条件概率。</p><p>同时，只要满足如下两个条件，上面的估计量就是无偏的：</p><ol><li>$ \int_\mathcal{T} w(t, x) dt = 1 $ 对任何 $ x \in \operatorname{supp} f(x) $ 成立</li><li>当 $ p(t, x) &#x3D; 0 $ 时，$ w(t, x) &#x3D; 0 $ <blockquote><p>为什么？</p></blockquote></li></ol><p>类比 MIS，CMIS 也可以定义 Balance Heuristic 如下：</p>$$\bar w(t, x) = \frac{p(t)p(x|t)}{\int_\mathcal{T} p(t') p(x|t') dt'} = \frac{p(t, x)}{\int_\mathcal{T} p(t', x)dt} = \frac{p(t, x)}{p(x)}$$<blockquote><p>那么其实可以看到，用 Balance Heristic 的 $ w(t, x) $ 带入到 $ \langle I \rangle_{CMIS} $ 之后，其实就会化简成为 $ f(x) &#x2F; p(x) $，只不过这里的 $ p(x) $ 是 $ p(t, x) $ 的边缘分布。</p></blockquote><h2 id="随机多重重要性采样-Stochastic-MIS"><a href="#随机多重重要性采样-Stochastic-MIS" class="headerlink" title="随机多重重要性采样 (Stochastic MIS)"></a>随机多重重要性采样 (Stochastic MIS)</h2><p>前面的方法会面临一个问题，有的时候 $ p(x) &#x3D; \int_\mathcal{T} p(t’, x)dt $ 是没有闭式解的，这样去算 $ \bar w(t, x) $ 的时候会遇到问题。所以，West 等人又提出了随机多重重要性采样 (Stochastic MIS, SMIS)。</p><p>SMIS 首先假设在 $ \mathcal{T} \times \mathcal{X} $ 中独立的采样 $ (t_1, x_1), …, (t_n, x_n) $ 共 $n$ 组点。</p><blockquote><p>TODO: implement me</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="Path-Reuse"><a href="#Path-Reuse" class="headerlink" title="Path Reuse"></a>Path Reuse</h4><h4 id="Spectral-Rendering"><a href="#Spectral-Rendering" class="headerlink" title="Spectral Rendering"></a>Spectral Rendering</h4><h4 id="Volume-Single-Scattering"><a href="#Volume-Single-Scattering" class="headerlink" title="Volume Single Scattering"></a>Volume Single Scattering</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章扩展了 Veach 在 1995 年提出的、用于 Monte Carlo 多重重要性采样 (Multiple Importance </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个示例 D3D11 程序的全流程记录</title>
    <link href="https://blog.libreliu.info/example-d3d11-app-flow/"/>
    <id>https://blog.libreliu.info/example-d3d11-app-flow/</id>
    <published>2022-10-18T16:00:00.000Z</published>
    <updated>2022-10-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是笔者进行 RenderDoc drivers 层分析时一并记录下来的，是一个渲染 Cube 的简单 D3D11 程序与 API 交互的全流程的记录。</p><p>以 <a href="https://github.com/libreliu/DirectX11-With-Windows-SDK/tree/master/Project%2001-09/03%20Rendering%20a%20Cube">DirectX11-With-Windows-SDK - Rendering A Cube</a> 为例进行说明。</p><blockquote><p>DXGI (<strong>D</strong>irect<strong>X</strong> <strong>G</strong>raphics <strong>I</strong>nfrastructure) 负责抽象和交换链、DAL 相关的公共部分。关于 DXGI 的资料可以参考 <a href="https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi">MSDN</a>。</p><p>DXGI 封装了多种对象：</p><ul><li>显示适配器 (IDXGIAdapter): 一般对应一块显卡，也可以对应 Reference Rasterizer，或者支持虚拟化的显卡的一个 VF 等</li><li>显示输出 (IDXGIOutput): 显示适配器的输出，一般对应一个显示器</li><li>交换链 (IDXGISwapChain): 用来暂存要显示到输出窗口&#x2F;全屏幕的 1 到多个 Surface 的对象<ul><li><code>g_pSwapChain-&gt;GetBuffer</code> 可以拿到表示 Back Buffer 的 <code>ID3D11Texture</code></li><li>从 <code>g_pd3dDevice-&gt;CreateRenderTargetView</code> 来创建一个封装该 Texture 的 <code>ID3D11RenderTargetView</code></li><li><code>g_pd3dDeviceContext-&gt;OMSetRenderTargets</code> 来设置管线的 RenderTarget</li><li><code>g_pd3dDeviceContext-&gt;RSSetViewports</code> 来设置管线的 Viewport</li></ul></li></ul></blockquote><!--> 和 DRM (master) 的相应概念的对比：> - NOTE: 我只看过 DRM Master (?) 的相关 API> > DRM 里面有> - KMS:>   - CRT Controller, Encoder, Connector, Plane>   - 感觉 IDXGIAdapter 约等于 /dev/dri/card0 ... 等加速设备>   - 但也不是，因为 DRM 的 master 节点的访问限制 (?)>   - TODO: 理一理 DRM> - Buffer Object Management--><h2 id="GameApp-Init"><a href="#GameApp-Init" class="headerlink" title="GameApp::Init()"></a><code>GameApp::Init()</code></h2><ul><li><code>D3DApp::Init()</code><ul><li><code>InitMainWindow()</code><ul><li><code>RegisterClass(WNDCLASS *)</code>: 注册</li><li><code>AdjustWindowRect()</code></li><li><code>CreateWindow()</code></li><li><code>ShowWindow()</code></li><li><code>UpdateWindow()</code></li></ul></li><li><code>InitDirect3D()</code><ul><li><p><code>D3D11CreateDevice()</code>: 采用 11.1 的 Feature Level，不行则降级</p><p>该函数会返回 Immediate Context (<code>ID3D11DeviceContext</code>), 设备 (<code>ID3D11Device</code>) 和特性等级</p></li><li><p><code>ID3D11Device::CheckMultisampleQualityLevels</code>: 查询给定 DXGI_FORMAT 是否支持给定倍数的 MSAA</p></li><li><p>将前面的 <code>ID3D11Device</code> Cast 到 <code>IDXGIDevice</code></p><blockquote><p>An <code>IDXGIDevice</code> interface implements a derived class for DXGI objects that produce image data.</p></blockquote></li><li><p><code>IDXGIDevice::GetAdapter</code> 拿到 <code>IDXGIAdapter</code></p><blockquote><p>The <code>IDXGIAdapter</code> interface represents a display subsystem (including one or more GPUs, DACs and video memory).</p></blockquote></li><li><p><code>IDXGIAdapter::GetParent</code> 拿到 <code>IDXGIFactory1</code></p><blockquote><p>这里的 <code>GetParent</code> 是 <code>IDXGIAdapter</code> 作为 <code>IDXGIObject</code> 的方法，可以获得构造它的工厂类。</p><p>The <code>IDXGIFactory1</code> interface implements methods for generating DXGI objects.</p></blockquote></li><li><p>尝试将 <code>IDXGIFactory1</code> Cast 到 <code>IDXGIFactory2</code> (DXGI 1.2 新增)</p><ul><li>如果支持 DXGI 1.2，则用 <code>CreateSwapChainForHwnd</code> 来创建交换链</li><li>否则，用 <code>CreateSwapChain</code> 来创建交换链<blockquote><p>这两个函数都可以创建窗口 &#x2F; 全屏幕交换链；DXGI 1.2 增加了新的、到其它输出目标的交换链创建功能，所以这里进行了重构。</p><p>也要注意，不同 DirectX 可以支持的<a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/ne-dxgi-dxgi_swap_effect">交换链的交换行为类型</a>是不同的。大体上，交换链的交换行为可以分为</p><ul><li>DISCARD vs SEQUENTIAL: 可以参考 <a href="https://gamedev.stackexchange.com/questions/58654/what-is-the-difference-between-dxgi-swap-effect-discard-and-dxgi-swap-effect-seq">StackExchange</a>，区别就是一个驱动可以放心扔掉，另一个必须保留回读可能</li><li>FILP vs BLIT (Bit Block Transfer): 决定是用交换指针还是数据拷贝的方法来从交换链被 Present 的 Surface 中拿取数据</li></ul></blockquote></li></ul></li><li><p><code>IDXGIFactory1::MakeWindowAssociation</code> 来取消让 DXGI 接收 Alt-Enter 的键盘消息并且切换窗口和全屏模式</p></li><li><p><code>D3D11SetDebugObjectName()</code></p><ul><li><code>ID3D11DeviceChild::SetPrivateData(WKPDID_D3DDebugObjectName, ...)</code> 来设置资源的内部数据，这里是调试名称</li></ul></li><li><p><code>DXGISetDebugObjectName()</code></p><ul><li><code>IDXGIObject::SetPrivateData(WKPDID_D3DDebugObjectName, ...)</code> 来设置资源的内部数据，这里是调试名称</li></ul></li><li><p><code>OnResize()</code></p><ul><li><code>IDXGISwapChain::ResizeBuffers()</code></li><li><code>IDXGISwapChain::GetBuffer()</code> 拿到 <code>ID3D11Texture2D</code> 形式的 Back Buffer</li><li><code>IDXGISwapChain::CreateRenderTargetView()</code> 创建绑定到上面 Back Buffer 的 Texture 的渲染目标视图</li><li><code>D3D11SetDebugObjectName</code> 来设置 Back Buffer 的调试名称 </li><li><code>ID3D11Device::CreateTexture2D()</code> 来创建深度模板缓冲 (Depth Stencil Buffer)，类型 <code>ID3D11Texture2D</code>，包含大小，MipLevel，采样描述等</li><li><code>ID3D11Device::CreateDepthStencilView()</code> 来创建前面缓冲对应的深度模板视图</li><li><code>ID3D11DeviceContext::OMSetRenderTargets()</code> 来将渲染目标视图和深度木板视图绑定到管线</li><li><code>ID3D11DeviceConetxt::RSSetViewports()</code> 绑定 Viewport 信息到光栅器状态</li><li><code>D3D11SetDebugObjectName()</code> 设置调试前面各种视图对象的对象名</li></ul></li></ul></li></ul></li><li><code>InitEffect()</code><ul><li><code>CreateShaderFromFile()</code>: 传入 CSO (Compiled Shader Object) 和 Shader 文件，输出 <code>ID3DBlob *</code><ul><li>如果有缓存，则用 <code>D3DReadFileToBlob</code> 装入，并返回</li><li><code>D3DCompileFromFile()</code>: 编译并生成 <code>ID3DBlob</code> 对象</li><li>如果指定了缓存路径，则 <code>D3DWriteBlobToFile()</code> 进行输出<blockquote><p>分别创建了 <code>vs_5_0</code> 和 <code>ps_5_0</code> Shader Model 的 Shader Blob</p></blockquote></li></ul></li><li><code>ID3D11Device::CreateVertexShader()</code>，根据 Shader Bytecode 创建 <code>ID3D11VertexShader</code> 对象<blockquote><p>注意这个函数支持传入 Class Linkage，这是一种在 Shader 间共享类型和变量的机制，在 Shader Model 5 被引入。更详细的用法可以参考 <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/overviews-direct3d-11-hlsl-dynamic-linking-class">Dynamic Linking Class | MSDN</a></p><p>TODO: 研究一下</p></blockquote></li><li><code>ID3D11Device::CreateInputLayout()</code> 传入输入元素描述符和 Shader，传出 <code>ID3D11InputLayout</code> 对象</li><li><code>ID3D11Device::CreatePixelShader()</code> ，根据 Shader Bytecode 创建 <code>ID3D11PixelShader</code> 对象</li></ul></li><li><code>InitResource()</code><ul><li><code>ID3D11Device::CreateBuffer()</code> 创建顶点缓冲区 (<code>ID3D11Buffer</code>) ，并传入初始化数据</li><li><code>ID3D11Device::CreateBuffer()</code> 创建索引缓冲区 (<code>ID3D11Buffer</code>) ，并传入初始化数据</li><li><code>ID3D11DeviceContext::IASetIndexBuffer()</code> 设置 Immediate Context 绑定索引缓冲区</li><li><code>ID3D11Device::CreateBuffer()</code> 创建常量缓冲区 (<code>ID3D11Buffer</code>) ，不是用初始化数据<ul><li>此处设置 <code>D3D11_BUFFER_DESC</code> 的 <code>CPUAccessFlags</code> 为 <code>D3D11_CPU_ACCESS_WRITE</code>，让 CPU 可以改变其值</li></ul></li><li><code>ID3D11DeviceContext::IASetVertexBuffers()</code> 设置顶点缓冲区，stride 和 offset</li><li><code>ID3D11DeviceContext::IASetPrimitiveTopology()</code> 设置图元类型</li><li><code>ID3D11DeviceContext::IASetInputLayout()</code> 设置输入布局</li><li><code>ID3D11DeviceContext::VSSetShader()</code> 绑定顶点着色器到管线</li><li><code>ID3D11DeviceContext::VSSetConstantBuffers()</code> 设置常量缓冲区<blockquote><p>这里当然是拿着 ID3D11Buffer 去设置</p></blockquote></li><li><code>ID3D11DeviceContext::PSSetShader()</code> 设置像素着色器</li><li><code>D3D11SetDebugObjectName()</code> 将 Input Layout, Shader 和 Buffer 设置好调试用名字</li></ul></li></ul><h2 id="GameApp-Run"><a href="#GameApp-Run" class="headerlink" title="GameApp::Run()"></a><code>GameApp::Run()</code></h2><blockquote><p>关于 Windows 消息机制的相关介绍可以参考 <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues">About messages and message queues | MSDN</a>。</p></blockquote><p>运行首先依赖 Windows 窗口程序本身的主事件循环（<code>PeekMessage()</code> &#x3D;&gt; <code>TranslateMessage()</code> &#x3D;&gt; <code>DispatchMessage()</code>)。</p><p>主窗口的消息处理函数中，主要会处理：</p><ul><li><code>WM_SIZE</code>: 如果在 <code>WM_ENTERSIZEMOVE</code> 和 <code>WM_EXITSIZEMOVE</code> 中间，则忽略，否则调用 <code>OnResize()</code> 重新配置交换链并绑定到管线</li><li><code>WM_ACTIVATE</code>: 窗口不活跃时暂停渲染</li><li><code>WM_DESTROY</code>: 窗口退出消息</li></ul><p>如果没有待处理的窗口消息，则会进入：</p><ul><li><code>CalculateFrameStats()</code>: 根据定时器计算时长并更新窗口标题</li><li><code>UpdateScene()</code>: 更新场景 (主要是更新常量缓冲)<ul><li>计算更新后的常量缓冲区值</li><li><code>ID3D11DeviceContext::Map</code> 传入 Constant Buffer 对象<blockquote><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map">MSDN</a>: Gets a pointer to the data contained in a subresource, and denies the GPU access to that subresource.</p><p>这里要指定映射类型 (CPU 可读，CPU 可写，CPU 可写且原内容可放弃)；不过，这里还有一种类型，叫做 <code>D3D11_MAP_WRITE_NO_OVERWRITE</code>，这块 <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_map">MSDN 的文档</a>有比较详细的解释。</p><p>也可以看看<a href="https://zhuanlan.zhihu.com/p/341476240">这篇</a>知乎专栏作为参考。</p></blockquote><!-- TODO: 调查一下这个问题 --></li><li><code>memcpy(mappedData.pData, &amp;cpuCBuffer, sizeof(cpuConstBuffer))</code> 将数据拷贝到 <code>D3D11_MAPPED_SUBRESOURCE::pData</code> 成员处</li><li><code>ID3D11DeviceContext::Unmap</code> 解除内存映射</li></ul></li><li><code>DrawScene()</code>: 绘制场景<ul><li><code>ID3D11DeviceContext::ClearRenderTargetView()</code>: 用给定颜色清空渲染目标视图</li><li><code>ID3D11DeviceContext::ClearDepthStencilView()</code>: 用给定深度和模板值清空深度模板视图</li><li><code>ID3D11DeviceContext::DrawIndexed()</code>: 绘制给定的立方体</li><li><code>IDXGISwapChain::Present(SyncInterval=0, flags=0)</code>: 告知交换链已经完成绘制，可以呈现，并且要求立即呈现<blockquote><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">IDXGISwapChain::Present</a>: Presents a rendered image to the user.</p></blockquote></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇是笔者进行 RenderDoc drivers 层分析时一并记录下来的，是一个渲染 Cube 的简单 D3D11 程序与 API 交互的全流程的记录。&lt;/p&gt;
&lt;p&gt;以 &lt;a href=&quot;https://github.com/libreliu/DirectX11-Wit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | ICARUS: NeRF 硬件加速器</title>
    <link href="https://blog.libreliu.info/paper-reading/icarus-nerf/"/>
    <id>https://blog.libreliu.info/paper-reading/icarus-nerf/</id>
    <published>2022-10-06T16:00:00.000Z</published>
    <updated>2022-10-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章介绍了 NeRF 硬件加速的实现。</p><h2 id="NeRF-回顾"><a href="#NeRF-回顾" class="headerlink" title="NeRF 回顾"></a>NeRF 回顾</h2><img src="/paper-reading/icarus-nerf/nerf-overview.png" class="" title="NeRF Overview from Original Paper"><p>Neural Radiance Field，简称 NeRF，最开始在 ECCV 2020 上<a href="https://www.matthewtancik.com/nerf">被提出</a>，提出了以神经网络编码辐射场的一种技术，并且将其运用到了基于图片的场景重建等多个领域中，是近年来受关注度相当高的一篇工作。</p><p>NeRF 的网络部分输入为 5D: 位置 $ (x,y,z) $ 和朝向 $ (\theta, \phi) $，输出为该位置的 RGB 颜色和密度。</p><p>NeRF 在给定相机位置下最终渲染的输出用类似体渲染 (Volumetric Rendering) 的办法来实现。</p><h3 id="NeRF-体渲染"><a href="#NeRF-体渲染" class="headerlink" title="NeRF 体渲染"></a>NeRF 体渲染</h3><p>对给定的相机光线 $ {\bf r}(t) &#x3D; {\bf o} + t{\bf d} $ 来说，最终输出的颜色 $ {\bf C}(r) $ 以下式表示：</p>$$C({\bf r}) = \int_{t_n}^{t_f} T(t) \sigma({\bf r}(t)) {\bf c}({\bf r}(t), {\bf d}) dt $$<p>其中：</p><ul><li>$ T(t) = \exp (-\int_{t_n}^{t} \sigma({\bf r}(s)) ds ) $ 为光线从 $ t_n $ 能打到 $ t $ 的概率<ul><li>比如说，如果射线穿过的部分密度都比较大，那 $ T(t) $ 就会比较小</li></ul></li><li>$ \sigma({\bf r}(t)) $ 是该 $ t $ 对应的点 $ {\bf r}(t) $ 的密度</li><li>$ {\bf c}({\bf r}(t), {\bf d}) $ 是网络给定方向和位置后输出的 RGB 颜色值</li><li>$ t_n $ 和 $ t_f $ 分别为射线进入和射出 NeRF 有效区域的包围盒时所对应的最近和最远参数值</li></ul><p>不过这个积分显然不能很容易的解析求解，NeRF 的做法是采用数值积分的那一套。</p><p>首先，利用分层抽样 (stratified sampling) 的技术，将 $ [t_n, t_f] $ 分成 $ N $ 个均匀的小区间，然后在每个小区间均匀采样出一个 $ t_i $ 出来。</p><p>然后，用下面的量 $ \hat C({\bf r}) $ 来估计上面的 $ C({\bf r}) $：</p>$$\hat C({\bf r}) = \sum_{i=1}^{N} T_i (1-\exp(-\sigma_i \delta_i)) {\bf c}_i$$<p>其中：</p><ul><li>$ T_i = \exp(- \sum_{j=1}^{i-1} \sigma_j \delta_j) $</li><li>$ \delta_i = t_{i+1} - t_i $ 为两临近采样点的距离</li></ul><blockquote><p>为什么会变成这个形式？可以参考 arXiv 上的 <a href="https://arxiv.org/pdf/2209.02417.pdf">Volume Rendering Digest (for NeRF)</a></p></blockquote><!-- 没看，TODO: 研究一下 --><p>原文中提到，从所有的 $ ({\bf c}_i, \delta_i) $ 对考虑的话，$ \hat C(r) $ 的计算显然是可微的，并且可以看成从最开始一直用 $ \alpha_i &#x3D; 1 - \exp(\sigma_i \delta_i) $ 的透明度往上面做 alpha blending。</p><!-- TODO: why alpha value like that --><h3 id="NeRF-网络"><a href="#NeRF-网络" class="headerlink" title="NeRF 网络"></a>NeRF 网络</h3><p>网络部分用位置编码 (Positional Encoding) + Coarse MLP + Fine MLP。</p><h4 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h4><p>位置编码用来改善网络对高频细节的学习效果。</p><p>位置编码层可以如下描述：</p>$$\gamma(p) = (\sin(2^0 \pi p), \cos(2^0 \pi p), ..., \sin(2^{L-1} \pi p), \cos(2^{L-1} \pi p))$$<h4 id="Coarse-amp-Fine-MLP"><a href="#Coarse-amp-Fine-MLP" class="headerlink" title="Coarse &amp; Fine MLP"></a>Coarse &amp; Fine MLP</h4><p>NeRF 同时使用两个 MLP 来表示场景，一个粗粒度 MLP 和一个细粒度 MLP。</p><p>渲染的时候，首先用分层抽样的办法，在粗粒度网络中用前面提到的体渲染方法进行渲染，并且得到输出 $ \hat C_c(r) $：</p>$$\hat C_c(r) = \sum_{i=1}^{N_c} w_i c_i, \quad w_i = T_i (1-\exp(\sigma_i \delta_i))$$<p>然后，计算归一化权重 $ \hat w_i &#x3D; w_i &#x2F; \sum_{i&#x3D;1}^{N_c} w_i $，并且用计算好的归一化权重作为概率分布函数 (cumulative distribution function)，再在这条直线上采样 $ N_f $ 个位置，将这 $ N_c + N_f $ 个位置送入细粒度 MLP 进行推理，再用前面的办法渲染得到最终的颜色值。</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>采用简单的把 Coarse MLP 和 Fine MLP 与真实值之间的 $ L^2 $ 损失直接加起来的办法。</p><h2 id="ICARUS"><a href="#ICARUS" class="headerlink" title="ICARUS"></a>ICARUS</h2><img src="/paper-reading/icarus-nerf/icarus-overview.png" class="" title="ICARUS Overview"><h3 id="NeRF-计算过程回顾"><a href="#NeRF-计算过程回顾" class="headerlink" title="NeRF 计算过程回顾"></a>NeRF 计算过程回顾</h3><ol><li>对像素所发出射线上的采样，得到点 $ ({\bf p}_1, …, {\bf p}_N) $</li><li>查询 MLP 网络：$ ({\bf p}_i, {\bf d}_i) \to ({\bf c_i}, \sigma_i) $</li><li>进行多次 alpha-blending</li></ol><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>架构设计时主要有以下目标：</p><ol><li>“端到端” - 芯片输入位置和方向，输出像素颜色，减少片上片外数据交换的额外开销（计算时间、功耗）</li><li>使用定点数 - 有效降低浮点数运算开销</li><li>架构设计要一定灵活性，尽量兼容比较多的 NeRF 衍生网络</li></ol><h4 id="如何使用定点数？"><a href="#如何使用定点数？" class="headerlink" title="如何使用定点数？"></a>如何使用定点数？</h4><p>目前的实现是将在 GPU 上训练好的 NeRF 的权重进行量化 (quantization)，再导出。不过，目前也有一些工作在 quantization-aware training 方面，可能对这个网络的训练过程有所帮助。</p><h3 id="位置编码单元-PEU"><a href="#位置编码单元-PEU" class="headerlink" title="位置编码单元 (PEU)"></a>位置编码单元 (PEU)</h3><p>设计位置编码单元 (Positional Encoding Unit, PEU) 的目的是在 PEU 前和 PEU 后的向量维数增加了很多倍（对原 NeRF 来说位置是 20 倍，方向是 8 倍），如果在 ICARUS 内部进行计算的话，可以减少很大一部分外部存储传输，降低传输总用时。</p><p>PEU 部件主要在做这件事：</p>$$\phi(x; A) = [\cos A^T x, \sin A^T x]$$<p>其中 $ A $ 一般为一个行数比列数多的矩阵，用来升维。</p><p>PEU 单元对应的设计如下 (Fig. 4(b))：</p><img src="/paper-reading/icarus-nerf/peu-overview.png" class="" title="PEU Overview"><p>可以看到，就是矩阵乘法单元和 CORDIC 单元的组合。</p><blockquote><p>一些关于矩阵乘和 CORDIC 单元的大概印象：<br>矩阵乘：有很多工作，比如搜索 Systolic array 等等</p><ul><li>不过我不清楚 SOTA 情况<br>CORDIC: <a href="https://zipcpu.com/dsp/2017/08/30/cordic.html">https://zipcpu.com/dsp/2017/08/30/cordic.html</a></li><li>不过我也不清楚 SOTA 情况</li></ul></blockquote><p>具体设计上来说，ICARUS 支持对 dim&#x3D;3 和 dim&#x3D;6 的两种输入进行位置编码，并且扩展到 dim&#x3D;128。PEU 内部设计有两个 3x128 的内存块和 6 组 MAC (Multiply-ACcumulate) 单元，当计算 dim&#x3D;6 的输入时会全部启用，当计算 dim&#x3D;3 的输入时只启用一半。</p><h3 id="MLP-Engine"><a href="#MLP-Engine" class="headerlink" title="MLP Engine"></a>MLP Engine</h3><p>MLP 引擎主要进行 $ f(Wx+b) $ 类型的计算。</p><p>MLP 引擎包含有：</p><ul><li>一个 Multi-output Network block (MONB)，负责计算中间的隐藏层</li><li>一个 Single-output network block (SONB)，负责计算最后的输出层<ul><li>不继续用 MONB 的原因是，全连接的 MONB 比只输出一个数字的 SONB 面积要大得多</li></ul></li><li>两个 activation memory block</li></ul><p>对于 MLP 计算来说，实现是这样的：</p><img src="/paper-reading/icarus-nerf/mlp-compution-overview.png" class="" title="MLP Overview"><p>首先，将 MLP 的权重拆成 64 x 64 的小块，方便硬件上的复用，并且同样的权重可以被多组输入向量复用，从而降低内存带宽开销，代价方面只需要暂存该 batch 内的中间结果就可以（这里选择 <code>batch_size=128</code>）。</p><p>每个 64 x 64 的矩阵-向量乘法再进行分片，变成按矩阵列分割的 64 个列向量 - 向量的内积乘法（即 $ [\alpha_1 … \alpha_{64}] [x_1 … x_{64}]^T $，每个 $ \alpha_i x_i $ 的部分和用一个 RMCM 模块实现：</p><img src="/paper-reading/icarus-nerf/working_principle_rmcm.png" class="" title="RMCM Principle"><p>大概来说，是因为乘法可以变成移位加法：</p>$$3x = 1x << 1 + 1x$$<p>所以权重 load 进来的作用就是预先选择好路径上的移位和加法器，然后数据从这些器件中流过去就行。</p><p>另一个优化是高一半的移位和加法路径直接用上一次的值来替换，然后网络训练的时候也作此改动。这样可以节省 1&#x2F;3 的面积，同时输出基本没有视觉质量损失。</p><p>SONB 的架构基本上和 MONB 差不多，只是 RMCM 块用不到了，用普通的向量乘法块就可以了。</p><img src="/paper-reading/icarus-nerf/sonb-overview.png" class="" title="SONB Overview"><h3 id="Volume-Rendering-Unit"><a href="#Volume-Rendering-Unit" class="headerlink" title="Volume Rendering Unit"></a>Volume Rendering Unit</h3><img src="/paper-reading/icarus-nerf/VRU-Overview.png" class="" title="VRU Overview"><p>VRU 模块主要要负责下面的计算：</p><img src="/paper-reading/icarus-nerf/VRU-classic.png" class="" title="VRU Classic"><p>这里，他处理成下面的形式：</p><img src="/paper-reading/icarus-nerf/VRU-rewrite.png" class="" title="VRU Rewrite"><p>然后用上面的网络计算。</p><h3 id="原型验证"><a href="#原型验证" class="headerlink" title="原型验证"></a>原型验证</h3><img src="/paper-reading/icarus-nerf/FPGA-prototyping.png" class=""><p>验证平台使用的是 Synopsys HAPS-80 S104，验证时使用的工艺是 40nm CMOS 工艺。</p><img src="/paper-reading/icarus-nerf/icarus-comparation.png" class=""><!-- #### 调整到 Surface Light Field 任务> TODO-->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章介绍了 NeRF 硬件加速的实现。&lt;/p&gt;
&lt;h2 id=&quot;NeRF-回顾&quot;&gt;&lt;a href=&quot;#NeRF-回顾&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | 基于物理的特征线渲染</title>
    <link href="https://blog.libreliu.info/paper-reading/pbr-feature-line/"/>
    <id>https://blog.libreliu.info/paper-reading/pbr-feature-line/</id>
    <published>2022-08-27T16:00:00.000Z</published>
    <updated>2022-08-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章介绍了基于物理的特征线渲染方法。</p><p>特征线渲染是一种非真实感渲染技术，常常被用在剪影、产品效果图等一些需要特殊的艺术效果的场合。</p><p>本篇文章提出的，基于路径方法的特征线渲染方法，是基于如下的两方面观察：</p><ol><li>从路径的角度出发，现有的特征线渲染方法将特征线处理成了光源</li><li>特征线相交测试可以对任意的边开展，而不仅仅是在屏幕空间中</li></ol><p>基于上面的观察，本文提出的方法</p><ol><li>对一整个路径中每条路径段分别进行和特征线的相交测试</li><li>将交到的特征线视为吸收所有入射光，然后辐射用户自定义颜色的光源</li></ol><blockquote><p>TL;DR: 用 Path Tracing 做描边，把要描的边处理成光源，让描边也有景深、色散和反射等效果。</p></blockquote><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法的基本架构很简单。</p><p>从传统的 Path Tracer 出发：</p><ol><li>对每个 path segment 依次进行和特征线的相交判断，并且</li><li>如果相交，则将特征线视为理想光源，并不再追下面的光源</li></ol><h3 id="相交判断"><a href="#相交判断" class="headerlink" title="相交判断"></a>相交判断</h3><p>从该 path segment 出发，以固定扩张率和当前路径总长度做一锥体，寻找锥体中的特征线。</p><p>实现上，本文采用从锥体较窄的一端发射查询射线，并且判断交点是否为特征线上的点的方法来进行判断，可能和 cone tracing 比较相似。</p><img src="/paper-reading/pbr-feature-line/cone-intersection-test.png" class="" title="cone-intersection-test"><h3 id="采样权重修改"><a href="#采样权重修改" class="headerlink" title="采样权重修改"></a>采样权重修改</h3><p>前面提到，“如果相交，则将特征线视为理想光源，并不再追下面的光源”。本文中会将这种情况整条采样路径每个点的 pdf 值处理成和打到刚好有光源位于这里的情况完全一致。</p><p>不过，这样会让整个估计变成有偏估计，因为还存在有特征线（i.e. 有光源）但是没有采样到的情况，这种情况使用正常 pdf 会让最后相机处接收的 Irradiance 期望偏小，也就是特征线会比无偏的情况更不明显。</p><p>比较幸运的是，通过加密相交判断中发射的查询射线的数量，可以渐进的趋于无偏的情况。</p><img src="/paper-reading/pbr-feature-line/progressively-unbias.png" class="" title="progressively-unbias"><h3 id="特征线判据"><a href="#特征线判据" class="headerlink" title="特征线判据"></a>特征线判据</h3><p>特征线的判断通过锥体中采样到的点和本 path segment 的起点和终点联合进行判断，主要有 MeshID, Albedo, Normal 和 Depth 四个方面的判据。</p><img src="/paper-reading/pbr-feature-line/feature-line-condition.png" class="" title="feature-line-condition"><blockquote><p>其中 $ t_{\text{depth}} $ 文中提到有一个较为启发的设置方法。</p></blockquote><p>各项的效果如图所示：</p><img src="/paper-reading/pbr-feature-line/feature-line-condition-breakdown.png" class="" title="feature-line-condition-breakdown"><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>可以参考本文 Teaser：</p><img src="/paper-reading/pbr-feature-line/teaser.png" class="" title="teaser"><p>可以看到，本文渲染的特征线有色散、景深模糊、反射等基于物理的效果。</p><h2 id="未来的工作"><a href="#未来的工作" class="headerlink" title="未来的工作"></a>未来的工作</h2><p>文章最后主要提及了如下的 Future Work：</p><ul><li>其它路径采样方法 (i.e. BDPT)</li><li>特征线锥形区域估计改进</li><li>特征线区域缓存</li><li>特征线模型改进<ul><li>反射 &#x2F; 半透特征线模型等</li></ul></li><li>将 lens blur 和色散效果集成到 <a href="https://pixl.cs.princeton.edu/pubs/Cole_2006_DGI/index.php">Stylized Focus</a><ul><li>Stylized Focus 主要通过多个光栅化 pass 的叠加来实现风格化的景深和聚焦效果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章介绍了基于物理的特征线渲染方法。&lt;/p&gt;
&lt;p&gt;特征线渲染是一种非真实感渲染技术，常常被用在剪影、产品效果图等一些需要特殊的艺术效果</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>让 Hexo 支持内联 LaTeX 数学公式的 Markdown</title>
    <link href="https://blog.libreliu.info/towards-math-markdown/"/>
    <id>https://blog.libreliu.info/towards-math-markdown/</id>
    <published>2022-08-25T16:00:00.000Z</published>
    <updated>2022-08-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过一周多陆陆续续的折腾，到<a href="https://github.com/libreliu/libreliu.github.io/commit/627caa945440bed93a3fe69a90a932a84f7dceb0">现在</a>本博客基本实现了博客 Markdown 渲染和 Typora, VSCode 等的默认预览中数学公式的表现一致。</p><blockquote><p>Note: 大于号（<code>&gt;</code>）小于号（<code>&lt;</code>）目前没有做额外的转义（它们本身是 HTML 标签的结束和开始），但是这个用 <code>\lt</code> 和 <code>\gt</code> 就行了，所以有点懒得改。</p><p>如果要改的话，就对 <code>math</code> 的处理加上这两个东西的 escape 就好，MathJaX 本身会识别出 <code>&amp;lt;</code> 和 <code>&amp;gt;</code> 的。</p></blockquote><p>简单来说，我分别魔改了 <a href="https://github.com/libreliu/marked">marked</a> 和 <a href="https://github.com/libreliu/hexo-renderer-marked-math">hexo-renderer-marked</a> 两个包，实现了内联 LaTeX 的正确 Tokenize 和 Renderer (i.e. 什么也不做，原样输出)，再由浏览器里运行的 <a href="https://github.com/libreliu/libreliu.github.io/commit/9523cf2ec2de2888fee50f2e9925313f96da5a35">MathJaX 3</a> 来进行 LaTeX 渲染。</p><p>魔改后的版本支持块公式 (block math) <code>$$ ... $$</code> 和内联公式 (inline math) <code>$ ... $</code>，并且内联公式内部的 <code>_</code> 不会和 Markdown 对 <code>_</code> 的使用冲突。</p><p>下面是渲染 Maxwell 方程组的示例：</p>$$\begin{aligned}\nabla \cdot \mathbf{E} &= \frac {\rho} {\varepsilon_0} \\\nabla \cdot \mathbf{B} &= 0 \\\nabla \times \mathbf{E} &= -\frac{\partial \mathbf{B}} {\partial t} \\\nabla \times \mathbf{B} &= \mu_0\left(\mathbf{J} + \varepsilon_0 \frac{\partial \mathbf{E}} {\partial t} \right) \end{aligned}$$<p>上面的 $ \mathbf{E} $ 是电场强度，$ \mathbf{B} $ 是磁感应强度，$ \mu_0$ 是真空磁导率，$ \epsilon_0 $ 是真空介电系数。</p><blockquote><p><code>marked</code> 是 <code>hexo-renderer-marked</code> 使用的 Markdown 渲染器，它负责把 Markdown 渲染成 HTML。</p></blockquote><h2 id="为什么要新造一个轮子？"><a href="#为什么要新造一个轮子？" class="headerlink" title="为什么要新造一个轮子？"></a>为什么要新造一个轮子？</h2><p>Google 一圈，现在有的 Hexo 内联 LaTeX 的方案都不是很让人满意：</p><ol><li><code>hexo-renderer-kramed</code> 使用的 <code>kramed</code> 从 2016 年开始已经没有再更新了</li><li><code>marked</code> 表示不会加入对 <code>$ ... $</code> 和 <code>$$ ... $$</code> 的支持 (<a href="https://github.com/markedjs/marked/issues/722">markedjs&#x2F;marked, Issue #722</a>)</li><li><code>hexo-renderer-pandoc</code> 需要用户自己安装 <code>pandoc</code>，<code>pandoc</code> 本身很庞大，并且是 Haskell 编写，本文作者表示改不动；另外，直接 out-of-box 的装上之后，块公式 <code>pandoc</code> 总是会多生成 <code>\[ ... \]</code> 的 pair，决定弃坑</li><li>网络上还存在一些 patch 方案，比如<a href="https://alexsixdegrees.github.io/2017/03/11/letaxinmarkdown/">这里</a>，直接把 <code>marked</code> 的 inline rule 改掉，让其不再将 <code>_</code> 作为合法的强调标志（比如 <code>_asdf_</code> 之类就不会渲染成 <em>asdf</em> 了）</li><li>其实也可以 <em>摆大烂</em>，把所有 LaTeX 和 Markdown 冲突的关键字都用反斜杠转义掉</li></ol><p>可以看到都不是太优雅。</p><h2 id="改动简介"><a href="#改动简介" class="headerlink" title="改动简介"></a>改动简介</h2><blockquote><p>其实一开始想给 <code>hexo-renderer-marked</code> 写插件，但是它只支持 extend <code>Tokenizer</code> 和 <code>Renderer</code>，把那些乱七八糟规则再写一遍又很难维护，所以最后放弃了这个想法。</p></blockquote><p>主要是对 <code>marked</code> 进行改动，让其支持 <code>$$ .. $$</code> 和 <code>$ .. $</code> 的 Tokenize，并且能无转义的输出。</p><p><code>marked</code> 采用正则表达式不断匹配的方式进行词法分析，对于部分块对象会继续进行行内的词法分析。词法分析后的 Toekn 流会送到 Renderer 进行输出。</p><p>详细可以看 <a href="https://github.com/libreliu/marked">libreliu&#x2F;marked</a> 上面的提交。</p><p>由于人比较懒，没有在 npm 上加自己的包，而是直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install github:libreliu/hexo-renderer-marked-math#master --save</span><br></pre></td></tr></table></figure><p>这个的缺点是每次 <code>npm update hexo-renderer-marked-math</code> 都要重新拉，并且版本管理上不是很友好。不过只是自己用的话其实无所谓。</p><h2 id="（作为菜鸡）踩过的坑"><a href="#（作为菜鸡）踩过的坑" class="headerlink" title="（作为菜鸡）踩过的坑"></a>（作为菜鸡）踩过的坑</h2><ol><li><p>NodeJS 的 <code>require</code> 在找不到 <code>index.js</code> 时，会去 <code>package.json</code> 中查找 <code>main</code> 字段，并且加载对应的模块。</p><p>可以注意到，<code>marked</code> 的 <code>main</code> 是 <code>./lib/marked.cjs</code>，这个文件需要运行 <code>npm run build</code> 生成。</p></li><li><p>调试 Promise 链可以采用 Bluebird 的<a href="http://bluebirdjs.com/docs/api/promise.longstacktraces.html">Promise.longStackTraces()</a>。</p></li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><a href="https://gist.github.com/3846masa/cde99a18a8d7ad225cf7">这里</a>在 2015 年对 VSCode 的 Markdown 渲染的 patch 对本更改有参考意义。</p><p><a href="https://github.com/zq1997/math-marked">math-marked</a>这个项目在我基本写完之后才看到，不过作者没有基于原来的 commit 继续改，后续升版本会比较费劲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过一周多陆陆续续的折腾，到&lt;a href=&quot;https://github.com/libreliu/libreliu.github.io/commit/627caa945440bed93a3fe69a90a932a84f7dceb0&quot;&gt;现在&lt;/a&gt;本博客基本实现了博客 M</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Slang</title>
    <link href="https://blog.libreliu.info/paper-reading/slang-shader-framework/"/>
    <id>https://blog.libreliu.info/paper-reading/slang-shader-framework/</id>
    <published>2022-07-30T16:00:00.000Z</published>
    <updated>2022-07-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证<strong>没有额外性能损失</strong>的情况下，解决现代游戏引擎和实时渲染应用中出现的，不同光源 &#x2F; 材质组合出现的 Shader 代码膨胀、晦涩难懂的基于宏的复用等问题。</p><p>Slang 针对原 HLSL，主要增加了以下的新特性：</p><ol><li>带可选成员类型约束的接口系统 (Interfaces)<ul><li>以及 <code>extension</code> 关键字来覆盖接口系统的默认行为，提供最大灵活性</li></ul></li><li>泛型系统 (Generics)</li><li>显式参数块 (Explicit Parameter Blocks)</li><li>Slang 编译器和提供运行时类型特化支持的编译器运行时 API</li><li>(论文发表后新增) 语法糖和其它易用性改进<ul><li>类 C# 的 getter&#x2F;setter 语法糖</li><li>运算符重载</li><li>模块系统</li></ul></li><li>(论文发表后新增) CUDA, OptiX 等非传统 Shader 编译目标</li></ol><p>从上面可以看出，Slang 自论文发布后还存在有功能演进，说明作为 Shader 语言本身还是有一定生命力的。</p><p>截至 2022 年 7 月 31 日，<a href="https://github.com/shader-slang/slang">Slang 的 GitHub 仓库</a> 共有 978 个 Star，235 Open Issue 和 284 Closed Issue，最后一次提交在两天前，证明项目还是比较活跃的。</p><blockquote><p>Note: 据我浅薄的了解，HLSL 也在不断迭代新的功能，如 <a href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">HLSL 2021</a> 的 <code>template</code> 泛型支持等。<del>不过 GLSL 好像没啥大动作</del>(?)</p></blockquote><h2 id="Slang-语言特性介绍"><a href="#Slang-语言特性介绍" class="headerlink" title="Slang 语言特性介绍"></a>Slang 语言特性介绍</h2><h3 id="接口系统-Interfaces"><a href="#接口系统-Interfaces" class="headerlink" title="接口系统 (Interfaces)"></a>接口系统 (Interfaces)</h3><p>Slang 的接口表示一种约定，比如约定里面会有某种特定函数原型的函数实现，某种特定的成员结构体等，与 “traits” 的语言概念比较接近。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare that MyType have conformance to interface IFoo</span></span><br><span class="line"><span class="keyword">struct</span> MyType : IFoo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)arg + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型系统-Generics"><a href="#泛型系统-Generics" class="headerlink" title="泛型系统 (Generics)"></a>泛型系统 (Generics)</h3><p>泛型系统可以实现同时支持不同类型实例的函数。特别的，可以约束传入的形参类型为实现某种接口的类型，如下面的 <code>myGenericMethod</code> 约束 <code>T</code> 为实现 <code>IFoo</code> 接口的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define</span></span><br><span class="line"><span class="type">int</span> myGenericMethod&lt;T: IFoo&gt;(T arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.myMethod(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke</span></span><br><span class="line">MyType obj;</span><br><span class="line"><span class="type">int</span> a = myGenericMethod&lt;MyType&gt;(obj); <span class="comment">// OK, explicit type argument</span></span><br><span class="line"><span class="type">int</span> b = myGenericMethod(obj); <span class="comment">// OK, automatic type deduction</span></span><br></pre></td></tr></table></figure><p>同时，Slang 还支持类似 C++ 的非类型模板形参的泛型参数输入，比如下面的 <code>N</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Array&lt;T, <span class="keyword">let</span> N : <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T arrayContent[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数，<code>struct</code> 等语言组件都支持泛型。</p><blockquote><p>Note: HLSL 本身就支持作为 struct 的 arg 拥有成员函数。</p></blockquote><h3 id="显式参数块-Explicit-Parameter-Blocks"><a href="#显式参数块-Explicit-Parameter-Blocks" class="headerlink" title="显式参数块 (Explicit Parameter Blocks)"></a>显式参数块 (Explicit Parameter Blocks)</h3><blockquote><p>这个特性在 Slang 官方的语言文档中没有着重强调，主要是在 Slang 的这篇论文中强调了。</p></blockquote><p>现代图形 API（D3D12, Vulkan）对于 Shader 的输入参数是以 “parameter block” 的形式来组织的（例：Vulkan 中术语为 Descriptor Set），一个 Shader 的输入可以由多个 Descriptor Set 组成。</p><p>考虑到场景的绘制过程中，有一部分 Shader 参数是不变的（比如同一个绘制到主 RenderTarget 的 Pass 中摄像机的位置），那么把这些不变的参数单独拿出来组织成一个 Parameter Block，把剩下的一些变化频率不太一致的另一些参数（比如模型的 <code>modelMatrix</code>）拿出来作为一个或多个 Parameter Block 的话，就可以降低一部分绘制时的开销。</p><p>但是手工组织 Shader 的 layout（特别是对于不同的材质，我们有不同的 Shader 要用）是比较繁琐的，Slang 则对这个 Parameter Binding 和 Parameter Block 有专门的设计（<code>Shader Parameters</code>），可以方便的自动推导符合程序员设计要求的 layout 和 block。</p><h3 id="编译器和运行时-API"><a href="#编译器和运行时-API" class="headerlink" title="编译器和运行时 API"></a>编译器和运行时 API</h3><p>Slang 提供了功能丰富的运行时 API，其功能经过一些演进和论文中描述的也不是特别一致了。</p><p>Slang 的运行时 API 大概提供了如下机制：</p><ol><li>运行时 Shader 编译和特化 API<ul><li>比如，运行时要对新的材质类型重新编译 Shader，就可以使用这些 API</li></ul></li><li>反射机制<ul><li>可以获得某段 Slang Shader 中的函数、Shader 入口参数等信息</li></ul></li></ol><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>Slang 的文档中描述了不少 Slang 的语法糖和易用性改进。</p><h4 id="类似-C-的-getter-x2F-setter-语法糖"><a href="#类似-C-的-getter-x2F-setter-语法糖" class="headerlink" title="类似 C# 的 getter &#x2F; setter 语法糖"></a>类似 C# 的 getter &#x2F; setter 语法糖</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">uint</span> flag;</span><br><span class="line"></span><br><span class="line">    property <span class="built_in">uint</span> highBits</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> flag &gt;&gt; <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; flag = (flag &amp; <span class="number">0xFF</span>) + (newValue &lt;&lt; <span class="number">16</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基于全局函数的运算符重载"><a href="#基于全局函数的运算符重载" class="headerlink" title="基于全局函数的运算符重载"></a>基于<strong>全局函数</strong>的运算符重载</h4><blockquote><p>HLSL 2021 支持了基于<strong>成员函数</strong>的运算符重载：[Announcing HLSL 2021</p><ul><li>DirectX Developer Blog](<a href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">https://devblogs.microsoft.com/directx/announcing-hlsl-2021/</a>)</li></ul><p>而 GLSL 截至 2022 年 7 月 31 日还在咕咕：<a href="https://github.com/KhronosGroup/GLSL/issues/107">Operator overloading · Issue #107 · KhronosGroup&#x2F;GLSL</a></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    __init(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyType <span class="keyword">operator</span>+(MyType a, MyType b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MyType(a.val + b.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyType rs = MyType(<span class="number">1</span>) + MyType(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rs.val; <span class="comment">// returns 3.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h4><p>Slang 支持一个简单的模块机制，可以把要 import 的目标模块（就是一个 .slang 的 Slang Shader）中的定义导入当前单元。如果该模块此时再被其它模块 import 的话，这些被导入的模块是不会导入到它的“上一层”的单元中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyShader.slang</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的导入</span></span><br><span class="line"><span class="keyword">import</span> YourLibrary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以导入时覆盖前面描述的行为</span></span><br><span class="line">__export <span class="keyword">import</span> SomeOtherModule;</span><br></pre></td></tr></table></figure><h2 id="重构-Falcor-渲染器"><a href="#重构-Falcor-渲染器" class="headerlink" title="重构 Falcor 渲染器"></a>重构 Falcor 渲染器</h2><p>Falcor 是一个基于 D3D12 的实时渲染器。</p><blockquote><p>根据 README，Vulkan 实验性支持在进行中。</p></blockquote><p>作者从 Falcor 的 2.0.2 版本出发，重构了 5400 行着色器代码。</p><p>改进主要集中在如下方面：</p><ol><li><p>将一个大的 Parameter Block 拆分成 per-material 的 block</p></li><li><p>Falcor 原来的 Material 采用层次化的设计，每一层 (e.g. GGX, Lambertian, Phong) 都和下一层进行 blend，而渲染时，根据不同的 material 要 dispatch 不同的 shader 时，采用了很多 <code>#define</code> 和基于文本的 Shader Varient Cache 的查询环节。</p><p>作者重构时将这套系统用 Slang 的泛型系统重构，并且将标准材质的 Varient 用非类型形参编码成了若干个 int，进而加快了查询速度。</p></li><li><p>针对与 Material 类似的技术，实现了光源上的特化，在场景中只有某种类型光源的时候采用静态特化好的 Shader 变体，减少运行时判断的开销</p></li></ol><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>通过重构 Falcor 渲染器，在 NVIDIA 的 ORCA 场景上的测试表明</p><ul><li>每帧 CPU 执行时间降低了 30%</li><li>光源和材料特化改进对部分场景的 GPU 时间有加速作用</li></ul><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>作者分别在重构前和重构后的 Falcor 上实现了（基于 LTC 方法的）多边形面光源，</p><ul><li>重构前：需要改动 7 处，4 个文件，246 行</li><li>重构前，但加入光源分离机制：需要改动 8 处，5 个文件，253 行</li><li>重构后：只需要改动 1 处，1 个文件，249 行</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p>We believe that all real-time graphics programmers could benefit from<br>a new generation of shader compilation tools informed by these<br>ideas. —— <em>Slang: language mechanisms for extensible real-time shading systems</em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证&lt;strong&gt;没有额外性能损失&lt;/strong&gt;的情况下，解决现代游戏引擎和实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields</title>
    <link href="https://blog.libreliu.info/paper-reading/ddgi/"/>
    <id>https://blog.libreliu.info/paper-reading/ddgi/</id>
    <published>2022-07-22T16:00:00.000Z</published>
    <updated>2022-07-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章提供了一种高效的计算动态物体和动态光源情形下的全局光照的方法。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="DDGI-light-probe"><a href="#DDGI-light-probe" class="headerlink" title="DDGI light probe"></a>DDGI light probe</h3><p>DDGI 是一种利用 light probe（光照探针）进行动态全局光计算的方法。</p><p>对于位于 $\mathrm{x’}$ 位置的 light probe，所有的出射方向可以视为从 probe 所在位置到以 probe 所在位置为中心的单位球面上点构成的向量的集合。此时，构造一个 $S^2 \to R^2$ 的映射，使得球面的八个扇区分别映射到八面体的八个面上，这个映射被称为八面体映射 (octahedron mapping)。</p><blockquote><p>文章中描述到，八面体映射的好处，在于可以将球面以比较均匀的参数化映射到正方形上去，方便之后将每个方向相对应的量储存到 2D 纹理上面去。</p></blockquote><p>通过八面体映射，就可以将 probe 每个方向的信息存储在正方形的纹理贴图上了。</p><p>不过，在这篇文章中，出于性能考虑，作者采用了类似 Variance Shadow Mapping 的方法，极大压缩了纹理贴图的分辨率，同时对于每个 probe 的贴图的每个方向，分别存放</p><ol><li>$E_i(\mathrm{x'}, w)$: probe 以 $\omega$ 方向为天顶的半球的入射 irradiance</li><li>$r(\omega)$: probe 在 $\omega$ 方向对应的最近邻图元的距离在半球面的均值<ul><li>也就是 $\int d(x’, \omega) d \omega$，其中 $d(x, \omega): R^3 \times \Omega \to R$ 为在 $x$ 处沿 $\omega$ 方向到最近邻图元的距离</li></ul></li><li>$r^2(\omega)$: probe 在 $\omega$ 方向对应的最近邻图元的距离的平方在半球面的均值</li></ol><p>三组信息。</p><blockquote><p>Recall: radiance 和 irradiance</p><ul><li>Radiance (辐射率): 单位面积单位立体角辐射功率，$ d\Phi &#x2F; (dS d\Omega) $</li><li>Irradiance (辐照度): 单位面积辐射功率 $ d\Phi &#x2F; dS $</li></ul></blockquote><h3 id="利用-probe-进行间接光计算"><a href="#利用-probe-进行间接光计算" class="headerlink" title="利用 probe 进行间接光计算"></a>利用 probe 进行间接光计算</h3><p>前面提到 probe 中存储的信息为 probe 所在位置中各个方向的入射 irradiance。如果把场景中各处的 irradiance 看成一个 irradiance 场，那么现在要处理的问题就是给定场在某些位置的值，插值出其他位置的值的过程。</p><p>对于漫反射，只需要关心入射 irradiance 而不需要具体的 radiance，所以只需要待着色图元的全局光入射 irradiance 信息。</p><p>irradiance 场大概可以这样描述：$R^3 \times S^2 \to Spectrum$</p><p>输入是 (位置, 方向)，输出是 Spectrum (e.g. RGBSpectrum)</p><p>可以想象到，如果场本身的变化相对于 probe 间距离来说变化比较缓慢，那么方法就会工作的比较好。</p><p>不过，也有一些会导致变化较快的情况：</p><ol><li>图元本身与 probe 所成夹角</li><li>图元被某些物体遮挡</li></ol><p>所以，DDGI 提出了这样的框架来进行着色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float3 n = shading normal, X = shading point, P = probe location</span></span><br><span class="line">float4 irradiance = float4(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (each of <span class="number">8</span> probes around X) &#123;</span><br><span class="line">    float3 dir = P – X;</span><br><span class="line">    <span class="type">float</span> r = <span class="built_in">length</span>(dir);</span><br><span class="line">    dir *= <span class="number">1.0</span> / r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// smooth backface</span></span><br><span class="line">    <span class="type">float</span> weight = (<span class="built_in">dot</span>(dir, n) + <span class="number">1</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjacency</span></span><br><span class="line">    weight *= trilinear(P, X);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// visibility (Chebyshev)</span></span><br><span class="line">    float2 temp = <span class="built_in">texelFetch</span>(depthTex, probeCoord).rg;</span><br><span class="line">    <span class="type">float</span> mean = temp.r, mean2 = temp.g;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mean) &#123;</span><br><span class="line">        <span class="type">float</span> variance = <span class="built_in">abs</span>(square(mean) – mean2);</span><br><span class="line">        weight *= variance / (variance + square(r – mean));</span><br><span class="line">    &#125;</span><br><span class="line">    irradiance += <span class="built_in">sqrt</span>(<span class="built_in">texelFetch</span>(colorTex, probeCoord) * weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> square(irradiance.rgb * (<span class="number">1.0</span> / irradiance.a));</span><br></pre></td></tr></table></figure><blockquote><p><code>irradiance.a</code> 的作用是什么..？</p><p>很多权重我理解是为了视觉效果，应该和物理正确没什么太大关系…</p><p>这里的也不是最终的版本（还要加上 normal bias），slides 里面提供了更加魔改的版本，不知道 RTXGI 里面是不是有更进一步的魔改</p></blockquote><h4 id="Chebyshev-项分析"><a href="#Chebyshev-项分析" class="headerlink" title="Chebyshev 项分析"></a>Chebyshev 项分析</h4><p>Chebyshev 不等式 (one-tailed version)：</p>$$P(x > t) \le \frac{\sigma^2}{\sigma^2 + (t-\mu)^2}$$<blockquote><p>可以参考 GAMES202 中<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_04.pdf">关于 Variance Soft Shadow Mapping 的部分</a></p></blockquote><p>相当于小于平均值时认为没有遮挡，大于平均值时按 Chebyshev 不等式的上界来估算被遮挡概率。</p><blockquote><p>有没有更好的估计方法？为什么这样估计是最好的？</p></blockquote><h3 id="各个项效果对比"><a href="#各个项效果对比" class="headerlink" title="各个项效果对比"></a>各个项效果对比</h3><p>原论文中有各项的作用展示：</p><img src="/paper-reading/ddgi/ddgi_term_comparation.png" class="" title="DDGI Term Comparation"><p>其中 classic irradiance probe 应该就是只有三线性插值的结果。</p><h3 id="动态更新-probe-信息"><a href="#动态更新-probe-信息" class="headerlink" title="动态更新 probe 信息"></a>动态更新 probe 信息</h3><p>每一帧，DDGI 会进行如下的操作：</p><ol><li>从 $m$ 个活跃 probe 中，每个 probe 发射 $n$ 条光线，然后存储 $n \times m$ 个交点处的表面元信息（位置，法线）到一个类似 G-buffer 的结构中<ul><li>发射光线时采用每帧不同的 pattern，最大限度避免锯齿<ul><li>作者采用 “stochastically-rotated Fibonacci spiral pattern”<blockquote><p>不过作者 2017 年的文章中并没有详细说明此处的具体实现，需要阅读作者的代码</p></blockquote></li></ul></li></ul></li><li>对表面元信息进行直接光和间接光计算<ul><li>直接光：<ul><li>点光源和方向光光源：利用该 G-buffer 进行普通的 deferred rendering + variance shadow mapping</li><li>面积光光源：使用下面间接光方法，第一跳时考虑面积光</li></ul></li><li>间接光：采用周围的 probe 信息进行计算<ul><li>和前面一节描述的方法一致</li></ul></li><li>(多跳)间接光：通过 3 中每次用 Moving Average 方法来更新，实现多跳的信息传播</li></ul></li><li>更新这 $m$ 个活跃 probe 对应的纹理贴图<ul><li>利用 alpha-blending, $\alpha$ 取 0.85 到 0.98</li><li><code>newIrradiance[texelDir] = lerp(oldIrradiance[texelDir], Sum(ProbeRays(max(0,texelDir · rayDir) ∗ rayRadiance)...), alpha)</code></li></ul></li></ol><blockquote><p>符号说明: <code>lerp(a, b, alpha) = a * alpha + b * (1-alpha)</code></p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><a href="https://research.nvidia.com/sites/default/files/pubs/2017-02_Real-Time-Global-Illumination/light-field-probes-final.pdf">Real-Time Global Illumination using Precomputed Light Field Probes</a><ul><li>McGuire 这篇 2017 年的工作中关于 GI 的部分和这篇文章很像，只是当时他在 light probe 中存储比较高分辨率的最近邻图元到 probe 距离，并且用这个距离来进行基于 probe 阵列的 ray trace，而不是采用硬件 ray trace。</li><li>并且他在这篇工作中提到，可以采用将 BSDF 分解成 diffuse + glossy (所有不 diffuse 的项)，对 glossy 用其它方法来处理 (比如 raytrace + post filter) 来实现整个场景的 GI。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章提供了一种高效的计算动态物体和动态光源情形下的全局光照的方法。&lt;/p&gt;
&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试嵌套 ul 和 li</title>
    <link href="https://blog.libreliu.info/test-ul-nested/"/>
    <id>https://blog.libreliu.info/test-ul-nested/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-07-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一些正常的测试文本。</p><ul><li>first class ul<ul><li>second class ul<ul><li>third class ul</li></ul></li></ul></li></ul><ol><li>测试 first class li<br>测试缩进后文字显示<ul><li>测试 inner class ul<ul><li>测试更内部显示</li></ul></li></ul></li><li>测试 first class li<br>测试缩进后文字显示<ul><li>测试 inner class ul<ul><li>测试更内部显示</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一些正常的测试文本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;first class ul&lt;ul&gt;
&lt;li&gt;second class ul&lt;ul&gt;
&lt;li&gt;third class ul&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;测试 fi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Generalized RIS</title>
    <link href="https://blog.libreliu.info/paper-reading/gris/"/>
    <id>https://blog.libreliu.info/paper-reading/gris/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要是扩展了 ReSTIR 和 ReSTIR GI 中用到的 Resampled Importance Sampling 在图形学中的理论基础。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要是扩展了 ReSTIR 和 ReSTIR GI 中用到的 Resampled Importance Sampling 在图形学中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | EARS</title>
    <link href="https://blog.libreliu.info/paper-reading/ears/"/>
    <id>https://blog.libreliu.info/paper-reading/ears/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了一种在离线渲染中优化 Path Tracing 中 Russian Roulette 和 Splitting 的方法。</p><p>首先，Splitting 即在 Path Tracing 的过程中，到某个 bounce 后，分叉出多条光线进行 trace，最后计算该点光照贡献时按权重进行平均的一种技术。</p><p>作为例子，考虑如下的场景（图源论文）：</p><img src="/paper-reading/ears/pool-scene.png" class="" title="pool-scene"><p>该场景中，池底的表面为漫反射材质，但是路径中其它的部分的 BSDF &#x2F; BRDF 都比较趋向于 Delta 分布。这时，如果可以在绿色点进行 Splitting，对不需要 Splitting 的路径实现复用，就可以帮助以更小的开销实现较低方差的渲染。</p><p>在每次 bounce 时，PathTracer 都需要进行一个决策：</p><ul><li>(Russian Roulette) 是否需要截止这条光线？以多少概率截止？</li><li>(Splitting) 是否需要将这条光线分裂成多份？如果需要的话，分裂成多少份？</li></ul><p>这些因子显然是和场景相关的，而选择好这些因子可以加速 Path Tracing 的收敛过程。</p><h2 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h2><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了一种在离线渲染中优化 Path Tracing 中 Russian Roulette 和 Splitting 的方法。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | Neural Radiance Caching</title>
    <link href="https://blog.libreliu.info/paper-reading/nrc/"/>
    <id>https://blog.libreliu.info/paper-reading/nrc/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了用于实时渲染的神经辐射度缓存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了用于实时渲染的神经辐射度缓存。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | ReSTIR GI</title>
    <link href="https://blog.libreliu.info/paper-reading/restir-gi/"/>
    <id>https://blog.libreliu.info/paper-reading/restir-gi/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要将 ReSTIR 这种采样增强方法扩展到了间接光照上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要将 ReSTIR 这种采样增强方法扩展到了间接光照上。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 | ReSTIR</title>
    <link href="https://blog.libreliu.info/paper-reading/restir/"/>
    <id>https://blog.libreliu.info/paper-reading/restir/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章主要介绍了 ReSTIR 这种用于实时渲染的采样增强方法，该方法可以处理交互式渲染中对大量光源 (&gt;&#x3D; 1k) 的直接光进行采样的问题，也可以用于实时渲染。</p><blockquote><p>注：本篇文章的官方 Slides 我感觉做的很不错，可以在他们的项目主页下载到。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="BSDF-适用的渲染方程"><a href="#BSDF-适用的渲染方程" class="headerlink" title="BSDF 适用的渲染方程"></a>BSDF 适用的渲染方程</h3>$$\begin{aligned}L_o(x, \omega_o) &= \int_\Omega f(x, \omega_i, \omega_o) L_i(x, \omega_i) \cos \theta^x_i d \omega_i \\&= \int_\mathcal{A_i} f(x, \omega_i, \omega_o) L_o(x', \omega_i) \frac{\cos \theta^x_i \cos \theta^{x'}_{o} }{| x - x' |^2} dA \qquad \text{(with light from } x' \text{)} \\&= \int_\mathcal{A_i} f(x, \omega_i, \omega_o) V(x, x') L_o(x', \omega_i) \frac{\cos \theta^x_i \cos \theta^{x'}_{o} }{| x - x' |^2} dA \\\end{aligned}$$<p>其中 $\theta^x_i$ 为 $x$ 处入射光线与 $x$ 所在表面位置法线所成角度，$\theta^{x’}_o$ 为 $x’$ 处出射光线与 $x’$ 所在表面位置法线所成角度。</p>$$V(x, x') := \left\{\begin{aligned}&1 ,& x' \text{ is visible from } x \\&0 ,& \text{otherwise}\end{aligned}\right.$$<!-- 之后可以扩展一节专门讲渲染方程，放到基础回顾部分；现在就略写一下 --><p>对于上面的积分，我们希望用一些离散的采样构成的一个估计量来进行原积分的估计。采样方式和利用采样得到的值进行运算从而构造估计量的方式被称为一种估计方法。</p><p>数理统计告诉我们，估计量也是满足一个分布的，在绝大多数时候我们通过估计量的<strong>期望</strong>和<strong>方差</strong>来衡量一个估计的好坏。</p><p>既然本篇论文是关于采样方法的改进，那么就首先回顾一下 Monte Carlo 求解渲染方程时会使用到的估计方法。</p><h3 id="简单随机抽样"><a href="#简单随机抽样" class="headerlink" title="简单随机抽样"></a>简单随机抽样</h3><p>假设我们需要估计</p>$$I := \int_\Omega f(x) dx$$<p>的值，并且我们可以<strong>等概率</strong>且<strong>独立</strong>的从 $\Omega$ 中抽取样本 ${x_i}_{i&#x3D;1}^n$，那么我们就可以构造估计量 $\bar I$</p>$$\bar I := \frac{|\Omega|}{N} \sum_{i=1}^n f(x_i)$$<p>既然 $X_i$ 是随机变量，那么我们的估计量自然也是个随机变量，它的期望 $\operatorname{E}[\bar I]$ 是</p>$$\begin{aligned}\operatorname{E}[\bar I] &= \frac{|\Omega|}{N} \sum_{i=1}^n \operatorname{E}[f(X_i)] \\&= |\Omega| \operatorname{E}[f(x_1)] & \text{(} \{X_i\} \text{ satisfy i.i.d.)} \\&= |\Omega| \int_\Omega f(x) d \mu(x) \\&= |\Omega| \int_\Omega f(x) \mu(x) dx \\&= |\Omega| \int_\Omega f(x) \frac{1}{|\Omega|} dx \\&= I\end{aligned}$$<blockquote><p>Note: 形如</p>$$\int_\Omega f(x) d\mu(x) $$<p>的积分中，$\mu(x)$ 是随机变量 $X$ 所对应的概率密度函数，在这里是均匀分布所以 $\mu(x) &#x3D; 1&#x2F;|\Omega|$ 。期望的本质就是 “$\sum x \times p(x)$”</p></blockquote><!-- 比如说我们在初等概率论中学到的随机变量，在测度论角度来讲就是一种可测函数，而初等概率论在很多计算上面是直接在取值空间进行计算的，也就是实数空间，它的很多积分的运算你放在测度论来看就是直接应用了积分变换定理。在概率论中提到的“分布”，其实就是根据这个随机变量（可测函数）在原空间和取值空间进行一个测度变换，站在这个角度去看待一些概率论问题就会感觉一切是那么合理，简直就是一种艺术。作者：再熬夜是猪链接：https://www.zhihu.com/question/29800166/answer/1884856359来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。--><p>所以积分最终会收敛，但是估计量 $\bar I$ 的方差依赖于 $f(x)$ 本身的性质：</p>$$\begin{aligned}\operatorname{Var}[\bar I] &= \frac{|\Omega|^2}{N^2} \operatorname{Var} \left[ \sum_{i=1}^{n} f(x_i) \right] \\&= \frac{|\Omega|^2}{N} \operatorname{Var}[f(x)] \\&= \frac{|\Omega|^2}{N} \left( \operatorname{E}[f(x)^2] - \operatorname{E}[f(x)]^2 \right) \\&= \frac{|\Omega|^2}{N} \left[ \int_\Omega f(x)^2 \mu(x) dx - \left( \int_\Omega f(x) \mu(x) dx \right)^2 \right] \\&= \frac{1}{N} \left[ |\Omega| \int_\Omega f(x)^2 dx - \left( \int_\Omega f(x) dx \right)^2 \right]\end{aligned}$$<p>我们观察到，后面的方括号中的内容和抽样次数 N 无关，所以只要 $\operatorname{Var}[f(X_i)]$ 有限，即可说明增加抽样次数，估计量最终可以<strong>在方差意义上</strong>收敛到原函数。</p><!-- https://math.stackexchange.com/questions/1386113/proving-that-the-variance-is-non-negative --><!-- TODO: 补一些 Var 的图 --><!-- 写一个 browser-side 画函数的工具？(大坑) --><blockquote><p>Note: </p><ol><li>$\operatorname{Var}[X] = \operatorname{E}[(X-\operatorname{E}[X])^2] = \operatorname{E}[X^2-2 \cdot X \cdot \operatorname{E}[X] + (\operatorname{E}[X])^2] = \operatorname{E}[X^2]-(\operatorname{E}[X])^2$ </li><li>$\operatorname{Var}[aX+bY] = a^2\operatorname{Var}[X] + b^2\operatorname{Var}[Y] + 2ab \operatorname{Cov}[X, Y]$</li><li>如果很严谨，还应该讨论函数具有何种性质时，方差意义上收敛的两个函数是同一个函数。（<del>不过我不会</del>）</li></ol></blockquote><h3 id="重要性采样-Importance-Sampling"><a href="#重要性采样-Importance-Sampling" class="headerlink" title="重要性采样 (Importance Sampling)"></a>重要性采样 (Importance Sampling)</h3><p>仍然假设我们需要估计</p>$$I := \int_\Omega f(x) dx$$<p>但是这次，我们选择一个连续分布，记其概率密度函数为 $p(x)$，并且我们从该分布中抽样得到样本 ${x_i}_{i&#x3D;1}^N$，我们用这些样本构造估计量 $\bar I$</p>$$\bar I := \frac{1}{N} \sum_{i=1}^n \frac{f(x_i)}{p(x_i)}$$<p>那么，</p>$$\begin{aligned}\operatorname{E}[\bar I] &= \operatorname{E}\left[\frac{f(x_1)}{p(x_1)}\right] \\&= \int_\Omega \frac{f(x)}{p(x)} p(x) dx \\&= \int_\Omega f(x) dx \\&= I\end{aligned}$$<blockquote><p>此处的推导隐含 $p(x)$ 在 $\Omega$ 上的值<strong>非零</strong>，考虑到 $p(x)$ 是概率密度函数，$p(x) &gt; 0$</p><p>不过事实上我们只需要 $p(x) &gt; 0$ 在 $\operatorname{supp}(f)$ 成立即可。</p></blockquote><p>方差：</p>$$\begin{aligned}\operatorname{Var}[\bar I]&= \frac{1}{N^2} \operatorname{Var}\left[ \sum_{i=1}^n \frac{f(x_i)}{p(x_i)} \right] \\&= \frac{1}{N} \operatorname{Var}\left[ \frac{f(x)}{p(x)} \right] \\&= \frac{1}{N} \left( \operatorname{E}\left[\left[\frac{f(x)}{p(x)}\right]^2\right] - \operatorname{E}\left[\frac{f(x)}{p(x)}\right]^2  \right) \\&= \frac{1}{N} \left[ \int_\Omega \left(\frac{f(x)}{p(x)}\right)^2 p(x) dx - \left( \int_\Omega \frac{f(x)}{p(x)} p(x) dx \right)^2 \right] \\&= \frac{1}{N} \left[ \int_\Omega \frac{f(x)^2}{p(x)} dx - \left( \int_\Omega f(x) dx \right)^2 \right] \\\end{aligned}$$<p>则加大 N 后方差可以渐进趋于 0。</p><p>如果我们可以找到概率密度函数 $p(x)$ 满足</p>$$p(x) = \frac{f(x)}{\int_\Omega f(t) \, dt}$$<p>的话，带入上面的式子可以得到</p>$$\begin{aligned}\operatorname{Var}[\bar I]&= \frac{1}{N} \left[ \left(\int_\Omega f(x) dx\right)^2 - \left( \int_\Omega f(x) dx \right)^2 \right] = 0\end{aligned}$$<p>一般的，由 $p(x)$ 决定的分布对 $f(x)$ 近似的越好，相同样本数量下估计量的方差就会越低。</p><h3 id="重采样重要性采样-Resampled-Importance-Sampling"><a href="#重采样重要性采样-Resampled-Importance-Sampling" class="headerlink" title="重采样重要性采样 (Resampled Importance Sampling)"></a>重采样重要性采样 (Resampled Importance Sampling)</h3><p>从前面的重要性采样方法中我们了解到，我们采样的 $p(x)$ 的形状越接近 $f(x)$，那么采样的效果就越好。</p><blockquote><p>所谓形状接近，就是函数贴近 ${f(x)}&#x2F;{\int_\Omega f(t) , dt}$。</p></blockquote><p>如果我们有一个很棒的分布 $\hat p(x)$，他比较接近 $f(x)$ 的形状，但是我们没法直接采样出符合 $\hat p(x)$ 分布的样本。</p><p><em>(1-sample RIS)</em> 假设我们此时还可以找到一个分布 $p(x)$，其与 $\hat p(x)$ 比较接近，那么此时，我们可以采用如下方法，采样出符合 $ \hat p(x)$ 分布的样本：</p><ol><li>从 $p(x)$ 分布中抽样得到集合 $ X &#x3D; {x_1, …, x_M } $</li><li>按如下所给的条件概率抽样一个<strong>索引</strong> $ z \in {1, …, M} $$$p(z \, | \, x_1, ..., x_M) = \frac{w(x_z)}{\sum_{i=1}^M w(x_i)} \quad \text{with} \quad w(x) = \frac{\hat p(x)}{p(x)}$$</li><li>按下式计算估计量$$\begin{aligned}\bar I^{1, M}_{ris}(z, x_1, ..., x_M) = \frac{f(x_z)}{\hat p(x_z)} \cdot \left( \frac{1}{M} \sum^M_{j=1} w(x_j) \right)\end{aligned}$$</li></ol><p>首先，我们需要证明这个方法正确。证明的核心在于计算两步抽样最终抽到 $ x_z $ 的概率。记</p>$$p(z_0, x_z) := \lim_{\epsilon \to 0} P(z = z_0,  x_z \le x \le x_z + \epsilon) / \epsilon$$<p>则</p>$$p(z, x_1, ..., x_M) = p(z \, | \, x_1, ..., x_M) \prod_{i=1}^M p(x_i) = \frac{ {\hat p(x_z)}/{p(x_z)} }{\sum_{i=1}^M \left({\hat p(x_i)}/{p(x_i)}\right)} \prod_{j=1}^M p(x_j)$$<p>则</p>$$\begin{aligned}\operatorname{E}\left[\bar I^{1, M}_{ris}\right]&= \int_{x_1, ..., x_M} \sum_{z=1}^M \bar I^{1, M}_{ris}(z, x_1, ..., x_M) \, p(z \, | \, x_1, ..., x_M) \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \int_{x_1, ..., x_M} \sum_{z=1}^M \frac{f(x_z)}{\hat p(x_z)} \cdot \left( \frac{1}{M} \sum^M_{j=1} w(x_j) \right) \frac{ {\hat p(x_z)}/{p(x_z)} }{\sum_{j=1}^M w(x_j)} \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \frac{1}{M} \int_{x_1, ..., x_M} \sum_{z=1}^M \frac{f(x_z)}{p(x_z)} \left( \prod_{i=1}^M p(x_i) \right) \, dx_1 ... dx_M \\&= \frac{1}{M} \operatorname{E}\left[ \sum_{z=1}^{M} \frac{f(x_z)}{p(x_z)} \right] \\&= \operatorname{E}\left[ \frac{f(x)}{p(x)} \right] \qquad \text{(} \because x_i \text{ i.i.d.)} \\&= \int_\Omega f(x) \, dx\end{aligned}$$<blockquote><p>NOTE: </p><ol><li>$ \int_{x_1, ..., x_M} $ 和 $ \int_{\mathcal{\Omega}^M} $ 是一样的，是他们各自的空间 $ \Omega $ 的直积。</li><li>$ \operatorname{E}[X+Y] = \operatorname{E}[X] + \operatorname{E}[Y] $ 不依赖于 $ X $ 和 $ Y $ 独立。</li></ol></blockquote><!-- TODO: 补充个 2 的证明 --><p>方差也可以相应计算如下：</p>$$\begin{aligned}\operatorname{Var}\left[\bar I^{1, M}_{ris}\right]&= \frac{1}{M^2} \operatorname{Var}\left[ \frac{f(x_z)}{\hat p(x_z)} \cdot \left(  \sum^M_{j=1} w(x_j) \right) \right] \\&= ?\end{aligned}$$<!-- TODO: Multi-sample RIS --><h3 id="带权蓄水池抽样-Weighted-Reservoir-Sampling"><a href="#带权蓄水池抽样-Weighted-Reservoir-Sampling" class="headerlink" title="带权蓄水池抽样 (Weighted Reservoir Sampling)"></a>带权蓄水池抽样 (Weighted Reservoir Sampling)</h3><p>前面提到，重采样重要性采样需要先抽 $ M $ 个样本，然后从中再抽样出最终的值。</p><p>经过仔细观察，拥有如下结构的抽样问题可以用带权蓄水池抽样 (Weighted Reservoir Sampling) 来解决：</p>$$p(z \, | \, x_1, ..., x_M) = \frac{w(x_z)}{\sum_{i=1}^M w(x_i)}$$<p>(WRS) 假设对于序列 $ {x_1, …, x_m} $，我们希望按上述概率抽样得到样本 $x_z$</p><ol><li>维护一个当前总权重 $ w_\text{sum} $，当前总样本数 $ M $ 和最终样本 $ y $</li><li>初始化 $ y:&#x3D;x_1; , M:&#x3D;1; , w_\text{sum}:&#x3D;w(x_1) $</li><li>对于每个新样本 $x_i$<ul><li>以 $ w(x_i) &#x2F; w_\text{sum} $ 概率：$ y:&#x3D;x_i; , M:&#x3D;M+1; , w_\text{sum} :&#x3D; w_\text{sum}+w(x_i) $</li><li>以 $ 1 - w(x_i) &#x2F; w_\text{sum} $ 概率：$ M:&#x3D;M+1; , w_\text{sum} :&#x3D; w_\text{sum}+w(x_i) $</li></ul></li></ol><p>这样对于某个样本 $ x_k $，经过这个过程最后被选中的概率为 <code>P(第 k 次被选中) * P(第 k 次之后都没有被换掉)</code>，乘起来很容易证明正确性。</p><p>WRS 方法的优势在于，不需要完成存储 $ {x_i} $ 序列本身，而是线性扫描一遍这个序列就可以得出结果，非常适合和前面的 RIS 方法搭配使用。</p><h3 id="蓄水池合并-Reservoir-Merging"><a href="#蓄水池合并-Reservoir-Merging" class="headerlink" title="蓄水池合并 (Reservoir Merging)"></a>蓄水池合并 (Reservoir Merging)</h3><!-- 假设我们要从 $ \{x_1, ..., x_m, y_1, ..., y_n\} $ 中抽样， -->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍了 ReSTIR 这种用于实时渲染的采样增强方法，该方法可以处理交互式渲染中对大量光源 (&amp;gt;&amp;#x3D; 1k) 的直</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客复活！</title>
    <link href="https://blog.libreliu.info/blog-reborn/"/>
    <id>https://blog.libreliu.info/blog-reborn/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-07-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客已经有一段时间没更新了，以至于竟然连之前的源文件都找不到了。</p><p>这次将博客的源文件放到 GitHub 上，并且把之前的文章收集整理一下，进行一下重构。</p><h2 id="用什么博客框架？"><a href="#用什么博客框架？" class="headerlink" title="用什么博客框架？"></a>用什么博客框架？</h2><p>在 Hexo 和 Pelican 中选择了 Hexo，主要社区和主题的维护者都更活跃一些。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="生成-amp-测试"><a href="#生成-amp-测试" class="headerlink" title="生成 &amp; 测试"></a>生成 &amp; 测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/hexo generate</span><br><span class="line">./node_modules/.bin/hexo server</span><br></pre></td></tr></table></figure><p>也可以考虑 <code>npm run build</code> 和 <code>npm run server</code>。</p><h3 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h3><p><code>hexo new &quot;My new post&quot;</code></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>主题基于 <a href="https://github.com/52binge/hexo-theme-blairos">BlairOS</a> 这个 Hexo 主题，我裁减了其中的统计代码，更改了 Logo 和相关的 Stylus 代码。</p><h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><ul><li>计划在将来把对 cdn.mathjax.org 的依赖也去掉，变成完全服务端渲染</li><li>这个模板对 ul 嵌套的情况渲染不正确</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前的博客已经有一段时间没更新了，以至于竟然连之前的源文件都找不到了。&lt;/p&gt;
&lt;p&gt;这次将博客的源文件放到 GitHub 上，并且把之前的文章收集整理一下，进行一下重构。&lt;/p&gt;
&lt;h2 id=&quot;用什么博客框架？&quot;&gt;&lt;a href=&quot;#用什么博客框架？&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>USTC Verilog OJ | 设计、实现、剩下的坑</title>
    <link href="https://blog.libreliu.info/ustc-verilog-oj/"/>
    <id>https://blog.libreliu.info/ustc-verilog-oj/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-02-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>(Remark 2022-07-07): 本文原发于知乎，现在在博客这边补个档。</p></blockquote><p>夜深人静的时候有些难以入眠（实际上可能是早上起太迟了），于是开一篇文章大略记叙一下部署在 <a href="https://verilogoj.ustc.edu.cn/">https://verilogoj.ustc.edu.cn/</a> 处的 USTC Verilog OJ 的设计实现和留下的坑。</p><p>设计一个 Verilog OJ 的想法源于 2020 春的《软件工程》课程，课程伊始要求同学们以 10 人为一组提交一个大作业。正好，当时 lluckydog 提到了这个点子，我们就去找实验中心的老师协商，老师也感觉不错。</p><p>设计之初，考虑到 Verilog 作为硬件描述（和仿真）语言的地位，我们认为 Verilog OJ 本身应该与其它程序设计语言的 OJ 有所不同。这种不同主要是来源于电路这种设计产出与程序这种产出之间的差异。</p><p>电路可以从功能和性能两方面来进行评价。对于功能，用行为级仿真就可以解决，而对于性能，则要将其放到后端当中去，从占用的资源，完成功能所需要的时钟周期和可以达到的最高时钟频率，以及使用到的资源等来综合的进行评价。这就意味着，OJ 在执行架构上需要兼容各种不同的评价任务，并且可以灵活配置。</p><p>针对这一点，我们认为应该将每个判题任务配置为 shell 脚本，在脚本中读取用户输入的文件，并且进行输出操作，这样就可以比较灵活的进行不同评测任务的配置了。</p><p>我们当时还调研了前端和后端评测任务的一些可能方向，比如<a href="https://github.com/YAVGroup/Verilog-OJ/blob/master/doc/research/OpenTimer%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90.md">使用 OpenTimer 进行静态时序分析</a>，<a href="https://github.com/YAVGroup/Verilog-OJ/blob/master/doc/research/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%AF%84%E4%BB%B7.md">使用 Yosys 进行综合并且判断电路综合后有没有 latch</a> 等等。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>前端方面我们是从 <a href="https://github.com/Linzecong/LPOJ">LPOJ</a> 的代码基础上开始修改的，所以也沿用了 Element UI + Vue.js 的组合；编辑代码采用 CodeMirror，显示波形采用 Wavedrom。</p><p>后端采用 Django + Django RESTful Framework，Django 赋予的快速原型能力我们整体还是比较满意的。</p><p>后端和判题机通过消息队列 Celery 实现解耦，为增加新的判题机留出空间，同时将两个过程掰开。判题机提交判题结果的方法就是把 SubmissionResult 对象进行 HTTP PATCH。</p><p>判题机本身会在每个新的判题请求到来时，从后端拉下来所有需要的文件，同时新启动一个 Docker 容器用来判题，判题完成时会将容器中分数、日志、波形（app_data）拷出并上传，之后销毁容器。容器本身有时间和内存限制。</p><blockquote><p>大多数判题任务就是在参考答案和用户提交答案上面跑一个 testbench 并且 dump vcd，然后做一个波形比较。vcd 文件解析使用的是 pyDigitalWaveTools。</p></blockquote><p>使用 Nginx 做反代，方便调整一些请求头之类的，上面所有的部分都打包为容器，并且用 docker-compose 进行部署。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>软工课程答辩前，我们设计了几道简单的题目来验证 Verilog OJ 的功能。<a href="https://github.com/YAVGroup/Verilog-OJ/tree/master/assets">这些题目</a>包括输出 0，输出 1，3-8 译码器和三个数的比较器等。前面几道题目是行为级的仿真，最后一题用到了 Yosys 进行综合，并且对综合后结果进行仿真（大概就是 <code>yosys -p &quot;read_verilog ./submit/code.v; synth -top top_module; write_verilog code_synthed.v&quot; -v 3</code>）</p><p>不过软工结束之后，由于鸽子们鸽来鸽去，想搞的计算机组成原理实验自动评测一直没有动静，助教们最后也还是决定手工检查，所以系统就有派上用场。</p><p>2021 年署假的时候，老师决定先翻译一些 <a href="https://hdlbits.01xz.net/">HDLBits</a> 上面的题目，作为下学期数字电路实验的一小部分，来帮助 Verilog 的学习。</p><p>在这学期出题和同学们做题的过程中，也发现并且修复了一些脚本上的问题，主要是 VCD 的一些 corner case。</p><h2 id="剩下的坑"><a href="#剩下的坑" class="headerlink" title="剩下的坑"></a>剩下的坑</h2><p>使用过程中同学们提了很多意见，这些意见基本都以 Issue 的形式放到了仓库当中去。不过不少问题都被我们一直鸽着，也缺乏感兴趣的新同学加入进来。</p><p>远期来说，我个人希望这个平台可以帮助希望做硬件开发的同学们更贴近 IC 业界考虑的问题，并且对硬件设计本身有更好的理解——当然鉴于我本人是个硬件菜鸡，这还需要很多大佬的支持才能办到。</p><p>就我个人从前辈处了解到的一些信息来说，IC 的验证和后端的流程普通的同学还是很难接触到的，可能在平台中有关于验证和后端设计需要关心的问题进行设计并包装成为题目是值得尝试的一些方向。</p><blockquote><p>比如说，SystemVerilog &#x2F; UMD 通用验证方法学 的超快速入门，调教时序问题的小实战等</p></blockquote><p>另一个可能值得尝试的坑是对接 USTC FPGAOL 平台，将片上的表现作为评估和设计迭代的依据。</p><p>（不过听着就是大坑.jpg）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>赶紧来个大佬填坑吧！（x）</p><p>希望有更多感兴趣的同学加入到我们的开发（和提 Issue）的工作当中ww</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;(Remark 2022-07-07): 本文原发于知乎，现在在博客这边补个档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;夜深人静的时候有些难以入眠（实际上可能是早上起太迟了），于是开一篇文章大略记叙一下部署在 &lt;a href=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
</feed>
