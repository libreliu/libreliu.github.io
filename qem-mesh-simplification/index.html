<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>可能是史上最详尽的 QEM 网格简化算法解释 - libreliu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。  简介QEM 算法（Garland and Heckbert [1998]）是网格简化领域的经典算法。 相关实现GitHub - byreave&#x2F;MeshSimplification-QEM: A C++implementation of QEM algorithm. GitHub - WZFish&#x2F;QEM-Me">
<meta property="og:type" content="article">
<meta property="og:title" content="可能是史上最详尽的 QEM 网格简化算法解释">
<meta property="og:url" content="https://blog.libreliu.info/qem-mesh-simplification/">
<meta property="og:site_name" content="libreliu&#39;s blog">
<meta property="og:description" content="注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。  简介QEM 算法（Garland and Heckbert [1998]）是网格简化领域的经典算法。 相关实现GitHub - byreave&#x2F;MeshSimplification-QEM: A C++implementation of QEM algorithm. GitHub - WZFish&#x2F;QEM-Me">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog.libreliu.info/qem-mesh-simplification/image-20230420220930080.png">
<meta property="article:published_time" content="2023-04-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-10T16:00:00.000Z">
<meta property="article:author" content="Libre Liu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.libreliu.info/qem-mesh-simplification/image-20230420220930080.png">
  
  
    <link rel="icon" href="/css/images/logo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="libreliu's blog" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/paper-summary">Paper Reading</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.libreliu.info"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="post-qem-mesh-simplification" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      可能是史上最详尽的 QEM 网格简化算法解释
      <small class=article-detail-date-index>&nbsp; 2023-04-11</small>
    </h1>
  


        <div class=page-title></div>
        <br>
      </header>
    
    <div class="article-meta">
      <!--<a href="/qem-mesh-simplification/" class="article-date">
  <time datetime="2023-04-10T16:00:00.000Z" itemprop="datePublished">2023-04-11</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
      
      
        <blockquote>
<p>注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QEM 算法（<a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=288280">Garland and Heckbert [1998]</a>）是网格简化领域的经典算法。</p>
<h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><p><a target="_blank" rel="noopener" href="https://github.com/byreave/MeshSimplification-QEM">GitHub - byreave&#x2F;MeshSimplification-QEM: A C++implementation of QEM algorithm.</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/WZFish/QEM-MeshSimplification">GitHub - WZFish&#x2F;QEM-MeshSimplification</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/songrun/SeamAwareDecimater">GitHub - songrun&#x2F;SeamAwareDecimater: Mesh simplification with UV’s boundary preserved</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/MeshFrame/MeshFrame/blob/master/Examples/MeshSimplifyQEM/mesh.cpp">GitHub - MeshFrame&#x2F;MeshFrame: A light-weighted, efficient and header-only mesh processing frame work</a></p>
<h2 id="QEM-Original"><a href="#QEM-Original" class="headerlink" title="QEM Original"></a>QEM Original</h2><blockquote>
<p>出现于文章 <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">Surface Simplification Using Quadric Error Metrics</a> 中</p>
</blockquote>
<h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>设现在有网格 $ M &#x3D; (V, F) $，规定<strong>可收缩顶点对</strong>为</p>
<ol>
<li>原网格中的边</li>
<li>$ \| v_1 - v_2\| < \epsilon $ 的顶点对 $ (v_1, v_2) $</li>
</ol>
<p>对每个三角形 $ F_i $，设构成该三角形的三个顶点为 $ v_0, v_1, v_2 $，则 $ F_i $ 上的点 $ v_f $ 满足方程</p>
$$
(\vec v_f- \vec v_0) \cdot \vec n = 0 \Rightarrow \vec v_f \cdot \vec n - \vec {v_0} \cdot \vec n = 0
$$

<p>其中面法线 $ \vec n $ 满足</p>
$$
\vec {n} =  \frac{(\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0)}{\| (\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0) \|}
$$


<p>空间中任意一点 $ v $ 到平面 $ F_i $ 的距离的平方为</p>
$$
\begin{aligned}
d^2(v, F_i) &= \| (\vec v-\vec v_0) \cdot \vec n \|^2 \\
&= (n^\mathbf{T} v - n^\mathbf{T} v_0 )^2 \\
&= v^\mathbf{T} (nn^\mathbf{T}) v - 2 n^\mathbf{T} v_0 n^\mathbf{T}v + (n^\mathbf{T} v_0)^2
\end{aligned}
$$
<p>定义</p>
$$
\begin{aligned}
{\bf A}_{3\times 3} &= n n^\mathbf{T}\\ 
d &= -n^\mathbf{T} v_0 \\
\vec b_{3 \times 1} &= d n \\
c &= d^2
\end{aligned}
$$
<p>则</p>
$$
d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c
$$
<p>这个距离平方也可以写成齐次形式</p>
$$
d^2(v, F_i) = h^\mathbf{T} {\bf Q} h \\
\text{where} \ {\bf Q}_{4\times4} = \begin{pmatrix} {\bf A}_{3 \times 3} & b_{3 \times 1} \\ b^\mathbf{T} _{1 \times 3}& c_{1 \times 1} \end{pmatrix} \ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}
$$
<p>所以，对于每一个平面 $ F_i $，都可以定义一个二次型 $ Q_{F_i}(v) &#x3D; h^\mathbf{T} \mathbf{Q} h $，其为任意一点 $ v$ 到该平面距离的平方。</p>
<p>对于顶点 $ v $，该顶点到相邻的所有表面的距离平方和可以表示为 $ \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i}(v) &#x3D; (\sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i})(v) $ 。</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>QEM 算法的框架如下：</p>
<ul>
<li><p>每个顶点 $ v_i $ 按上面的方法赋予一个 Q 矩阵，$ Q_{v_i} &#x3D; \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i} $</p>
</li>
<li><p>收缩 $(v_i, v_j)$ 边到 $ v’ $ 时，定义这次收缩的代价为 $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$；每次全局的选择最小代价的边进行收缩</p>
<ul>
<li>如何选择 $ v’ $？有 Optimal Placement 和 Subset Placement 两种形式：<ol>
<li><p>(<strong>Optimal Placement</strong>) $ {\bf A} $ 可逆时</p>
<p>令 $ \frac{\partial}{\partial v}(v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c) &#x3D; 0 $，解得 $ v_\text{optimal} &#x3D; -{\bf A}^{-1} b $ </p>
</li>
<li><p>(<strong>Subset Placement</strong>) $ {\bf A} $ 不可逆时，选择两个端点或中点；看哪个 edge loss 小</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>收缩后的顶点 $ v’ $ 更新</p>
<blockquote>
<p>这里对算法有两种理解，第一种是按初始计算的方法重新按邻面赋予 Q 矩阵（这样就是一个完全 local 的方法），第二种理解是合并两个顶点，则将对应的 Q 矩阵也进行合并。</p>
<p>文章中的做法是<strong>第二种理解</strong>，从文章提到 implicit track sets of planes 可以知道。不过在 Discussion 处也讨论了这种做法的问题：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><em>Second, the information accumulated in the quadrics is essentially implicit, which can at times be problematic. Suppose we join together two cubes and would like to remove the planes associated with the now defunct interior faces. Not only is it, in general, difficult to determine what faces are defunct, there is no clear way to reliably remove the appropriate planes from the quadrics. As a result, our algorithm does not do as good a job at simplification with aggregation as we would like.</em></p>
</blockquote>
<ul>
<li>$ Q_{v'} = Q_{v_1} + Q_{v_2} $</li>
</ul>
<p>值得注意的是， $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$ 会导致一些 double counting 的现象发生，即有些公共面构造的 Q 分量被重复求和了。但作者提到，这样的重复对效果的影响有限。</p>
<blockquote>
<p>这里引用了 Donald E. Knuth. The Art of Computer Programming, volume 1. Addison Wesley, Reading, MA, Third edition, 1997.</p>
<p>不是很懂高德纳老爷子和 inclusion-exclusion rule 对效果的改善的关系…</p>
</blockquote>
<h3 id="Preserving-Boundaries"><a href="#Preserving-Boundaries" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>对于不希望边界移动的情况，可以首先标记将边标记为<strong>正常边</strong>和<strong>边界边</strong>两种（这个边界边不一定需要是真的网格边界，只是比较不希望移动的边）。</p>
<p>对于标记为<strong>边界边</strong>的边 $(v_1, v_2)$，令和其相邻的所有面的 Q 矩阵中增加一项反映到垂直于该平面、且过该<strong>边界边</strong>的一个平面的距离平方的项。</p>
<p>设边界边 $(v_1, v_2)$，不妨设某个相邻的三角形 $ F_i $ 的三个顶点为 $v_1, v_2, v_3$，则与之相对的边界平面 $ F_{B_i} $ 可以计算如下</p>
$$
n_{F_i} = \operatorname{normalize}{ \left((v_2 - v_1) \times (v_3 - v_1) \right)} \\
n_{F_{B_i}} = \operatorname{normalize}{\left( n_{F_i} \times (v_2 - v_1) \right)} \\
\forall v \in F_{B_i},\ \vec {n_{F_{B_i}}} \cdot (\vec v - \vec {v_1}) = 0 \Rightarrow \vec {n_{F_{B_i}}} \cdot \vec v +(- \vec {n_{F_{B_i}}} \cdot \vec {v_1}) = 0
$$
<p>则到边界平面 $ F_{B_i} $ 的距离平方计算如下：</p>
$$
d^2(v, F_{B_i}) = h^\mathbf{T} \mathbf{Q} h \\
\text{where} \ {\bf Q}_{4\times4} = 
\begin{pmatrix}
{\bf A}_{3 \times 3} & b_{3 \times 1} \\
b^\mathbf{T} _{1 \times 3}& c_{1 \times 1}
\end{pmatrix} = 
\begin{pmatrix}
n_{F_{B_i}}n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) {n_{F_{B_i}}} \\
(- n_{F_{B_i}} \cdot {v_1}) n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) ^2
\end{pmatrix}
\ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}
$$
<p>把他加入到相邻面的 Q 矩阵中，最后就会进入各个边的 Q 矩阵。</p>
<h2 id="Appearance-Preserving-QEM"><a href="#Appearance-Preserving-QEM" class="headerlink" title="Appearance Preserving QEM"></a>Appearance Preserving QEM</h2><blockquote>
<p>出现于文章 <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~garland/Papers/quadric2.pdf">Simplifying Surfaces with Color and Texture using Quadric Error Metrics</a> 中</p>
</blockquote>
<p>对于<strong>连续</strong>的顶点属性来说，可以通过把他们加入向量中一起优化的方法来解决。这种方法本质上是原来 QEM 的推广，将原来的到平面的距离推广为了到平面上三点的位置和其它顶点属性共同确定的<strong>超平面</strong>的距离。</p>
<p>同时，本文中调整了<strong>可收缩顶点对</strong>的定义，将其限制在了原三角网格中的边的范围内，因为可靠性不够好。</p>
<blockquote>
<p>Our experience has shown that, while greedy edge contraction produces consistently good results on many kinds of models, greedy contraction of arbitrary pairs is not as robust and does not perform as consistently.</p>
</blockquote>
<h3 id="Formulation-1"><a href="#Formulation-1" class="headerlink" title="Formulation"></a>Formulation</h3><p>将上面的三角形 $ F_i $ 的各个顶点 $ v_i $ 从 $ \mathbb{R}^3 $ 推广到 $ \mathbb{R}^n $，我们知道 3 个 $ \mathbb{R}^n $ 中的点（非线性相关）仍然确定一个 $ \mathbb{R}^2 $ 平面，这个平面的两个<strong>标准正交</strong>基向量 $ e_1 $，$ e_2 $ 可以用 Schmidt 正交化的办法得到：</p>
$$
\begin{aligned}
e_1 &= \operatorname{normalize}{(v_2-v_1)} \\
e_2 &= \operatorname{normalize}{((v_3 - v_1) - (e_1 \cdot (v_3 - v_1)) e_1)}
\end{aligned}
$$
<p>这样，对于 $ v \in \mathbb{R}^n $，有</p>
$$
\begin{aligned}
d^2(v, F_i) &= \| v - v_1 \|^2 - ((v-v_1)\cdot e_1)^2 - ((v-v_1)\cdot e_2)^2 \\
&= (v-v_1)^{\bf T}(v-v_1) - ((v-v_1)^{\bf T}e_1)(e_1^{\bf T}(v-v_1)) - ((v-v_1)^{\bf T}e_2)(e_2^{\bf T}(v-v_1)) \\
&= (v^{\bf T} v - v_1^{\bf T}v-v^{\bf T} v_1 + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - v^{\bf T}e_1 e_1^{\bf T} v_1 + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - v^{\bf T}e_2 e_2^{\bf T} v_1 + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v)^{\bf T} + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)^{\bf T}  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v) + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(v^{\bf T}_1 e_1 e_1^{\bf T} + v^{\bf T}_1 e_2 e_2^{\bf T}-v_1^{\bf T}) v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(e_1 e_1^{\bf T}v_1 +e_2 e_2^{\bf T} v_1 - v_1)^{\bf T} v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2((e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1)^{\bf T} v + (v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2)

\end{aligned}
$$
<p>仿照前面，整理成 Q 矩阵的形式</p>
$$
d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c \\
\text{where}\ \left\{
\begin{aligned}
{\bf A}_{n\times n} &= {\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T} \\
{\bf b}_{n\times 1} &= (e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1 \\
c_{1\times 1} &= v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2
\end{aligned}
\right.
$$


<h3 id="Preserving-Boundaries-1"><a href="#Preserving-Boundaries-1" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>将原始的 QEM 边界处理方法直接搬到 $ \mathbb{R}^n $ 会比较困难，因为 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面有很多个。</p>
<blockquote>
<p>平面在 $ \mathbb{R}^n $ 中即为一个 $ \mathbb{R}^2 $ 子空间，垂直于该平面的向量现在构成一个“法空间”（其为 $ \mathbb{R} ^n &#x2F; \mathbb{R} ^2 $ 的商空间），其维数为 $ n - 2 $，那 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面 $ \iff $  $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点和一个法空间中的点  $ \Rightarrow $ 这样的平面至少有 $ n - 2 $ 个</p>
</blockquote>
<p>所以，这里考虑直接锁边界。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./qem-mesh-simplification/image-20230420220930080.png" alt="image-20230420220930080"></p>
<p>0.5 ratio</p>

      
     <!-- by blair add this if sentence at 20160725 -->
      <br>
      
<!-- <div id="bottom-donation-section"> -->
<!-- <span style="font-size: 1.0em; padding:0em 1em 0.5em 1em; margin: 0 auto;">
  <strong style="vertical-align: top;">分享到:</strong>
    <div class="j_handlclick"  style="background: url(/images/logos/share_facebook_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_twitter_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://twitter.com/intent/tweet?url=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_line_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.addtoany.com/add_to/line?linkurl=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_wechat_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://api.addthis.com/oexchange/0.8/forward/wechat/offer?url=" target="_blank">
    </div>
  <br>  
  <br>  
  &nbsp;&nbsp;如果您觉得这篇文章对您的学习很有帮助, 请您也分享它, 让它能再次帮助到更多的需要学习的人.
您的<a href="/support/"><strong>支持</strong></a>将鼓励我继续创作 !
  <br>  

</span> -->
<!--
<h3 id="bottom-donation-title">支持 让文章变得更优质</h3>
<div>
<a id="bottom-donation-button" href="/support">点我 赞助 作者</a>
</div>
-->
<!-- </div> -->
<!-- <div class="well"> -->
  <!--
  原创文章，转载请注明： 转载自<a target="_blank" rel="noopener" href="http://52binge.github.io"> Blair Chan's Blog</a>，作者：
  <a href="/about">Blair Chan</a> <br>
  -->
  <!-- 本文基于<a target="_blank" title="Creative Commons Attribution 4.0 international License" href="https://creativecommons.org/licenses/by-nc/4.0/">署名4.0国际许可协议</a>发布，转载请保留本文署名和文章链接。 如您有任何授权方面的协商，请邮件联系我。 -->
<!-- </div> -->
 <!-- by blair add 160724-->
    
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-text">相关实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QEM-Original"><span class="toc-text">QEM Original</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Formulation"><span class="toc-text">Formulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Framework"><span class="toc-text">Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preserving-Boundaries"><span class="toc-text">Preserving Boundaries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Appearance-Preserving-QEM"><span class="toc-text">Appearance Preserving QEM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Formulation-1"><span class="toc-text">Formulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preserving-Boundaries-1"><span class="toc-text">Preserving Boundaries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-text">效果展示</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/mesa-radv-digestion/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Mesa radv 源码阅读（一）: 如何跟踪图形栈、Vulkan Loader、Mesa 派发机制
        
      </div>
    </a>
  
  
    <a href="/play-with-spirv/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">SPIR-V 初探 (一) - Fragment Shader&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Libre Liu&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true,
    },
    options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>
