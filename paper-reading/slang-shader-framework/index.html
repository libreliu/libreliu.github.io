<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>论文阅读 | Slang - libreliu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简介Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证没有额外性能损失的情况下，解决现代游戏引擎和实时渲染应用中出现的，不同光源 &#x2F; 材质组合出现的 Shader 代码膨胀、晦涩难懂的基于宏的复用等问题。 Slang 针对原 HLSL，主要增加了以下的新特性：  带可选成员类型约束的接口系统 (Interfaces) 以及 extension 关键字来覆盖接口系统的默认行为，提">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读 | Slang">
<meta property="og:url" content="https://blog.libreliu.info/paper-reading/slang-shader-framework/">
<meta property="og:site_name" content="libreliu&#39;s blog">
<meta property="og:description" content="简介Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证没有额外性能损失的情况下，解决现代游戏引擎和实时渲染应用中出现的，不同光源 &#x2F; 材质组合出现的 Shader 代码膨胀、晦涩难懂的基于宏的复用等问题。 Slang 针对原 HLSL，主要增加了以下的新特性：  带可选成员类型约束的接口系统 (Interfaces) 以及 extension 关键字来覆盖接口系统的默认行为，提">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-10-18T14:10:46.892Z">
<meta property="article:author" content="Libre Liu">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/logo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="libreliu's blog" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/paper-summary">Paper Reading</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.libreliu.info"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="paper-reading-paper-reading/slang-shader-framework" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      论文阅读 | Slang
      <small class=article-detail-date-index>&nbsp; 2022-07-31</small>
    </h1>
  


        <div class=page-title></div>
        <br>
      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/slang-shader-framework/" class="article-date">
  <time datetime="2022-07-30T16:00:00.000Z" itemprop="datePublished">2022-07-31</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
          <p>论文标题：Slang: language mechanisms for extensible real-time shading systems</p>
          <p>论文来源：SIGGRAPH 2018</p>
          <p>论文作者：Yong He, Kayvon Fatahalian, Tim Foley</p>
          <p><a target="_blank" rel="noopener" href='http://graphics.cs.cmu.edu/projects/slang/'>论文链接</a></p>
        </blockquote>
      
      
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Slang 是在 HLSL 之上扩展的着色器语言，其旨在保证<strong>没有额外性能损失</strong>的情况下，解决现代游戏引擎和实时渲染应用中出现的，不同光源 &#x2F; 材质组合出现的 Shader 代码膨胀、晦涩难懂的基于宏的复用等问题。</p>
<p>Slang 针对原 HLSL，主要增加了以下的新特性：</p>
<ol>
<li>带可选成员类型约束的接口系统 (Interfaces)<ul>
<li>以及 <code>extension</code> 关键字来覆盖接口系统的默认行为，提供最大灵活性</li>
</ul>
</li>
<li>泛型系统 (Generics)</li>
<li>显式参数块 (Explicit Parameter Blocks)</li>
<li>Slang 编译器和提供运行时类型特化支持的编译器运行时 API</li>
<li>(论文发表后新增) 语法糖和其它易用性改进<ul>
<li>类 C# 的 getter&#x2F;setter 语法糖</li>
<li>运算符重载</li>
<li>模块系统</li>
</ul>
</li>
<li>(论文发表后新增) CUDA, OptiX 等非传统 Shader 编译目标</li>
</ol>
<p>从上面可以看出，Slang 自论文发布后还存在有功能演进，说明作为 Shader 语言本身还是有一定生命力的。</p>
<p>截至 2022 年 7 月 31 日，<a target="_blank" rel="noopener" href="https://github.com/shader-slang/slang">Slang 的 GitHub 仓库</a> 共有 978 个 Star，235 Open Issue 和 284 Closed Issue，最后一次提交在两天前，证明项目还是比较活跃的。</p>
<blockquote>
<p>Note: 据我浅薄的了解，HLSL 也在不断迭代新的功能，如 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">HLSL 2021</a> 的 <code>template</code> 泛型支持等。<del>不过 GLSL 好像没啥大动作</del>(?)</p>
</blockquote>
<h2 id="Slang-语言特性介绍"><a href="#Slang-语言特性介绍" class="headerlink" title="Slang 语言特性介绍"></a>Slang 语言特性介绍</h2><h3 id="接口系统-Interfaces"><a href="#接口系统-Interfaces" class="headerlink" title="接口系统 (Interfaces)"></a>接口系统 (Interfaces)</h3><p>Slang 的接口表示一种约定，比如约定里面会有某种特定函数原型的函数实现，某种特定的成员结构体等，与 “traits” 的语言概念比较接近。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare that MyType have conformance to interface IFoo</span></span><br><span class="line"><span class="keyword">struct</span> MyType : IFoo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">myMethod</span>(<span class="params"><span class="built_in">float</span> arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)arg + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型系统-Generics"><a href="#泛型系统-Generics" class="headerlink" title="泛型系统 (Generics)"></a>泛型系统 (Generics)</h3><p>泛型系统可以实现同时支持不同类型实例的函数。特别的，可以约束传入的形参类型为实现某种接口的类型，如下面的 <code>myGenericMethod</code> 约束 <code>T</code> 为实现 <code>IFoo</code> 接口的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define</span></span><br><span class="line"><span class="type">int</span> myGenericMethod&lt;T: IFoo&gt;(T arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.myMethod(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke</span></span><br><span class="line">MyType obj;</span><br><span class="line"><span class="type">int</span> a = myGenericMethod&lt;MyType&gt;(obj); <span class="comment">// OK, explicit type argument</span></span><br><span class="line"><span class="type">int</span> b = myGenericMethod(obj); <span class="comment">// OK, automatic type deduction</span></span><br></pre></td></tr></table></figure>

<p>同时，Slang 还支持类似 C++ 的非类型模板形参的泛型参数输入，比如下面的 <code>N</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Array&lt;T, <span class="keyword">let</span> N : <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T arrayContent[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数，<code>struct</code> 等语言组件都支持泛型。</p>
<blockquote>
<p>Note: HLSL 本身就支持作为 struct 的 arg 拥有成员函数。</p>
</blockquote>
<h3 id="显式参数块-Explicit-Parameter-Blocks"><a href="#显式参数块-Explicit-Parameter-Blocks" class="headerlink" title="显式参数块 (Explicit Parameter Blocks)"></a>显式参数块 (Explicit Parameter Blocks)</h3><blockquote>
<p>这个特性在 Slang 官方的语言文档中没有着重强调，主要是在 Slang 的这篇论文中强调了。</p>
</blockquote>
<p>现代图形 API（D3D12, Vulkan）对于 Shader 的输入参数是以 “parameter block” 的形式来组织的（例：Vulkan 中术语为 Descriptor Set），一个 Shader 的输入可以由多个 Descriptor Set 组成。</p>
<p>考虑到场景的绘制过程中，有一部分 Shader 参数是不变的（比如同一个绘制到主 RenderTarget 的 Pass 中摄像机的位置），那么把这些不变的参数单独拿出来组织成一个 Parameter Block，把剩下的一些变化频率不太一致的另一些参数（比如模型的 <code>modelMatrix</code>）拿出来作为一个或多个 Parameter Block 的话，就可以降低一部分绘制时的开销。</p>
<p>但是手工组织 Shader 的 layout（特别是对于不同的材质，我们有不同的 Shader 要用）是比较繁琐的，Slang 则对这个 Parameter Binding 和 Parameter Block 有专门的设计（<code>Shader Parameters</code>），可以方便的自动推导符合程序员设计要求的 layout 和 block。</p>
<h3 id="编译器和运行时-API"><a href="#编译器和运行时-API" class="headerlink" title="编译器和运行时 API"></a>编译器和运行时 API</h3><p>Slang 提供了功能丰富的运行时 API，其功能经过一些演进和论文中描述的也不是特别一致了。</p>
<p>Slang 的运行时 API 大概提供了如下机制：</p>
<ol>
<li>运行时 Shader 编译和特化 API<ul>
<li>比如，运行时要对新的材质类型重新编译 Shader，就可以使用这些 API</li>
</ul>
</li>
<li>反射机制<ul>
<li>可以获得某段 Slang Shader 中的函数、Shader 入口参数等信息</li>
</ul>
</li>
</ol>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>Slang 的文档中描述了不少 Slang 的语法糖和易用性改进。</p>
<h4 id="类似-C-的-getter-x2F-setter-语法糖"><a href="#类似-C-的-getter-x2F-setter-语法糖" class="headerlink" title="类似 C# 的 getter &#x2F; setter 语法糖"></a>类似 C# 的 getter &#x2F; setter 语法糖</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">uint</span> flag;</span><br><span class="line"></span><br><span class="line">    property <span class="built_in">uint</span> highBits</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> flag &gt;&gt; <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; flag = (flag &amp; <span class="number">0xFF</span>) + (newValue &lt;&lt; <span class="number">16</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="基于全局函数的运算符重载"><a href="#基于全局函数的运算符重载" class="headerlink" title="基于全局函数的运算符重载"></a>基于<strong>全局函数</strong>的运算符重载</h4><blockquote>
<p>HLSL 2021 支持了基于<strong>成员函数</strong>的运算符重载：[Announcing HLSL 2021</p>
<ul>
<li>DirectX Developer Blog](<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">https://devblogs.microsoft.com/directx/announcing-hlsl-2021/</a>)</li>
</ul>
<p>而 GLSL 截至 2022 年 7 月 31 日还在咕咕：<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/issues/107">Operator overloading · Issue #107 · KhronosGroup&#x2F;GLSL</a></p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    __init(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyType <span class="keyword">operator</span>+(MyType a, MyType b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MyType(a.val + b.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyType rs = MyType(<span class="number">1</span>) + MyType(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rs.val; <span class="comment">// returns 3.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h4><p>Slang 支持一个简单的模块机制，可以把要 import 的目标模块（就是一个 .slang 的 Slang Shader）中的定义导入当前单元。如果该模块此时再被其它模块 import 的话，这些被导入的模块是不会导入到它的“上一层”的单元中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyShader.slang</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的导入</span></span><br><span class="line"><span class="keyword">import</span> YourLibrary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以导入时覆盖前面描述的行为</span></span><br><span class="line">__export <span class="keyword">import</span> SomeOtherModule;</span><br></pre></td></tr></table></figure>

<h2 id="重构-Falcor-渲染器"><a href="#重构-Falcor-渲染器" class="headerlink" title="重构 Falcor 渲染器"></a>重构 Falcor 渲染器</h2><p>Falcor 是一个基于 D3D12 的实时渲染器。</p>
<blockquote>
<p>根据 README，Vulkan 实验性支持在进行中。</p>
</blockquote>
<p>作者从 Falcor 的 2.0.2 版本出发，重构了 5400 行着色器代码。</p>
<p>改进主要集中在如下方面：</p>
<ol>
<li><p>将一个大的 Parameter Block 拆分成 per-material 的 block</p>
</li>
<li><p>Falcor 原来的 Material 采用层次化的设计，每一层 (e.g. GGX, Lambertian, Phong) 都和下一层进行 blend，而渲染时，根据不同的 material 要 dispatch 不同的 shader 时，采用了很多 <code>#define</code> 和基于文本的 Shader Varient Cache 的查询环节。</p>
<p>作者重构时将这套系统用 Slang 的泛型系统重构，并且将标准材质的 Varient 用非类型形参编码成了若干个 int，进而加快了查询速度。</p>
</li>
<li><p>针对与 Material 类似的技术，实现了光源上的特化，在场景中只有某种类型光源的时候采用静态特化好的 Shader 变体，减少运行时判断的开销</p>
</li>
</ol>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>通过重构 Falcor 渲染器，在 NVIDIA 的 ORCA 场景上的测试表明</p>
<ul>
<li>每帧 CPU 执行时间降低了 30%</li>
<li>光源和材料特化改进对部分场景的 GPU 时间有加速作用</li>
</ul>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>作者分别在重构前和重构后的 Falcor 上实现了（基于 LTC 方法的）多边形面光源，</p>
<ul>
<li>重构前：需要改动 7 处，4 个文件，246 行</li>
<li>重构前，但加入光源分离机制：需要改动 8 处，5 个文件，253 行</li>
<li>重构后：只需要改动 1 处，1 个文件，249 行</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>We believe that all real-time graphics programmers could benefit from<br>a new generation of shader compilation tools informed by these<br>ideas. —— <em>Slang: language mechanisms for extensible real-time shading systems</em></p>
</blockquote>

      
     <!-- by blair add this if sentence at 20160725 -->
      <br>
      
<!-- <div id="bottom-donation-section"> -->
<!-- <span style="font-size: 1.0em; padding:0em 1em 0.5em 1em; margin: 0 auto;">
  <strong style="vertical-align: top;">分享到:</strong>
    <div class="j_handlclick"  style="background: url(/images/logos/share_facebook_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_twitter_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://twitter.com/intent/tweet?url=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_line_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.addtoany.com/add_to/line?linkurl=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_wechat_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://api.addthis.com/oexchange/0.8/forward/wechat/offer?url=" target="_blank">
    </div>
  <br>  
  <br>  
  &nbsp;&nbsp;如果您觉得这篇文章对您的学习很有帮助, 请您也分享它, 让它能再次帮助到更多的需要学习的人.
您的<a href="/support/"><strong>支持</strong></a>将鼓励我继续创作 !
  <br>  

</span> -->
<!--
<h3 id="bottom-donation-title">支持 让文章变得更优质</h3>
<div>
<a id="bottom-donation-button" href="/support">点我 赞助 作者</a>
</div>
-->
<!-- </div> -->
<!-- <div class="well"> -->
  <!--
  原创文章，转载请注明： 转载自<a target="_blank" rel="noopener" href="http://52binge.github.io"> Blair Chan's Blog</a>，作者：
  <a href="/about">Blair Chan</a> <br>
  -->
  <!-- 本文基于<a target="_blank" title="Creative Commons Attribution 4.0 international License" href="https://creativecommons.org/licenses/by-nc/4.0/">署名4.0国际许可协议</a>发布，转载请保留本文署名和文章链接。 如您有任何授权方面的协商，请邮件联系我。 -->
<!-- </div> -->
 <!-- by blair add 160724-->
    
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slang-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="toc-text">Slang 语言特性介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B3%BB%E7%BB%9F-Interfaces"><span class="toc-text">接口系统 (Interfaces)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B3%BB%E7%BB%9F-Generics"><span class="toc-text">泛型系统 (Generics)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0%E5%9D%97-Explicit-Parameter-Blocks"><span class="toc-text">显式参数块 (Explicit Parameter Blocks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6-API"><span class="toc-text">编译器和运行时 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">语法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC-C-%E7%9A%84-getter-x2F-setter-%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">类似 C# 的 getter &#x2F; setter 语法糖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">基于全局函数的运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><span class="toc-text">模块机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84-Falcor-%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-text">重构 Falcor 渲染器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-text">可扩展性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/towards-math-markdown/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          让 Hexo 支持内联 LaTeX 数学公式的 Markdown
        
      </div>
    </a>
  
  
    <a href="/paper-reading/ddgi/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">论文阅读 | Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Libre Liu&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true,
    },
    options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>
