<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>论文阅读 | Automatic Mesh and Shader Level of Detail - libreliu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。 文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读 | Automatic Mesh and Shader Level of Detail">
<meta property="og:url" content="https://blog.libreliu.info/paper-reading/auto-shader-mesh-lod/">
<meta property="og:site_name" content="libreliu&#39;s blog">
<meta property="og:description" content="本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。 文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-20T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-20T16:00:00.000Z">
<meta property="article:author" content="Libre Liu">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/logo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="libreliu's blog" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/paper-summary">Paper Reading</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.libreliu.info"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="paper-reading-paper-reading/auto-shader-mesh-lod" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      论文阅读 | Automatic Mesh and Shader Level of Detail
      <small class=article-detail-date-index>&nbsp; 2023-02-21</small>
    </h1>
  


        <div class=page-title></div>
        <br>
      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/auto-shader-mesh-lod/" class="article-date">
  <time datetime="2023-02-20T16:00:00.000Z" itemprop="datePublished">2023-02-21</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
          <p>论文标题：Automatic Mesh and Shader Level of Detail</p>
          <p>论文来源：IEEE TVCG 2022</p>
          <p>论文作者：Yuzhi Liang, Qi Song, Rui Wang, Yuchi Huo, Hujun Bao</p>
          <p><a target="_blank" rel="noopener" href='https://ieeexplore.ieee.org/document/9815871'>论文链接</a></p>
        </blockquote>
      
      
      
        <p>本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。</p>
<p>文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮后得到结果。</p>
<p>针对交替优化耗时较长的问题，文章中还提出了“分别优化”的算法。该算法会首先分别对网格和 Shader 独立的进行简化，得到一系列质量单调下降的 Shader 和网格变体列，然后再针对每个距离组选择合适的网格和 Shader 对。为了让 LOD 组间的变化尽可能平滑，文章还设置了最平滑的 LOD 切换路线的查找，以及 LOD 组数量的优化操作。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li>网格简化和 LOD 生成</li>
<li>Shader 简化和 LOD 生成</li>
<li>基于外观的联合优化</li>
</ul>
<h2 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>对于 Shader 和网格简化问题，定义三元组 $ (M_i, S_i, d_i) $，其中</p>
<ul>
<li>$ M_i $ 为原网格 $ M $ 的第 $ i $ 个简化变体</li>
<li>$ S_i $ 为原 Shader $ S $ 的第 $ i $ 个简化变体 </li>
<li>$ d_i $ 为距相机的距离</li>
</ul>
<p>定义 $ \epsilon_a(i) $ 为简化 $ (M_i, S_i, d_i) $ 变体的绝对图像误差，其定义为</p>
$$
\epsilon_a (i) = \int_H \| f(M_i, S_i, d_i) - \bar{f}(M, S, d_i) \| dH
$$

<p>这里的作为误差模型的积分域 $ H &#x3D; V \times U \times X \times Y $ ，其中</p>
<ul>
<li>$ V $ 为离散的若干个 view direction</li>
<li>$ U $ 若干 Shader uniform 参数，如光照方向</li>
<li>$ X \times Y $ 为图像空间的两个维度</li>
</ul>
<p>这里的范数是 pixelwise RGB $ L^2 $ 范数。</p>
<p>另外，定义 $ \epsilon_t(i) $ 为两个简化组之间的视觉差异：</p>
$$
\epsilon_t (i) = \int_H \| f(M_i, S_i, d_{i+1}) - f(M_{i+1}, S_{i+1}, d_{i+1}) \| dH
$$

<p>这样，LOD 优化问题就可以看作下面的数学问题：</p>
$$
\mathop{\arg \min}_{M_i, S_i, d_i} t = Cost ( f(M_i, S_i, d_i) ) \\
\mathrm{s.t.}\quad \epsilon_a(i) < e_a (d_i) \cdot s_{d_i}
$$

<p>其中 Cost 为在该网格上应用此 Shader 进行着色的时间开销，$ e_a (d_i) $ 为在 $ d_i $ 距离的 absolute per-pixel error bound， $ s_{d_i} $ 为距离 $ d_i $ 时网格 $ M_i $ 的投影大小，</p>
<p>其中 $ e_a(d) $ 采用前面工作提出的一个启发函数：</p>
$$
e_a(d) = (\frac{d-d_{near}}{d_{far} - d_{near}})^Q \cdot e_{max}
$$

<p>其中</p>
<ul>
<li>$ d_{near} $ 和 $ d_{far} $ 是设置的视景体参数</li>
<li>$ e_{max} $ 是 maximum absolute per pixel error bound<ul>
<li>也就是关于 $ e_t(i) $ 的积分项关于积分域里面各个部分的最大值</li>
</ul>
</li>
<li>$ Q \in [0, 1] $ 反映了对误差的容忍程度</li>
</ul>
<h3 id="交替优化"><a href="#交替优化" class="headerlink" title="交替优化"></a>交替优化</h3><h4 id="Shader-简化"><a href="#Shader-简化" class="headerlink" title="Shader 简化"></a>Shader 简化</h4><blockquote>
<p>这里的 Shader 简化工作主要参考了前面的文章：</p>
<ul>
<li>[3] Y. He, T. Foley, N. Tatarchuk, and K. Fatahalian, “A system for rapid, automatic shader level-of-detail,” ACM Trans. on Graph. (TOG), vol. 34, no. 6, p. 187, 2015.</li>
<li>[8] R. Wang, X. Yang, Y. Yuan, W. Chen, K. Bala, and H. Bao, “Automatic shader simplification using surface signal approximation,” ACM Trans. on Graph. (TOG), vol. 33, no. 6, p. 226, 2014.</li>
<li>[18] F. Pellacini, “User-configurable automatic shader simplification,”<br>ACM Trans. Graph., vol. 24, no. 3, pp. 445–452, 2005</li>
<li>[21] P. Sitthi-Amorn, N. Modly, W. Weimer, and J. Lawrence, “Genetic programming for shader simplification,” in ACM Transactions on Graphics (TOG), vol. 30, no. 6. ACM, 2011, p. 152.</li>
</ul>
</blockquote>
<ol>
<li>将 Vertex Shader 和 Fragment Shader 转换为抽象语法树 (AST) 和程序依赖图 (PDG)</li>
<li>应用不同的化简规则来生成简化 Shader<ul>
<li>Operation Removal: 将 $ op(a, b) $ 省略为 $ a $ 或 $ b $</li>
<li>Code Transformation: 将 per-pixel 的 pixel shader 操作移动到 per-vertex 或 per-tessellated-vertex 的操作来减少计算量</li>
<li>Moving to parameter: 将参数用其均值替换（$ n \to average(n) $），并且替换到 “parameter stage” 中进行计算（详见 [3]），并将均值作为结果送入 GPU Shader 中</li>
</ul>
</li>
</ol>
<blockquote>
<p>本文并没有对 Shader 本身的优化方面做出额外的创新。这些方法主要来源于 [3] 这篇文章。</p>
</blockquote>
<h4 id="Mesh-简化"><a href="#Mesh-简化" class="headerlink" title="Mesh 简化"></a>Mesh 简化</h4><blockquote>
<p>Mesh 简化工作：</p>
<ul>
<li>[4] M. Garland and P. S. Heckbert, “Surface simplification using<br>quadric error metrics,” in Proceedings of the 24th annual conference on<br>Computer graphics and interactive techniques. ACM Press&#x2F;AddisonWesley Publishing Co., 1997, pp. 209–216.</li>
<li>[7] P. Lindstrom and G. Turk, “Image-driven simplification,” ACM<br>Transactions on Graphics (ToG), vol. 19, no. 3, pp. 204–241, 2000</li>
</ul>
</blockquote>
<p>主要用了 [7] 中的 Image-driven simplification 的方法。这个方法是基于顶点对折叠的，每次折叠选择使 image error 升高最低的一对顶点。</p>
<blockquote>
<p><strong>QEM</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a><br><a target="_blank" rel="noopener" href="http://mgarland.org/research/quadrics.html">http://mgarland.org/research/quadrics.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lafengxiaoyu/article/details/72812681">https://blog.csdn.net/lafengxiaoyu/article/details/72812681</a></p>
<p>QEM 是 SIGGRAPH’97 提出的经典算法，截至现在已经有大约 5000 次引用。</p>
</blockquote>
<h4 id="交替优化-1"><a href="#交替优化-1" class="headerlink" title="交替优化"></a>交替优化</h4><p>给定网格 $ M $ 和 Shader $ S $，</p>
<ol>
<li>搞 Shader 优化 (然后生成一堆变体 $ S_i $)</li>
<li>对于每个在 Pareto frontier 上的 $ S_i $，利用该 Shader 进行相应的 Mesh 简化，使得新的 $ M_j $ 在满足质量要求 (也就是 error &lt;&#x3D; absolute error bound) 的情况下为最简<blockquote>
<p>Pareto frontier 上的 $ S_i $ 满足</p>
<ul>
<li>不存在另一个 Shader，他的性能一样，质量更好</li>
<li>不存在另一个 Shader，他的质量一样，性能更好</li>
</ul>
</blockquote>
</li>
<li>将这些 $ (M_j, S_i) $ 按渲染性能排序，取前 20% 作为种子进入下一轮迭代</li>
</ol>
<h3 id="分别优化"><a href="#分别优化" class="headerlink" title="分别优化"></a>分别优化</h3><h4 id="生成网格变体"><a href="#生成网格变体" class="headerlink" title="生成网格变体"></a>生成网格变体</h4><p>因为没有任何关于简化后 Shader 的信息，所以作者此处采用原 Shader 进行着色后 supersampled &#x2F; filtered 的图片作为 loss 环节进行网格简化。</p>
<p>因为某些边简化之后对视觉表现没有什么影响，所以这里只选取 K (实现中 K &#x3D; 500) 个有较大 error 变化的简化网格作为候选变体。</p>
<h4 id="生成-Shader-变体"><a href="#生成-Shader-变体" class="headerlink" title="生成 Shader 变体"></a>生成 Shader 变体</h4><p>理论上，对于不同的场景配置 (简化网格 &amp; 距离配置)，最优的 Shader 变体是不同的。</p>
<p>但是，因为</p>
<ol>
<li>First, as has been proven in prior work [3], the performance and error of shader variants can be predicted instead of being actually evaluated. In this way, we do not need to actually render every shader variant under all scene configurations.<blockquote>
<p>在 [3] 中，性能的预测是通过一种简单的启发函数，即 <code>scalar fp ops + 100 * texture ops</code> 来预测的（不同 Shader stage 有不同权重，parameter 数量有额外惩罚）</p>
<p>error 的评价是通过 error cache 和偶尔的重新 evaluate 来实现的</p>
</blockquote>
</li>
<li>Second, we noted that for one shader variant with one simplified mesh, the shading errors at distances could be approximated by filtering the rendered image at the closest distance.<blockquote>
<p>通过在最近距离生成着色结果，再进行 filter 来模拟在远处的结果</p>
</blockquote>
</li>
<li>Finally, we further observed that although these Pareto frontiers may change with scene configurations, the shader variants on Pareto frontiers are similar at similar distances and with similarly simplified meshes. <blockquote>
<p>Pareto 面上的 shader 变体基本上是比较稳定的，随着场景配置的变化不是很多</p>
</blockquote>
</li>
</ol>
<p>所以，作者最后只选择<strong>有代表性的距离</strong>和<strong>有代表性的简化网格</strong>来计算最优 Shader 变体，而不是穷举所有场景配置。</p>
<p>作者选择均匀的从 N 组距离组里面选择 4 组，然后每个距离组里面选择 10 个前面的简化网格（即 Pareto 面左右的十个），就得到了 40 个组合。然后用 genetic programming 的优化方法来得到每个 (距离, 网格) 组上的最优简化 Shader。这些优化好的 Shader 变体都放到一个数组里面。</p>
<p>然后，作者近似的认为整个问题是一个凸区域上找可行域边界的问题，所以只需要 1D search，而不需要遍历 2D 区域。</p>
<p>然后，再用 find smooth path 的技术来获得比较连续的 LOD transition。</p>
<blockquote>
<p>具体来说，就是每个边的权重是在边界处的图像损失，这样图像损失小的转换会更容易被选中。</p>
</blockquote>
<p>最后，合并区别不大的 LOD 组。</p>

      
     <!-- by blair add this if sentence at 20160725 -->
      <br>
      
<!-- <div id="bottom-donation-section"> -->
<!-- <span style="font-size: 1.0em; padding:0em 1em 0.5em 1em; margin: 0 auto;">
  <strong style="vertical-align: top;">分享到:</strong>
    <div class="j_handlclick"  style="background: url(/images/logos/share_facebook_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_twitter_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://twitter.com/intent/tweet?url=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_line_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.addtoany.com/add_to/line?linkurl=" target="_blank">
    </div>
    <div class="j_handlclick"  style="background: url(/images/logos/share_wechat_icon.jpg);background-size: contain;display: inline-block; width:50px; height:50px" href="https://api.addthis.com/oexchange/0.8/forward/wechat/offer?url=" target="_blank">
    </div>
  <br>  
  <br>  
  &nbsp;&nbsp;如果您觉得这篇文章对您的学习很有帮助, 请您也分享它, 让它能再次帮助到更多的需要学习的人.
您的<a href="/support/"><strong>支持</strong></a>将鼓励我继续创作 !
  <br>  

</span> -->
<!--
<h3 id="bottom-donation-title">支持 让文章变得更优质</h3>
<div>
<a id="bottom-donation-button" href="/support">点我 赞助 作者</a>
</div>
-->
<!-- </div> -->
<!-- <div class="well"> -->
  <!--
  原创文章，转载请注明： 转载自<a target="_blank" rel="noopener" href="http://52binge.github.io"> Blair Chan's Blog</a>，作者：
  <a href="/about">Blair Chan</a> <br>
  -->
  <!-- 本文基于<a target="_blank" title="Creative Commons Attribution 4.0 international License" href="https://creativecommons.org/licenses/by-nc/4.0/">署名4.0国际许可协议</a>发布，转载请保留本文署名和文章链接。 如您有任何授权方面的协商，请邮件联系我。 -->
<!-- </div> -->
 <!-- by blair add 160724-->
    
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-text">相关工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E8%A7%88"><span class="toc-text">方法总览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Formulation"><span class="toc-text">Formulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E4%BC%98%E5%8C%96"><span class="toc-text">交替优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shader-%E7%AE%80%E5%8C%96"><span class="toc-text">Shader 简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mesh-%E7%AE%80%E5%8C%96"><span class="toc-text">Mesh 简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E4%BC%98%E5%8C%96-1"><span class="toc-text">交替优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E4%BC%98%E5%8C%96"><span class="toc-text">分别优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E5%8F%98%E4%BD%93"><span class="toc-text">生成网格变体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90-Shader-%E5%8F%98%E4%BD%93"><span class="toc-text">生成 Shader 变体</span></a></li></ol></li></ol></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/paper-reading/cross-machine-black-box-GPU-perf-modeling/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">论文阅读 | 平衡精确度和预测范围的黑盒 GPU 性能建模&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Libre Liu&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true,
    },
    options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>
