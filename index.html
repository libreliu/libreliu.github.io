<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>libreliu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="libreliu&#39;s blog">
<meta property="og:url" content="https://blog.libreliu.info/">
<meta property="og:site_name" content="libreliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Libre Liu">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/logo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="libreliu's blog" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/paper-summary">Paper Reading</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.libreliu.info"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer">
      <article id="post-play-with-spirv" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/play-with-spirv/"><strong>SPIR-V 初探 (一) - Fragment Shader</strong></a>
      <small class=article-date-index>&nbsp; 2023-03-29</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/play-with-spirv/" class="article-date">
  <time datetime="2023-03-28T16:00:00.000Z" itemprop="datePublished">2023-03-29</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要关注 SPIR-V 1.6。</p>
<p>前面分支 &#x2F; 循环 &#x2F; 函数等测试主要是在 Fragment 这种 OpEntrypoint 下调用的子函数内部进行测试的。</p>
<p>下面的实验基本使用 <a target="_blank" rel="noopener" href="https://shader-playground.timjones.io/">Shader Playground</a> 的 glslang trunk (上面写使用的 2022-09-19 的版本)，其中：</p>
<ul>
<li>Shader stage 选择 <strong>frag</strong></li>
<li>Target 选择 Vulkan 1.3</li>
<li>Output format 选择 SPIR-V</li>
</ul>
<h3 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2">https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2</a></li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>通过例子来学习 SPIR-V 会比较快捷，也比较容易理解。</p>
<p>SPIR-V 本身是 SSA 形式的 IR，且指令 format 较为规整，易于解析 (虽然大家都是调库，也不会用手解析 SPIR-V 的)。</p>
<p>规范文档参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/">Khronos SPIR-V Registry</a></li>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html">SPIR-V Unified Specifications</a></li>
</ul>
<p>同时推荐用 <a target="_blank" rel="noopener" href="https://shader-playground.timjones.io/">Shader Playground</a> 来方便直接看到 SPIR-V Disassembly。</p>
<p>据博主本人测试，OpenAI 的 GPT-4 有<strong>不错</strong>的 SPIR-V 到 GLSL 反汇编能力。</p>
</blockquote>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>从反汇编结果可以看到，SPIR-V Module 有比较整齐的形式，事实上这些形式是规定好的：<a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_logical_layout_of_a_module">Logical Layout of a Module - SPIR-V Specification</a>。</p>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.6</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 6                                                  ; Bound; where all &lt;id&gt;s in this module are</span><br><span class="line">                                                            ; guaranteed to satisfy 0 &lt; id &lt; Bound</span><br><span class="line">; Schema: 0                                                 ; Instruction Schema; Reserved, not used for now</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450                ; Addressing model = Logical</span><br><span class="line">                                                            ; Logical 模式下面，指针只能从已有的对象中创建，指针的地址也都是假的</span><br><span class="line">                                                            ;   （也就是说，不能把指针的值拷贝到别的变量中去）</span><br><span class="line">                                                            ; 也有一些带有物理指针的 Addressing Model 和相应的 Memory Model</span><br><span class="line">                                                            ;   =&gt; 留待后文探索</span><br><span class="line">                                                            ; Memory Model = GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot;           ; Execution Model = Fragment</span><br><span class="line">                                                            ; Entrypoint = %main (用 OpFunction 定义的某个 Result ID)</span><br><span class="line">                                                            ; Name = &quot;main&quot; (Entrypoint 要有一个字符串名字)</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft        ; The coordinates decorated by FragCoord</span><br><span class="line">                                                            ; appear to originate in the upper left,</span><br><span class="line">                                                            ; and increase toward the right and downward.</span><br><span class="line">                                                            ; Only valid with the Fragment Execution Model.</span><br><span class="line">               OpSource ESSL 310                            ; 标记源语言; ESSL = OpenGL ES Shader Language</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会发现 %main 这个 result id 是在后面定义的，但是前面却引用到了。</p>
<p>对于 <code>SPV_OPERAND_TYPE_ID</code>, <code>SPV_OPERAND_TYPE_MEMORY_SEMANTICS_ID</code>, <code>SPV_OPERAND_TYPE_SCOPE_ID</code> 来说，正常都需要先定义（是某个指令的 result id）再引用，但是可以前向定义的指令除外。</p>
<p>可前向定义的指令可以参考 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/SPIRV-Tools/blob/1021ec302f568cd83fee9f4eaa763dadb66e40b0/source/val/validate_id.cpp#L49">source&#x2F;val&#x2F;validate_id.cpp:L122 @ SPIRV-Tools</a>，其中包括：</p>
<ul>
<li>全部的 <code>OpTypeXXX</code> 类指令</li>
<li>其它一大堆，主要是执行模式等 metadata、Decorate、分支、device side invoke 等<ul>
<li>可以参考 <code>spvOperandCanBeForwardDeclaredFunction (source/operand.cpp @ SPIRV-Tools)</code> 这个函数</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="简单的函数"><a href="#简单的函数" class="headerlink" title="简单的函数"></a>简单的函数</h3><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Circle</span><span class="params">( vec2 uv, vec2 p, <span class="type">float</span> r, <span class="type">float</span> blur )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = length(uv - p);</span><br><span class="line">    <span class="type">float</span> c = smoothstep(r, r-blur, d);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">%1 = OpExtInstImport &quot;GLSL.std.450&quot;                        ; 引入外部指令集</span><br><span class="line">%float = OpTypeFloat 32</span><br><span class="line">%v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Function_v2float = OpTypePointer Function %v2float</span><br><span class="line">%_ptr_Function_float = OpTypePointer Function %float       ; 定义指针类型，指向的变量的 Storage Class 为 Function</span><br><span class="line">%10 = OpTypeFunction %float %_ptr_Function_v2float %_ptr_Function_v2float %_ptr_Function_float %_ptr_Function_float</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line">%Circle_vf2_vf2_f1_f1_ = OpFunction %float None %10        ; 返回值类型 %float，Function Control 类型无</span><br><span class="line">                                                           ; 函数类型 %10 - float (vec2, vec2, float, float)</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float  ; 拿到各个 parameter 的 result id</span><br><span class="line">          %p = OpFunctionParameter %_ptr_Function_v2float  </span><br><span class="line">          %r = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">       %blur = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">         %16 = OpLabel                                     ; 一个基本块的开始 (2.2.5. Control Flow)</span><br><span class="line">          %d = OpVariable %_ptr_Function_float Function    ; 定义 float 变量, Storage Class 为 Function </span><br><span class="line">          %c = OpVariable %_ptr_Function_float Function    ; =&gt; 变量可以被 OpLoad / OpStore</span><br><span class="line">         %39 = OpLoad %v2float %uv                         ; 结果类型 %v2float, 装载 %uv 变量的值</span><br><span class="line">         %40 = OpLoad %v2float %p</span><br><span class="line">         %41 = OpFSub %v2float %39 %40                     ; Operand2 - Operand1，结果类型 %v2float</span><br><span class="line">         %42 = OpExtInst %float %1 Length %41              ; Execute an instruction in an imported set of extended instructions</span><br><span class="line">                                                           ; Set (也就是这里的 %1) is the result of an OpExtInstImport instruction.</span><br><span class="line">                                                           ; 后面的 Set 中的 Instruction 是 “Length”，操作数是 %41</span><br><span class="line">               OpStore %d %42                              ; 存到 %d 变量的存储中</span><br><span class="line">         %44 = OpLoad %float %r</span><br><span class="line">         %45 = OpLoad %float %r</span><br><span class="line">         %46 = OpLoad %float %blur</span><br><span class="line">         %47 = OpFSub %float %45 %46                       ; %blur - %r</span><br><span class="line">         %48 = OpLoad %float %d</span><br><span class="line">         %49 = OpExtInst %float %1 SmoothStep %44 %47 %48  ; SmoothStep(%r, %blur - %r, %d)</span><br><span class="line">               OpStore %c %49</span><br><span class="line">         %50 = OpLoad %float %c</span><br><span class="line">               OpReturnValue %50                           ; 不返回值的话使用 OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<h3 id="函数的-in-x2F-out-参数"><a href="#函数的-in-x2F-out-参数" class="headerlink" title="函数的 in &#x2F; out 参数"></a>函数的 in &#x2F; out 参数</h3><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inoutTest</span><span class="params">(in vec2 uv, out <span class="type">float</span> o1, in <span class="type">float</span> i2, out vec2 o2)</span> &#123;</span><br><span class="line">    o2 = uv;</span><br><span class="line">    o1 = i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">         %v1 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %t1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %t2 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %v2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">      %param = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">    %param_0 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %24 = OpLoad %v2float %v1</span><br><span class="line">               OpStore %param %24</span><br><span class="line">         %27 = OpLoad %float %t2</span><br><span class="line">               OpStore %param_1 %27</span><br><span class="line">         %29 = OpFunctionCall %void %inoutTest_vf2_f1_f1_vf2_ %param %param_0 %param_1 %param_2</span><br><span class="line">         %30 = OpLoad %float %param_0   ; 可以看到，就是实现了 %param_0 变量内值的变化</span><br><span class="line">               OpStore %t1 %30</span><br><span class="line">         %31 = OpLoad %v2float %param_2</span><br><span class="line">               OpStore %v2 %31</span><br><span class="line">               OpStore %fragColor %38</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br><span class="line">%inoutTest_vf2_f1_f1_vf2_ = OpFunction %void None %10</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line">         %o1 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %i2 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %o2 = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line"></span><br><span class="line">         %16 = OpLabel</span><br><span class="line">         %17 = OpLoad %v2float %uv</span><br><span class="line">               OpStore %o2 %17</span><br><span class="line">         %18 = OpLoad %float %i2</span><br><span class="line">               OpStore %o1 %18</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">testIf</span><span class="params">(<span class="type">float</span> range)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (range &lt; <span class="number">1.0</span>)</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line"> %testIf_f1_ = OpFunction %int None %22</span><br><span class="line">      %range = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %25 = OpLabel                                    ; 基本块开始</span><br><span class="line">        %c_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %c_0 %int_0</span><br><span class="line">         %68 = OpLoad %float %range                       </span><br><span class="line">         %71 = OpFOrdLessThan %bool %68 %float_1          ; check if %68 (loaded from %range) &lt; %float_1</span><br><span class="line">               OpSelectionMerge %73 None                  ; Declare a structured selection</span><br><span class="line">                                                          ; This instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.</span><br><span class="line">                                                          ; Selection Control = None; 这里可以给 Hint 提示此分支是否应该 remove</span><br><span class="line">                                                          ; 并且指定 Merge Block 为 %73，也就是分支结束的地方</span><br><span class="line">               OpBranchConditional %71 %72 %75            ; 如果 %71 为 true, 则跳到 %72 标号，否则跳到 %75 标号 - 标志基本块结束</span><br><span class="line">         %72 = OpLabel                                    ; </span><br><span class="line">               OpStore %c_0 %int_1</span><br><span class="line">               OpBranch %73                               ; Unconditional branch to %73</span><br><span class="line">         %75 = OpLabel</span><br><span class="line">               OpStore %c_0 %int_2</span><br><span class="line">               OpBranch %73</span><br><span class="line">         %73 = OpLabel</span><br><span class="line">         %77 = OpLoad %int %c_0</span><br><span class="line">               OpReturnValue %77</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>OpSelectionMerge</code></li>
<li><code>OpBranchConditional</code></li>
<li>两个基本块最后 <code>OpBranch</code> 到出口</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>Merge Instruction: <code>OpSelectionMerge</code> 或者 <code>OpLoopMerge</code> 两者之一，用在</li>
<li>Header Block: 包含 Merge Instruction 的 Block<ul>
<li>Loop Header: Merge Instruction 是 <code>OpLoopMerge</code> 的 Header Block</li>
<li>Selection Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpBranchConditional</code> 是终止指令的 Header Block</li>
<li>Switch Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpSwitch</code> 是终止指令的 Header Block</li>
</ul>
</li>
<li>Merge Block: 在 Merge Instruction 作为 Merge Block 操作数的 Block</li>
<li>Break Block: 含有跳转到被 Loop Header 的 Merge Instruction 定义为 Merge Block 的 Block</li>
<li>Continue Block: 含有跳转到 <code>OpLoopMerge</code> 指令的 Continue Target 的 Block</li>
<li>Return Block: 包含 <code>OpReturn</code> 或者 <code>OpReturnValue</code> 的 Block</li>
</ul>
<blockquote>
<p>GPT-4: 在 SPIR-V 中，Merge Block 是一个特定类型的基本块（Basic Block），用于控制流程结构中收敛控制流的位置。当你在 SPIR-V 中使用分支结构（如 if-else 语句、循环等）时，Merge Block 表示在这些分支结构末端的汇合点。</p>
<p>SPIR-V 中的控制流结构使用特殊的操作码（如 OpSelectionMerge、OpLoopMerge）来定义。这些操作码告诉编译器如何解释控制流图（Control Flow Graph，CFG）。Merge Block 用于表示这些控制流结构的结束位置，它是控制流从不同路径重新合并到一条路径的地方。例如，一个 if-else 语句会有两个分支，这两个分支在 Merge Block 之后合并为单个执行路径。</p>
</blockquote>
<h4 id="while-循环-无-break"><a href="#while-循环-无-break" class="headerlink" title="while 循环 - 无 break"></a>while 循环 - 无 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None                 ; Declare a structured loop.</span><br><span class="line">                                                        ; This instruction must immediately precede</span><br><span class="line">                                                        ; either an OpBranch or OpBranchConditional </span><br><span class="line">                                                        ; instruction. </span><br><span class="line">                                                        ; That is, it must be the second-to-last </span><br><span class="line">                                                        ; instruction in its block.</span><br><span class="line">                                                        ; Merge Block = %87</span><br><span class="line">                                                        ; Continue target = %88</span><br><span class="line">               OpBranch %89</span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0     ; 有符号比较; if %90 (=count) &gt;= %int_0 (0)</span><br><span class="line">               OpBranchConditional %91 %86 %87          ; %91 == true ? jump to %86 : jump to %87 (FINISH)</span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93                         ; sum = sum + 1</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95                       ; count = count - 1</span><br><span class="line">               OpBranch %88</span><br><span class="line">         %88 = OpLabel</span><br><span class="line">               OpBranch %85                             ; 无条件回到 Loop 头</span><br><span class="line">         %87 = OpLabel</span><br><span class="line">         %96 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %96</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>相当于翻译成了如下格式的 SPIR-V：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%header_block = OpLabel</span><br><span class="line">                OpLoopMerge %merge_block %continue_block</span><br><span class="line">                OpBranch %loop_body</span><br><span class="line"></span><br><span class="line">   %loop_test = OpLabel</span><br><span class="line">                OpLoopMerge %loop_merge %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cond = ...          ; Some calculations</span><br><span class="line">                OpBranchConditional %loop_cond %loop_body %loop_merge</span><br><span class="line">   </span><br><span class="line">   %loop_body = OpLabel</span><br><span class="line">                ...          ; Some codes inside loop body</span><br><span class="line">                OpBranch %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cont = OpLabel</span><br><span class="line">                OpBranch %loop_test</span><br><span class="line"></span><br><span class="line">  %loop_merge = OpLabel</span><br><span class="line">                ...          ; The &quot;following&quot; basic block</span><br></pre></td></tr></table></figure>

<h4 id="while-循环-带-break"><a href="#while-循环-带-break" class="headerlink" title="while 循环 - 带 break"></a>while 循环 - 带 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None</span><br><span class="line">               OpBranch %89</span><br><span class="line"></span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0</span><br><span class="line">               OpBranchConditional %91 %86 %87</span><br><span class="line"></span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95</span><br><span class="line">         %96 = OpLoad %int %count</span><br><span class="line">         %97 = OpIEqual %bool %96 %int_2</span><br><span class="line">               OpSelectionMerge %99 None              ; If 的 Merge Block = %99</span><br><span class="line">               OpBranchConditional %97 %98 %99</span><br><span class="line"></span><br><span class="line">         %98 = OpLabel</span><br><span class="line">               OpBranch %87                           ; =&gt; break out of the loop =&gt; emit instruction</span><br><span class="line">                                                      ;    to branch to while&#x27;s merge block</span><br><span class="line"></span><br><span class="line">         %99 = OpLabel                                ; 正常走 =&gt; 到达 while 末尾 =&gt; emit 到 while</span><br><span class="line">               OpBranch %88                           ; 的 Continue Block</span><br><span class="line"></span><br><span class="line">         %88 = OpLabel                                ; Continue Block </span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %87 = OpLabel                                ; Merge Block</span><br><span class="line">        %101 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %101</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>break 作为一个基本块末尾，直接 emit 无条件 branch 来跳到 while 循环的 merge block。</li>
</ul>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>GLSL 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testFor</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">%testFor_i1_ = OpFunction %int None %27</span><br><span class="line">    %count_0 = OpFunctionParameter %_ptr_Function_int</span><br><span class="line"></span><br><span class="line">         %33 = OpLabel</span><br><span class="line">      %sum_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">          %i = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum_0 %int_0</span><br><span class="line">               OpStore %i %int_0</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %109 = OpLabel</span><br><span class="line">               OpLoopMerge %111 %112 None</span><br><span class="line">               OpBranch %113</span><br><span class="line"></span><br><span class="line">        %113 = OpLabel</span><br><span class="line">        %114 = OpLoad %int %i</span><br><span class="line">        %115 = OpLoad %int %count_0</span><br><span class="line">        %116 = OpSLessThan %bool %114 %115</span><br><span class="line">               OpBranchConditional %116 %110 %111</span><br><span class="line"></span><br><span class="line">        %110 = OpLabel</span><br><span class="line">        %117 = OpLoad %int %sum_0</span><br><span class="line">        %118 = OpIAdd %int %117 %int_1</span><br><span class="line">               OpStore %sum_0 %118</span><br><span class="line">               OpBranch %112</span><br><span class="line"></span><br><span class="line">        %112 = OpLabel                              ; Continuation Block</span><br><span class="line">        %119 = OpLoad %int %i                       ; for 循环的循环结束操作放到了这里</span><br><span class="line">        %120 = OpIAdd %int %119 %int_1</span><br><span class="line">               OpStore %i %120</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %111 = OpLabel                              ; Merge Block</span><br><span class="line">        %121 = OpLoad %int %sum_0</span><br><span class="line">               OpReturnValue %121</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>Continuation Block 处现在 emit 了循环后维护操作</li>
</ul>
<h3 id="Uniform、BuiltIn-等其它-Scope-的变量"><a href="#Uniform、BuiltIn-等其它-Scope-的变量" class="headerlink" title="Uniform、BuiltIn 等其它 Scope 的变量"></a>Uniform、BuiltIn 等其它 Scope 的变量</h3><blockquote>
<p><code>OpSource</code>, <code>OpName</code>, <code>OpMemberName</code> 属于调试信息。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Anonymous uniform block - Import member names to shader directly</span></span><br><span class="line">layout(binding = <span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 outColor;</span><br><span class="line">layout(location = <span class="number">0</span>) in vec4 vertColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will not work:</span></span><br><span class="line"><span class="comment">// layout(binding = 0) uniform vec3 lightPos;</span></span><br><span class="line"><span class="comment">//  &#x27;non-opaque uniforms outside a block&#x27; : not allowed when using GLSL for Vulkan </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mainImage</span><span class="params">(out vec4 c, in vec2 f, in vec3 lightPos)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, lightPos);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input &#x2F; Output"></a>Input &#x2F; Output</h4><blockquote>
<p>所有可选 Decoration 可以参考 <a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration</a></p>
</blockquote>
<p>对于 gl_FragCoord：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">                      OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">      %gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure>

<p>对于 Input Variable：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %vertColor &quot;vertColor&quot;</span><br><span class="line">                      OpDecorate %vertColor Location 0</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">                      %vertColor = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure>

<p>对于 Output Variable：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                       OpName %outColor &quot;outColor&quot;</span><br><span class="line">                       OpDecorate %outColor Location 0</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">           %outColor = OpVariable %_ptr_Output_v4float Output</span><br></pre></td></tr></table></figure>

<p>使用时直接 <code>OpLoad</code> 就可以。</p>
<h4 id="Uniform-Block-Anonymous"><a href="#Uniform-Block-Anonymous" class="headerlink" title="Uniform Block (Anonymous)"></a>Uniform Block (Anonymous)</h4><blockquote>
<p>匿名的 Uniform Block，其成员是被引入了 Global Scope 的。</p>
<p>可以作为 OpenGL 的 uniforms outside a block 的平替。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniBlock &quot;uniBlock&quot;</span><br><span class="line">               OpMemberName %uniBlock 0 &quot;lightPos&quot;</span><br><span class="line">               OpMemberName %uniBlock 1 &quot;someOtherFloat&quot;</span><br><span class="line">               OpName %_ &quot;&quot;</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0             ; Structure type = %uniBlock</span><br><span class="line">                                                                 ; Member = 0</span><br><span class="line">                                                                 ; Decoration = Offset</span><br><span class="line">                                                                 ; Byte Offset = 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block                        ; Apply only to a structure type to establish</span><br><span class="line">                                                                 ; it is a memory interface block</span><br><span class="line">               OpDecorate %_ DescriptorSet 0                     ; Apply only to a variable. </span><br><span class="line">                                                                 ; Descriptor Set is an unsigned 32-bit integer </span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc. </span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">               OpDecorate %_ Binding 0                           ; Apply only to a variable.</span><br><span class="line">                                                                 ; Binding Point is an unsigned 32-bit integer</span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc.</span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float                      ; 后面指定所有成员的类型，这里是 &#123;vec3, float&#125;</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock         ; Storage Class = Uniform</span><br><span class="line">          %_ = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_v3float = OpTypePointer Uniform %v3float</span><br><span class="line"></span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %_ %int_0     ; Create a pointer into a composite object.</span><br><span class="line">                                                                 ; Base = %_, Indexes = &#123;%int_0&#125;</span><br><span class="line">                                                                 ; Each index in Indexes</span><br><span class="line">                                                                 ; - must have a scalar integer type</span><br><span class="line">                                                                 ; - is treated as signed</span><br><span class="line">                                                                 ; - if indexing into a structure, must be an </span><br><span class="line">                                                                 ;   OpConstant whose value is in bounds for selecting a member</span><br><span class="line">                                                                 ; - if indexing into a vector, array, or matrix, </span><br><span class="line">                                                                 ;   with the result type being a logical pointer type,</span><br><span class="line">                                                                 ;   causes undefined behavior if not in bounds.</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure>

<h4 id="Uniform-Block-Named"><a href="#Uniform-Block-Named" class="headerlink" title="Uniform Block (Named)"></a>Uniform Block (Named)</h4><p>把上面的示例程序里面的 <code>uniform uniBlock</code> 类型的不具名 Uniform Block 加一个实例名字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout(binding=<span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125; uniInst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..skip some lines..</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, uniInst.lightPos);&#125;</span><br></pre></td></tr></table></figure>

<p>下面是相关的 SPIR-V：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniInst &quot;uniInst&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block</span><br><span class="line">               OpDecorate %uniInst DescriptorSet 0</span><br><span class="line">               OpDecorate %uniInst Binding 0</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %uniInst %int_0</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure>

<p>可以看到，主要区别是 <code>%_</code> 变成了 <code>%uniInst</code>，其实就是 OpName 从 <code>&quot;&quot;</code> 变成了 <code>&quot;uniInst&quot;</code>，这样 SPIR-V 反汇编工具生成的反汇编能更好看一些而已。真正的 Result ID 等的逻辑关系都是没有变化的。</p>
<blockquote>
<p>当然，不知道反射库依赖不依赖 <code>OpName</code>，当然去掉了也不是没法反射就是了，只要 layout 一样，怼上去就得了。</p>
</blockquote>
<h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (binding = <span class="number">1</span>) uniform sampler2D samplerColor;</span><br><span class="line">layout (binding = <span class="number">2</span>) uniform texture2D tex;</span><br><span class="line">layout (binding = <span class="number">3</span>) uniform sampler samp;</span><br><span class="line">layout (location = <span class="number">0</span>) in vec2 inUV;</span><br><span class="line">layout (location = <span class="number">1</span>) in <span class="type">float</span> inLodBias;</span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    vec4 color = texture(samplerColor, inUV, inLodBias);</span><br><span class="line">      vec4 color2 = texture(sampler2D(tex, samp), inUV, inLodBias);</span><br><span class="line">    outFragColor = color + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 40</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %inUV %inLodBias %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %color &quot;color&quot;</span><br><span class="line">               OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">               OpName %inUV &quot;inUV&quot;</span><br><span class="line">               OpName %inLodBias &quot;inLodBias&quot;</span><br><span class="line">               OpName %color2 &quot;color2&quot;</span><br><span class="line">               OpName %tex &quot;tex&quot;</span><br><span class="line">               OpName %samp &quot;samp&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">               OpDecorate %samplerColor Binding 1</span><br><span class="line">               OpDecorate %inUV Location 0</span><br><span class="line">               OpDecorate %inLodBias Location 1</span><br><span class="line">               OpDecorate %tex DescriptorSet 0</span><br><span class="line">               OpDecorate %tex Binding 2</span><br><span class="line">               OpDecorate %samp DescriptorSet 0</span><br><span class="line">               OpDecorate %samp Binding 3</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Function_v4float = OpTypePointer Function %v4float</span><br><span class="line">         %10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">         %11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line">    %v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Input_v2float = OpTypePointer Input %v2float</span><br><span class="line">       %inUV = OpVariable %_ptr_Input_v2float Input</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line">  %inLodBias = OpVariable %_ptr_Input_float Input</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">        %tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line">         %27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">       %samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %color = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">     %color2 = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">         %14 = OpLoad %11 %samplerColor</span><br><span class="line">         %18 = OpLoad %v2float %inUV</span><br><span class="line">         %21 = OpLoad %float %inLodBias</span><br><span class="line">         %22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br><span class="line">               OpStore %color %22</span><br><span class="line">         %26 = OpLoad %10 %tex</span><br><span class="line">         %30 = OpLoad %27 %samp</span><br><span class="line">         %31 = OpSampledImage %11 %26 %30</span><br><span class="line">         %32 = OpLoad %v2float %inUV</span><br><span class="line">         %33 = OpLoad %float %inLodBias</span><br><span class="line">         %34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br><span class="line">               OpStore %color2 %34</span><br><span class="line">         %37 = OpLoad %v4float %color</span><br><span class="line">         %38 = OpLoad %v4float %color2</span><br><span class="line">         %39 = OpFAdd %v4float %37 %38</span><br><span class="line">               OpStore %outFragColor %39</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<ul>
<li>Sampler (<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpName %samp &quot;samp&quot;</span><br><span class="line">OpDecorate %samp DescriptorSet 0</span><br><span class="line">OpDecorate %samp Binding 3</span><br><span class="line"></span><br><span class="line">%27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">%samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br></pre></td></tr></table></figure></li>
<li>Sampled Image (<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OpName %tex &quot;tex&quot;</span><br><span class="line">OpDecorate %tex DescriptorSet 0</span><br><span class="line">OpDecorate %tex Binding 2</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">%tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%26 = OpLoad %10 %tex</span><br><span class="line">%30 = OpLoad %27 %samp</span><br><span class="line">%31 = OpSampledImage %11 %26 %30</span><br><span class="line">%32 = OpLoad %v2float %inUV</span><br><span class="line">%33 = OpLoad %float %inLodBias</span><br><span class="line">%34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br></pre></td></tr></table></figure></li>
<li>Combined Image Sampler (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">OpDecorate %samplerColor Binding 1</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%14 = OpLoad %11 %samplerColor</span><br><span class="line">%18 = OpLoad %v2float %inUV</span><br><span class="line">%21 = OpLoad %float %inLodBias</span><br><span class="line">%22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意关于 OpImage 和 OpSampledImage 的特殊规则：</p>
<ul>
<li>All <code>OpSampledImage</code> instructions must be in the same block in which their Result <code>&lt;id&gt;</code> are consumed. Result <code>&lt;id&gt;</code> from <code>OpSampledImage</code> instructions must not appear as operands to <code>OpPhi</code> instructions or <code>OpSelect</code> instructions, or any instructions other than the image lookup and query instructions specified to take an operand whose type is OpTypeSampledImage.</li>
<li>在 <code>spvtools::opt::InstrumentPass::MovePreludeCode @ source/opt/instrument_pass.cpp (SPIRV-Tools)</code> 中对该要求进行了处理。</li>
</ul>
</blockquote>
<h3 id="Storage-Buffer"><a href="#Storage-Buffer" class="headerlink" title="Storage Buffer"></a>Storage Buffer</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap14.html#descriptorsets-storagebuffer">14.1.7. Storage Buffer</a></p>
</blockquote>
<blockquote>
<p>我的一个疑惑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[]; </span><br><span class="line">    <span class="type">float</span> someEndingVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以，参考 https://github.com/KhronosGroup/SPIRV-Guide/blob/master/chapters/access_chains.md</span></span><br><span class="line"><span class="comment">// 的例子</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （应该）可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectData</span> &#123;</span></span><br><span class="line">    vec4 model;</span><br><span class="line">    <span class="type">float</span> moreData;</span><br><span class="line">    vec4 padThis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WritableData</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> testData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br><span class="line"></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">1</span>) buffer myWritableBufferType &#123;</span><br><span class="line">    WritableData datas[];</span><br><span class="line">&#125; writableBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="type">int</span>(gl_FragCoord.x * <span class="number">1000</span>);</span><br><span class="line">    outFragColor = objectBuffer.objects[index].model;</span><br><span class="line">    writableBuffer.datas[index].testData = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 42</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %gl_FragCoord %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %index &quot;index&quot;</span><br><span class="line">               OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpName %WritableData &quot;WritableData&quot;</span><br><span class="line">               OpMemberName %WritableData 0 &quot;testData&quot;</span><br><span class="line">               OpName %myWritableBufferType &quot;myWritableBufferType&quot;</span><br><span class="line">               OpMemberName %myWritableBufferType 0 &quot;datas&quot;</span><br><span class="line">               OpName %writableBuffer &quot;writableBuffer&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line">               OpMemberDecorate %WritableData 0 Offset 0</span><br><span class="line">               OpDecorate %_runtimearr_WritableData ArrayStride 4</span><br><span class="line">               OpMemberDecorate %myWritableBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %myWritableBufferType BufferBlock</span><br><span class="line">               OpDecorate %writableBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %writableBuffer Binding 1</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">%gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line"> %float_1000 = OpConstant %float 1000</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_v4float = OpTypePointer Uniform %v4float</span><br><span class="line">%WritableData = OpTypeStruct %float</span><br><span class="line">%_runtimearr_WritableData = OpTypeRuntimeArray %WritableData</span><br><span class="line">%myWritableBufferType = OpTypeStruct %_runtimearr_WritableData</span><br><span class="line">%_ptr_Uniform_myWritableBufferType = OpTypePointer Uniform %myWritableBufferType</span><br><span class="line">%writableBuffer = OpVariable %_ptr_Uniform_myWritableBufferType Uniform</span><br><span class="line">  %float_123 = OpConstant %float 123</span><br><span class="line">%_ptr_Uniform_float = OpTypePointer Uniform %float</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %index = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %16 = OpAccessChain %_ptr_Input_float %gl_FragCoord %uint_0</span><br><span class="line">         %17 = OpLoad %float %16</span><br><span class="line">         %19 = OpFMul %float %17 %float_1000</span><br><span class="line">         %20 = OpConvertFToS %int %19</span><br><span class="line">               OpStore %index %20</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br><span class="line">         %32 = OpLoad %v4float %31</span><br><span class="line">               OpStore %outFragColor %32</span><br><span class="line">         %38 = OpLoad %int %index</span><br><span class="line">         %41 = OpAccessChain %_ptr_Uniform_float %writableBuffer %int_0 %38 %int_0</span><br><span class="line">               OpStore %41 %float_123</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line"></span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable    ; 如果可变则无此 decorate</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData           ; Declare a new run-time array type.</span><br><span class="line">                                                                   ; Its length is not known at compile time.</span><br><span class="line">                                                                   ; See OpArrayLength for getting the Length</span><br><span class="line">                                                                   ; of an array of this type.</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line"></span><br><span class="line">; 访问</span><br><span class="line">; 使用 OpAccessChain 指令，该指令是 base, indices... 格式</span><br><span class="line">; 此例子： objectBuffer[0 th][index th][0 th] 来获得 model 的指针，该指针之后可以 load / store</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-操作"><a href="#Atomic-操作" class="headerlink" title="Atomic 操作"></a>Atomic 操作</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc">https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc</a></p>
</blockquote>
<p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) buffer statsBufferType &#123;</span><br><span class="line">    <span class="type">int</span> totalInvocations;</span><br><span class="line">&#125; statsBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// returns the value before the add</span></span><br><span class="line">    <span class="type">int</span> globalIdx = atomicAdd(statsBuffer.totalInvocations, <span class="number">1</span>);</span><br><span class="line">    outFragColor = vec4(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 26</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %globalIdx &quot;globalIdx&quot;</span><br><span class="line">               OpName %statsBufferType &quot;statsBufferType&quot;</span><br><span class="line">               OpMemberName %statsBufferType 0 &quot;totalInvocations&quot;</span><br><span class="line">               OpName %statsBuffer &quot;statsBuffer&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpMemberDecorate %statsBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %statsBufferType BufferBlock</span><br><span class="line">               OpDecorate %statsBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %statsBuffer Binding 0</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">%statsBufferType = OpTypeStruct %int</span><br><span class="line">%_ptr_Uniform_statsBufferType = OpTypePointer Uniform %statsBufferType</span><br><span class="line">%statsBuffer = OpVariable %_ptr_Uniform_statsBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_int = OpTypePointer Uniform %int</span><br><span class="line">      %int_1 = OpConstant %int 1</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_1 = OpConstant %uint 1</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line">         %25 = OpConstantComposite %v4float %float_1 %float_1 %float_1 %float_1</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">  %globalIdx = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %14 = OpAccessChain %_ptr_Uniform_int %statsBuffer %int_0</span><br><span class="line">         %19 = OpAtomicIAdd %int %14 %uint_1 %uint_0 %int_1             ; Pointer = %14</span><br><span class="line">                                                                        ; Memory Scope = %uint_1 = 1</span><br><span class="line">                                                                        ; =&gt; Scope is the current device</span><br><span class="line">                                                                        ; Semantics = %uint_0 = 0</span><br><span class="line">                                                                        ; =&gt; None (relaxed)</span><br><span class="line">                                                                        ; Value = %uint_1 = 1</span><br><span class="line">               OpStore %globalIdx %19</span><br><span class="line">               OpStore %outFragColor %25</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Memory Scope: <a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-</a></p>
</blockquote>
<h2 id="Coming-soon"><a href="#Coming-soon" class="headerlink" title="Coming soon"></a>Coming soon</h2><ul>
<li>Matrix 类型</li>
<li>导数 <code>dFdx</code> &#x2F; <code>dFdy</code> &amp; <code>discard</code><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/gpuweb/gpuweb/issues/361">https://github.com/gpuweb/gpuweb/issues/361</a></li>
<li><a target="_blank" rel="noopener" href="http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/">http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/</a></li>
</ul>
</li>
<li>Group Ops</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/auto-shader-mesh-lod" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/auto-shader-mesh-lod/"><strong>论文阅读 | Automatic Mesh and Shader Level of Detail</strong></a>
      <small class=article-date-index>&nbsp; 2023-02-21</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/auto-shader-mesh-lod/" class="article-date">
  <time datetime="2023-02-20T16:00:00.000Z" itemprop="datePublished">2023-02-21</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。</p>
<p>文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮后得到结果。</p>
<p>针对交替优化耗时较长的问题，文章中还提出了“分别优化”的算法。该算法会首先分别对网格和 Shader 独立的进行简化，得到一系列质量单调下降的 Shader 和网格变体列，然后再针对每个距离组选择合适的网格和 Shader 对。为了让 LOD 组间的变化尽可能平滑，文章还设置了最平滑的 LOD 切换路线的查找，以及 LOD 组数量的优化操作。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li>网格简化和 LOD 生成</li>
<li>Shader 简化和 LOD 生成</li>
<li>基于外观的联合优化</li>
</ul>
<h2 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>对于 Shader 和网格简化问题，定义三元组 $ (M_i, S_i, d_i) $，其中</p>
<ul>
<li>$ M_i $ 为原网格 $ M $ 的第 $ i $ 个简化变体</li>
<li>$ S_i $ 为原 Shader $ S $ 的第 $ i $ 个简化变体 </li>
<li>$ d_i $ 为距相机的距离</li>
</ul>
<p>定义 $ \epsilon_a(i) $ 为简化 $ (M_i, S_i, d_i) $ 变体的绝对图像误差，其定义为</p>
$$
\epsilon_a (i) = \int_H \| f(M_i, S_i, d_i) - \bar{f}(M, S, d_i) \| dH
$$

<p>这里的作为误差模型的积分域 $ H &#x3D; V \times U \times X \times Y $ ，其中</p>
<ul>
<li>$ V $ 为离散的若干个 view direction</li>
<li>$ U $ 若干 Shader uniform 参数，如光照方向</li>
<li>$ X \times Y $ 为图像空间的两个维度</li>
</ul>
<p>这里的范数是 pixelwise RGB $ L^2 $ 范数。</p>
<p>另外，定义 $ \epsilon_t(i) $ 为两个简化组之间的视觉差异：</p>
$$
\epsilon_t (i) = \int_H \| f(M_i, S_i, d_{i+1}) - f(M_{i+1}, S_{i+1}, d_{i+1}) \| dH
$$

<p>这样，LOD 优化问题就可以看作下面的数学问题：</p>
$$
\mathop{\arg \min}_{M_i, S_i, d_i} t = Cost ( f(M_i, S_i, d_i) ) \\
\mathrm{s.t.}\quad \epsilon_a(i) < e_a (d_i) \cdot s_{d_i}
$$

<p>其中 Cost 为在该网格上应用此 Shader 进行着色的时间开销，$ e_a (d_i) $ 为在 $ d_i $ 距离的 absolute per-pixel error bound， $ s_{d_i} $ 为距离 $ d_i $ 时网格 $ M_i $ 的投影大小，</p>
<p>其中 $ e_a(d) $ 采用前面工作提出的一个启发函数：</p>
$$
e_a(d) = (\frac{d-d_{near}}{d_{far} - d_{near}})^Q \cdot e_{max}
$$

<p>其中</p>
<ul>
<li>$ d_{near} $ 和 $ d_{far} $ 是设置的视景体参数</li>
<li>$ e_{max} $ 是 maximum absolute per pixel error bound<ul>
<li>也就是关于 $ e_t(i) $ 的积分项关于积分域里面各个部分的最大值</li>
</ul>
</li>
<li>$ Q \in [0, 1] $ 反映了对误差的容忍程度</li>
</ul>
<h3 id="交替优化"><a href="#交替优化" class="headerlink" title="交替优化"></a>交替优化</h3><h4 id="Shader-简化"><a href="#Shader-简化" class="headerlink" title="Shader 简化"></a>Shader 简化</h4><blockquote>
<p>这里的 Shader 简化工作主要参考了前面的文章：</p>
<ul>
<li>[3] Y. He, T. Foley, N. Tatarchuk, and K. Fatahalian, “A system for rapid, automatic shader level-of-detail,” ACM Trans. on Graph. (TOG), vol. 34, no. 6, p. 187, 2015.</li>
<li>[8] R. Wang, X. Yang, Y. Yuan, W. Chen, K. Bala, and H. Bao, “Automatic shader simplification using surface signal approximation,” ACM Trans. on Graph. (TOG), vol. 33, no. 6, p. 226, 2014.</li>
<li>[18] F. Pellacini, “User-configurable automatic shader simplification,”<br>ACM Trans. Graph., vol. 24, no. 3, pp. 445–452, 2005</li>
<li>[21] P. Sitthi-Amorn, N. Modly, W. Weimer, and J. Lawrence, “Genetic programming for shader simplification,” in ACM Transactions on Graphics (TOG), vol. 30, no. 6. ACM, 2011, p. 152.</li>
</ul>
</blockquote>
<ol>
<li>将 Vertex Shader 和 Fragment Shader 转换为抽象语法树 (AST) 和程序依赖图 (PDG)</li>
<li>应用不同的化简规则来生成简化 Shader<ul>
<li>Operation Removal: 将 $ op(a, b) $ 省略为 $ a $ 或 $ b $</li>
<li>Code Transformation: 将 per-pixel 的 pixel shader 操作移动到 per-vertex 或 per-tessellated-vertex 的操作来减少计算量</li>
<li>Moving to parameter: 将参数用其均值替换（$ n \to average(n) $），并且替换到 “parameter stage” 中进行计算（详见 [3]），并将均值作为结果送入 GPU Shader 中</li>
</ul>
</li>
</ol>
<blockquote>
<p>本文并没有对 Shader 本身的优化方面做出额外的创新。这些方法主要来源于 [3] 这篇文章。</p>
</blockquote>
<h4 id="Mesh-简化"><a href="#Mesh-简化" class="headerlink" title="Mesh 简化"></a>Mesh 简化</h4><blockquote>
<p>Mesh 简化工作：</p>
<ul>
<li>[4] M. Garland and P. S. Heckbert, “Surface simplification using<br>quadric error metrics,” in Proceedings of the 24th annual conference on<br>Computer graphics and interactive techniques. ACM Press&#x2F;AddisonWesley Publishing Co., 1997, pp. 209–216.</li>
<li>[7] P. Lindstrom and G. Turk, “Image-driven simplification,” ACM<br>Transactions on Graphics (ToG), vol. 19, no. 3, pp. 204–241, 2000</li>
</ul>
</blockquote>
<p>主要用了 [7] 中的 Image-driven simplification 的方法。这个方法是基于顶点对折叠的，每次折叠选择使 image error 升高最低的一对顶点。</p>
<blockquote>
<p><strong>QEM</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a><br><a target="_blank" rel="noopener" href="http://mgarland.org/research/quadrics.html">http://mgarland.org/research/quadrics.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lafengxiaoyu/article/details/72812681">https://blog.csdn.net/lafengxiaoyu/article/details/72812681</a></p>
<p>QEM 是 SIGGRAPH’97 提出的经典算法，截至现在已经有大约 5000 次引用。</p>
</blockquote>
<h4 id="交替优化-1"><a href="#交替优化-1" class="headerlink" title="交替优化"></a>交替优化</h4><p>给定网格 $ M $ 和 Shader $ S $，</p>
<ol>
<li>搞 Shader 优化 (然后生成一堆变体 $ S_i $)</li>
<li>对于每个在 Pareto frontier 上的 $ S_i $，利用该 Shader 进行相应的 Mesh 简化，使得新的 $ M_j $ 在满足质量要求 (也就是 error &lt;&#x3D; absolute error bound) 的情况下为最简<blockquote>
<p>Pareto frontier 上的 $ S_i $ 满足</p>
<ul>
<li>不存在另一个 Shader，他的性能一样，质量更好</li>
<li>不存在另一个 Shader，他的质量一样，性能更好</li>
</ul>
</blockquote>
</li>
<li>将这些 $ (M_j, S_i) $ 按渲染性能排序，取前 20% 作为种子进入下一轮迭代</li>
</ol>
<h3 id="分别优化"><a href="#分别优化" class="headerlink" title="分别优化"></a>分别优化</h3><h4 id="生成网格变体"><a href="#生成网格变体" class="headerlink" title="生成网格变体"></a>生成网格变体</h4><p>因为没有任何关于简化后 Shader 的信息，所以作者此处采用原 Shader 进行着色后 supersampled &#x2F; filtered 的图片作为 loss 环节进行网格简化。</p>
<p>因为某些边简化之后对视觉表现没有什么影响，所以这里只选取 K (实现中 K &#x3D; 500) 个有较大 error 变化的简化网格作为候选变体。</p>
<h4 id="生成-Shader-变体"><a href="#生成-Shader-变体" class="headerlink" title="生成 Shader 变体"></a>生成 Shader 变体</h4><p>理论上，对于不同的场景配置 (简化网格 &amp; 距离配置)，最优的 Shader 变体是不同的。</p>
<p>但是，因为</p>
<ol>
<li>First, as has been proven in prior work [3], the performance and error of shader variants can be predicted instead of being actually evaluated. In this way, we do not need to actually render every shader variant under all scene configurations.<blockquote>
<p>在 [3] 中，性能的预测是通过一种简单的启发函数，即 <code>scalar fp ops + 100 * texture ops</code> 来预测的（不同 Shader stage 有不同权重，parameter 数量有额外惩罚）</p>
<p>error 的评价是通过 error cache 和偶尔的重新 evaluate 来实现的</p>
</blockquote>
</li>
<li>Second, we noted that for one shader variant with one simplified mesh, the shading errors at distances could be approximated by filtering the rendered image at the closest distance.<blockquote>
<p>通过在最近距离生成着色结果，再进行 filter 来模拟在远处的结果</p>
</blockquote>
</li>
<li>Finally, we further observed that although these Pareto frontiers may change with scene configurations, the shader variants on Pareto frontiers are similar at similar distances and with similarly simplified meshes. <blockquote>
<p>Pareto 面上的 shader 变体基本上是比较稳定的，随着场景配置的变化不是很多</p>
</blockquote>
</li>
</ol>
<p>所以，作者最后只选择<strong>有代表性的距离</strong>和<strong>有代表性的简化网格</strong>来计算最优 Shader 变体，而不是穷举所有场景配置。</p>
<p>作者选择均匀的从 N 组距离组里面选择 4 组，然后每个距离组里面选择 10 个前面的简化网格（即 Pareto 面左右的十个），就得到了 40 个组合。然后用 genetic programming 的优化方法来得到每个 (距离, 网格) 组上的最优简化 Shader。这些优化好的 Shader 变体都放到一个数组里面。</p>
<p>然后，作者近似的认为整个问题是一个凸区域上找可行域边界的问题，所以只需要 1D search，而不需要遍历 2D 区域。</p>
<p>然后，再用 find smooth path 的技术来获得比较连续的 LOD transition。</p>
<blockquote>
<p>具体来说，就是每个边的权重是在边界处的图像损失，这样图像损失小的转换会更容易被选中。</p>
</blockquote>
<p>最后，合并区别不大的 LOD 组。</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/cross-machine-black-box-GPU-perf-modeling" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/cross-machine-black-box-GPU-perf-modeling/"><strong>论文阅读 | 平衡精确度和预测范围的黑盒 GPU 性能建模</strong></a>
      <small class=article-date-index>&nbsp; 2023-02-16</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/cross-machine-black-box-GPU-perf-modeling/" class="article-date">
  <time datetime="2023-02-15T16:00:00.000Z" itemprop="datePublished">2023-02-16</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章提出了一种跨机器，黑盒，基于微测试 (microbenchmark) 的方法来解析的对不同实现变体的 OpenCL kernel 的执行时间进行预测和最优 kernel 选择。</p>
<p>简单来说，本文大的思路是，收集一些 kernel 中出现的<strong>特征</strong>和对应特征在运行时会出现的<strong>频率</strong>，利用 microbenchmark 在目标平台上测量这些<strong>特征</strong>每次出现会花费的运行时间，再用一个（多重）线性模型来拟合最后的运行时间。</p>
<p>由于文章比较长，此处将文章的大概结构列举如下：</p>
<ul>
<li>Section 1: 简介</li>
<li>Section 2: 解释性的例子</li>
<li>Section 3: 本文贡献概况</li>
<li>Section 4: 本文采用的假设和局限性</li>
<li>Section 5: <strong>收集 kernel 统计信息</strong></li>
<li>Section 6: <strong>建模 kernel 执行时间</strong></li>
<li>Section 7: <strong>校准模型参数</strong></li>
<li>Section 8: 结果展示</li>
<li>Section 9: 作者调研到的、其它相关的性能建模方法</li>
</ul>
<h2 id="本文的假设和局限性"><a href="#本文的假设和局限性" class="headerlink" title="本文的假设和局限性"></a>本文的假设和局限性</h2><p>本文提到的一些 assumptions：</p>
<ul>
<li>(usefulness) 可以帮助用户理解给定机器的性能特性，并且给优化器提供变体性能数据预测参考，同时降低需要在目标系统实际测量的数据数量</li>
<li>(accuracy) 根据检索到的相关文献显示，在本文提及的 GPU kernel 性能预测问题上，没有方法可以一致的获得小于个位数的预测误差，所以本文也设定这样的目标</li>
<li>(cost-explanatory): 和其它基于排名的方法不同 (Chen et al. (2018))，虽然本文优化的目标是在各种变体中进行选择，但是本文中模型的主要输出为运行时间，且采用比较可解释的线性模型进行建模</li>
</ul>
<p>本文提到的一些局限：</p>
<ul>
<li>硬件资源的利用率：<ul>
<li>硬件资源的利用率会影响最终的性能。比如，峰值浮点性能受 SIMD lane 使用率影响，片上状态存储器 (VGPR, Scratchpad Memory) 会影响调度槽位的利用率，进而影响延迟隐藏的能力</li>
<li>不过，采用本文的方法，基本的性能损失系数是比较容易解释和估计的。比如，实际的内存带宽利用率，以及峰值 FLOP&#x2F;s</li>
<li>即使无法达到硬件资源的全部利用，对于硬件资源利用率随参数变化相对稳定的场合，本文的模型仍然可以适用。不过对于变化的情况，让本文提出的模型适用的唯一可行方法，就是将模型的粒度调低到类似 SIMD lane 的水平，这样利用率的变化就不再相关了。ECM 系列模型就是这样考虑这个问题的。<blockquote>
<p>?</p>
</blockquote>
</li>
<li>为了简化的处理这个问题，本文采用 workgroup size 恒定为 256 的参数设定。</li>
</ul>
</li>
<li>程序建模上的简化：<ul>
<li>本文的模型中，主要检测的是基于某种特殊类别的操作 (e.g. 浮点操作，特殊类型的访存) 和检测到该特征出现的次数，其中次数被建模为 non-data-dependent 的一个特征。<ul>
<li>Polyhedrally-given loop domain?</li>
</ul>
</li>
<li>所有分支指令都假设两个分支均会执行，即假设 GPU 采用 masking 的方式进行执行。<blockquote>
<p>文章认为这和 GPU 的行为是匹配的，不过显然不完全是。较新的 GPU 是同时支持 branching 和 masking 的。masking 存在的意义是对于短分支来说，可以不打断流水线。</p>
</blockquote>
</li>
</ul>
</li>
<li>内存访问开销评估：<ul>
<li>内存访问的开销受到程序访问的局部性，以及对于 banked memory 来说的 bank 竞争问题的影响。</li>
<li>本文将内存访问切分成了两种：<ul>
<li>对于各个程序都常见的，比较简单的访存模式，用 Section 6.1.1 的办法按 interlane stride, utilization radio 和 data width 进行分类<blockquote>
<p>quasi-affine? </p>
</blockquote>
</li>
<li>对于更复杂的访存模式，在 Section 7.1.1 中提供一种单独抽出来在循环里面按该模式进行访存，并且进行测量的机制</li>
</ul>
</li>
</ul>
</li>
<li>平台无关：<ul>
<li>本文提出的系统作用于 OpenCL 上，但是相似的系统在 CUDA 上也可以比较轻松的实现。</li>
</ul>
</li>
</ul>
<h2 id="收集-kernel-统计信息"><a href="#收集-kernel-统计信息" class="headerlink" title="收集 kernel 统计信息"></a>收集 kernel 统计信息</h2><h3 id="计算每个特征的预期出现次数"><a href="#计算每个特征的预期出现次数" class="headerlink" title="计算每个特征的预期出现次数"></a>计算每个特征的预期出现次数</h3><p>前面提到，本文假设程序中出现的所有循环，其循环次数和本次运行所使用的数据无关，即 non-data-dependent。</p>
<p>这种情况下，如果要求解循环体中每个语句的运行次数，简单的做法是将所有循环展开，不过这样效率会比较低。事实上，此处可以把问题看作：在 $ d $ 维的整数空间 $ \mathrm{Z}^d $ 中，可行区域是由一些约束条件构成的超平面截出来的一个子区域，某个语句的循环次数就是在该子区域中整数格点的数目。</p>
<p>文章汇总提到，用 <code>barvinok</code> 和 <code>isl</code> 库一起，可以解决前面这个数循环体内语句执行次数的问题，其中 <code>barvinok</code> 是基于 Barvinok 算法的，这是一个比较高效的、计算有理凸多胞形中的格点数目的算法。</p>
<p>当然，还要分析好一条语句内真正进行计算或数据搬运的相应特征和次数。</p>
<blockquote>
<p>为什么要抽象成有理凸多胞形？ 这是因为真正循环的次数和 Kernel 本身的一些参数，以及 Kernel 的 Launch parameters 也有关系，这里希望带着这些参数做符号计算，让模型更有用一些（比如说，优化这些参数会变得容易）</p>
</blockquote>
<h3 id="计数粒度-count-granularity"><a href="#计数粒度-count-granularity" class="headerlink" title="计数粒度 (count granularity)"></a>计数粒度 (count granularity)</h3><p>计数粒度设计的思路是，计数出来的次数尽可能贴近真实 GPU 硬件中所执行操作的次数。</p>
<p>比如，我们知道，在 OpenCL 的调度模型中，每个 <code>sub-group</code> 会尽可能匹配 GPU 调度的最小单位，并且视硬件能力 <code>sub-group</code> 内部会支持一些 reduce 和 scatter 等原语，并且算数指令一般也是以 <code>sub-group</code> 为粒度进行调度和实现的。这样，算术指令就应该以 <code>sub-group</code> 为粒度计数。</p>
<p>当然，具体 <code>sub-group</code> 的数目是依赖具体的 Kernel launch parameters 的，不过这里对前面参数的依赖是多项式形式的 (比如 <code>work-group count / 32</code>），所以可以作为一个含参的量，让前面的循环次数计算也成为一个含参的值。</p>
<!-- TOOD: check this paragraph -->

<p>粒度有如下三种：</p>
<ul>
<li>per work-item<ul>
<li>同步障操作 (barrier synchronization)</li>
</ul>
</li>
<li>per sub-group （subgroup size 需要用户提供）<ul>
<li>片上操作：算数指令和 local memory 访问</li>
<li>uniform 访问：global memory 访问，但是 <code>lid(0)</code> stride 0，即多个线程访问同一块内存区域</li>
</ul>
</li>
<li>per work-group （没有给出例子）</li>
</ul>
<blockquote>
<p>这里的讨论很不详细，需要和下面一起看</p>
</blockquote>
<h2 id="建模-kernel-执行时间"><a href="#建模-kernel-执行时间" class="headerlink" title="建模 kernel 执行时间"></a>建模 kernel 执行时间</h2>$$
T_\text{wall}({\bf n}) = \text{feat}^\text{out}({\bf n}) \approx g(\text{feat}^\text{in}_0({\bf n}), ..., \text{feat}^\text{in}_j({\bf n}), p_0, ..., p_k)
$$

<p>其中：</p>
<ul>
<li>$ {\bf n} $ 是整个计算过程中为常数的、仅与各种变体相关的整数向量</li>
<li>$ \text{feat}^\text{in}_j({\bf n}) $ 是某种单元特征的出现次数（比如单精度 FP32 乘法数）</li>
<li>$ p_i $ 是硬件相关的校正参数</li>
<li>$ g $ 是用户提供的可微函数</li>
</ul>
<h3 id="kernel-特征"><a href="#kernel-特征" class="headerlink" title="kernel 特征"></a>kernel 特征</h3><h4 id="数据移动特征"><a href="#数据移动特征" class="headerlink" title="数据移动特征"></a>数据移动特征</h4><p>对于大多数计算 kernel 来说，数据搬运所占的开销是大头。</p>
<p>内存访问模式：</p>
<ul>
<li>内存类别：global &#x2F; local</li>
<li>访问类型：load &#x2F; store</li>
<li>the local and global strides along each thread axis in the array index<ul>
<li>也就是说，每次 <code>gid(0)</code>, <code>gid(1)</code>, <code>lid(0)</code>, <code>lid(1)</code> 自增一的时候，对 array 数组访问的偏移要分别增加多少</li>
</ul>
</li>
<li>the ratio of the number of element accesses to the number of elements accessed (access-to-footprint ratio, or AFR)<ul>
<li><code>AFR = 1</code>: every element in the footprint is accessed one time</li>
<li><code>AFR &gt; 1</code>: some elements are accessed more than once<ul>
<li>这样 Cache 就可能会对速度有加成了</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>文章中提到，解析形式的模型需要建模很多机器细节，比如 workgroup 调度，内存系统架构等，来达到和黑盒模型相似的精度。一个例子是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k_out = <span class="number">0</span>; k_out &lt;= ((<span class="number">-16</span> + n) / <span class="number">16</span>); ++k_out)</span><br><span class="line">  ...</span><br><span class="line">  a_fetch[...] = a[n*(<span class="number">16</span>*gid(<span class="number">1</span>) + lid(<span class="number">1</span>)) + <span class="number">16</span>*k_out + lid(<span class="number">0</span>)];</span><br><span class="line">  b_fetch[...] = b[n*(<span class="number">16</span>*k_out + lid(<span class="number">1</span>)) + <span class="number">16</span>*gid(<span class="number">0</span>) + lid(<span class="number">0</span>)];</span><br></pre></td></tr></table></figure>

<p>这个例子里面的内存访问模式如下：</p>
<table>
<thead>
<tr>
<th>Array</th>
<th>Ratio</th>
<th>Local strides</th>
<th>Global strides</th>
<th>Loop stride</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>n&#x2F;16</td>
<td>{0:1, 1:n}</td>
<td>{0:0, 1:n*16}</td>
<td>16</td>
</tr>
<tr>
<td>b</td>
<td>n&#x2F;16</td>
<td>{0:1, 1:n}</td>
<td>{0:16, 1:0}</td>
<td>16*n</td>
</tr>
</tbody></table>
<p>这两个例子的性能差距在 5 倍左右。</p>
</blockquote>
<p>With this approach, a universal model for all kernels on all hardware based on kernel-level features like ours  could need a prohibitively large number of global memory access features and corresponding measurement kernels. This motivates our decision to allow proxies of “in-situ” memory accesses to be included as features, which in turn motivates our ‘work removal’ code transformation, discussed in Section 7.1.1. This transformation facilitates generation of microbenchmarks exercising memory accesses which match the access patterns found in specific computations by stripping away unrelated portions of the computation in an automated fashion.</p>
<p>Specifying Data Motion Features in the Model: 弄个 aLD, bLD, f_mem_access_tag</p>
<p>也可以手动指定，不用运行时测量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Model(</span><br><span class="line">  <span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>显式语法格式如下：<code>&quot;f_mem_access_tag:&lt;mem access tag&gt;_&lt;mem type&gt;_&lt;data type&gt;_&lt;direction&gt;_lstrides:&#123;&lt;local stride constraints&gt;&#125;_gstrides:&#123;&lt;global stride constraints&gt;&#125;_afr:&lt;AFR constraint&gt;&quot;</code></p>
<h4 id="算术操作特征"><a href="#算术操作特征" class="headerlink" title="算术操作特征"></a>算术操作特征</h4><p>特征：</p>
<ul>
<li>操作类型：加法、乘法、指数</li>
<li>数据类型：float32, float64</li>
</ul>
<p>本文中的工作不考虑整数算术特征，因为在模型考虑的 kernel 变体中，整数算术只用在了数组下标计算中。</p>
<h4 id="同步特征"><a href="#同步特征" class="headerlink" title="同步特征"></a>同步特征</h4><p>特征：</p>
<ul>
<li>局部同步障 (local barriers)</li>
<li>kernel 启动</li>
</ul>
<p>这里 Local barriers 是 per work-item 的，然后根据实际程序同步的需要，可能需要进行乘以同时进行同步的 work item 数量。</p>
<p>简单来说就是，认为参与同步的 thread 越多越耗时。</p>
<blockquote>
<p>Recall that the statistics gathering module counts the number of synchronizations encountered by a single work-item, so depending on how a user intends to model execution, they may need to multiply a synchronization feature like local barriers by, e.g., the number of work-groups, a feature discussed in the next section.</p>
<p>A user might incorporate synchronization features into this model as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h3><ul>
<li>Thread groups feature<ul>
<li>给定 workgroup count，进行不同 workgroup count 间启动时间补偿</li>
</ul>
</li>
<li>OpenCL wall time feature<ul>
<li>给定 platform 和 device 下，执行 60 遍获得平均 walltime，作为输出特征</li>
<li>“We measure kernel execution time excluding any host-device transfer of data.”</li>
</ul>
</li>
</ul>
<p>一个完整的模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_group * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="校准模型参数"><a href="#校准模型参数" class="headerlink" title="校准模型参数"></a>校准模型参数</h2><p>Work Removal Transformation: a code transformation that can extract a set of desired operations from a given computation, while maintaining overall loop structure and sufficient data flow to avoid elimination of further parts of the computation by optimizing compilers</p>
<p>Work Removal 变换会把 on-chip 工作从 kernel 中去掉，达成两方面目的：</p>
<ol>
<li>测试 on-chip work 和 global memory access 各自占用时间，决定是否要进行 latency hiding</li>
<li>测试某种特殊访存模型的时间占用</li>
</ol>
<h3 id="Measurement-kernel-设计"><a href="#Measurement-kernel-设计" class="headerlink" title="Measurement kernel 设计"></a>Measurement kernel 设计</h3><ul>
<li>Global memory access<ul>
<li>AFR &#x3D; 1: Fully specified by local strides, global strides, data size<ul>
<li>That is, patterns that do not produce a write race and not nested inside sequential loops</li>
<li>Performs global load from each of <em>a variable number of input arrays</em> using the specified access pattern</li>
<li>Each work-item then stores the sum of the input array values it fetched in a single result array</li>
<li>Params: data type, global memory array size, work-group dimensions, number of input arrays, thread index strides</li>
</ul>
</li>
<li>AFR &gt; 1:<ul>
<li>Use <strong>Work Removal Tranformation</strong> to generate dedicated measurement kernel.</li>
</ul>
</li>
</ul>
</li>
<li>Arithmetic operations<ul>
<li>First, have each work-item initialize 32 private variables of the specified data type</li>
<li>Then, perform a loop in which each iteration updates each variable using the target arithmetic operation on values from other variables<ul>
<li>This is to create structural dependency</li>
</ul>
</li>
<li>We <strong>unroll the loop by a factor of 64</strong> and <strong>arrange the variable assignment order</strong> to achieve high throughput using the approach found in the Scalable HeterOgeneous Computing (SHOC) OpenCL MaxFlops.cpp benchmark (Danalis et al. 2010).<ul>
<li>the 32 variable updates are ordered so that <strong>no assignment depends on the most recent four statements</strong><ul>
<li>32 is used because it permits maximum SIMD lane utilization &amp; prevent from spilling too many registers</li>
</ul>
</li>
<li>we <strong>sum</strong> the 32 variable values and <strong>store the result in a global array</strong> according to a <strong>user-specified memory access pattern</strong><ul>
<li>(NOTE: The actual cost can be deduced by change the runcount of arithmetic ops)</li>
<li>include the global store to avoid being optimized away</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Local memory access<ul>
<li>Tags: data type, global memory array size, iteration count, and workgroup dimensions<ul>
<li>Data type determines the local data stride</li>
</ul>
</li>
</ul>
<ol>
<li>each workitem <strong>initializes one element of a local array</strong> to the data type specified</li>
<li>Then we have it perform a loop, at each iteration moving a different element from one location in the array to another. <ul>
<li>We avoid write-races and simultaneous reads from a single memory location, and use an lid(0) stride of 1, avoiding bank conflicts.</li>
</ul>
</li>
<li>After the loop completes, <strong>each work-item writes one value from the shared array to global memory</strong></li>
</ol>
</li>
<li>Other features<ul>
<li>executes a variable number of local barriers, to measure operation overlapping behaviour (<strong>Section 7.4</strong>)</li>
<li>Empty kernel launch, to measure kernel launching overhead</li>
</ul>
</li>
</ul>
<p>文章提出，<em>Using a sufficiently high-fidelity model, we expect that users will be able to differentiate between latency-based costs of a single kernel launch and throughput-related costs that would be incurred in pipelined launches.</em></p>
<blockquote>
<p>怎么做？</p>
</blockquote>
<h3 id="计算模型参数"><a href="#计算模型参数" class="headerlink" title="计算模型参数"></a>计算模型参数</h3><p>采用最小二乘法来进行拟合，得到 feature 向量中给定 feature 的出现次数和总的运行时间的关系。</p>
<h3 id="Operation-Overlap-建模"><a href="#Operation-Overlap-建模" class="headerlink" title="Operation Overlap 建模"></a>Operation Overlap 建模</h3><p>Global memory 和 On-chip 的延迟之间是有可能互相隐藏的。</p>
<p>本文的建模基于简单的想法，即 $ \max (c_{onchip}, c_{gmem}) $，两类操作的时间求 $ \max $ 操作。</p>
<p>不过 $ \max $ 不是很可导，所以采用一个可微的近似函数来做，详情可以看论文。</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/learning-from-program-traces" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/learning-from-program-traces/"><strong>论文阅读 | Learning from Shader Program Traces</strong></a>
      <small class=article-date-index>&nbsp; 2023-01-03</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/learning-from-program-traces/" class="article-date">
  <time datetime="2023-01-02T16:00:00.000Z" itemprop="datePublished">2023-01-03</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Program trace<ul>
<li>In software engineering, a trace refers to the record of all states that a program visits during its execution, including all instructions and data.</li>
<li>本文提到的 Shader program trace，只包括中间结果 (<strong>data</strong>)，而不包括程序序列 (<strong>instruction</strong>)。</li>
</ul>
</li>
</ul>
<p>Since the fragment shader program operates independently per pixel, we can consider the full program trace as a vector of values computed at each pixel – a generalization from simple RGB.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>输入是用（嵌入到 Python 的） DSL 写的 fragment procedural shader program，翻译成 Tensorflow 程序<ul>
<li>可以同时输出渲染好的图片和生成的 program trace</li>
<li>分支展开、循环 unroll</li>
<li>These policies permit us to express the trace of any shader as a fixed-length vector of the computed scalar values, regardless of the pixel location</li>
</ul>
</li>
</ul>
<h3 id="输入特征化简"><a href="#输入特征化简" class="headerlink" title="输入特征化简"></a>输入特征化简</h3><ul>
<li>编译器优化<ul>
<li>忽略常量值、计算图上重复的节点，因为其在不同 pixel 位置的运行结果应该高度统一</li>
</ul>
</li>
<li>不生成内建函数的 trace</li>
<li>检测并筛除迭代改进模式的循环中的中间 trace 结果<ul>
<li>比如，raymarching 找 closest intersection 的迭代</li>
</ul>
</li>
<li>均匀的特征下采样<ul>
<li>The most straightforward strategy is to subsample the vector by some factor n, retaining only every nth trace feature as ordered in a depth first traversal of the compute graph</li>
</ul>
</li>
<li>其它采样方案 (都不太好用)<ul>
<li>clustering</li>
<li>loop subsampling</li>
<li>first or last</li>
<li>mean and variance</li>
</ul>
</li>
</ul>
<p>We <strong>first apply compiler optimizations</strong>, then <strong>subsample the features with a subsampling rate that makes the trace length be most similar to a fixed target length</strong>.</p>
<p>For all experiments, we target a length of 200, except where specifically noted such as in the simulation example. </p>
<p>After compiling and executing the shader, we have <strong>for every pixel: a vector of dimension N</strong>: the number of recorded intermediate values in the trace</p>
<h3 id="特征白化"><a href="#特征白化" class="headerlink" title="特征白化"></a>特征白化</h3><p>主要是为了解决 shader trace 里面的异常值，防止干扰训练和推理。用的是 Scaling + clamping。</p>
<ul>
<li>Check if the distribution merits clamping<ul>
<li>If N &lt;&#x3D; 10, no need to clamp</li>
<li>Else, do clamp<ul>
<li>Discard NaN, Inf, -Inf</li>
<li>let $P_0$ &#x3D; Lowest p’th percentile, $P_1$ &#x3D; highest p’th percentile, superparam $ \gamma $</li>
<li>Clamp to $ [P_0 − \gamma(P_1− P_0), P_1 + \gamma(P_1 − P_0)] $</li>
</ul>
</li>
<li>Do rescale<ul>
<li>for each intermediate feature, rescale the clamped values to the fixed range $ [-1,1] $</li>
<li>Record the bias and scale used (in rescaling)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The scale and bias is recorded and used in both training and testing, but the values will be clamped to range<br>[-2, 2] to allow data extrapolation.</p>
<blockquote>
<p>感觉有点乱…</p>
</blockquote>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>1x1 Conv + Feature Reduction (N &#x3D; 200 -&gt; K &#x3D; 48) </li>
<li>1x1 Conv * 3</li>
<li>Dilated Convolution (1, 2, 4, 8, 1)</li>
<li>1x1 Conv * 3 </li>
<li>1x1 Conv + Feature Reduction (K &#x3D; 48 -&gt; 3, that is, RGB color output)</li>
</ul>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>$ L_b = L_c + \alpha L_p $</p>
<ul>
<li>$ L_c $ 是 RGB 图像上的标准 $ L_2 $ loss</li>
<li>$ L_p $ 是 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1801.03924">The Unreasonable Effectiveness of Deep Features as a Perceptual Metric</a> 这篇文章中给出的损失函数度量 LPIPS<ul>
<li>大概就是，做了一个图像相似数据集，弄了很多 distortions 和 CNN 常见任务输出的图片，做 2AFC 和 JND，随后学习这个 metric</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/162070277">深度特征度量图像相似度的有效性——LPIPS</a> 这篇知乎文章比较不错</li>
</ul>
</li>
</ul>
<p>下面还有个 Appendix D，里面有实验的 GAN 的 loss</p>
<h4 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h4><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>和一个 Baseline 方法 RGBx 对比，这个 Baseline 用的手挑特征 normal, depth, diffuse, specular color (<em>where applicable</em>) 来作为输入进行学习。</p>
<h3 id="Denoising-fragment-shaders"><a href="#Denoising-fragment-shaders" class="headerlink" title="Denoising fragment shaders"></a>Denoising fragment shaders</h3><p>目标是用 1spp 图像来学习 1000spp 的 reference image。</p>
<h3 id="Reconstructing-simplified-shaders"><a href="#Reconstructing-simplified-shaders" class="headerlink" title="Reconstructing simplified shaders"></a>Reconstructing simplified shaders</h3><p>这个任务是，从简化后的 Shader 的运行结果中，重建原来 Shader 的运行结果。</p>
<p>简化 Shader 采用的是 Loop perforation 和 Genetic Programming Simplification。</p>
<p>用两个 Conditional GAN，分别称为 Spatial GAN 和 Temporal GAN，一个用来从 1spp 的图 $ c_x $ 生成 Ground Truth (原来的 Shader 运行结果) $ c_y $，另一个用来从前面三帧的 1spp 输出 + 前面两帧的 Spatial GAN 的生成器的输出来生成下一帧，也就是用序列 $ \tilde {c_x} $ 生成序列 $ \tilde {c_y} $。</p>
<blockquote>
<p>GAN related:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/301309418">四天搞懂生成对抗网络（一）——通俗理解经典GAN</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/302720602">四天搞懂生成对抗网络（二）——风格迁移的“精神始祖”Conditional GAN</a></li>
</ul>
</blockquote>
<h3 id="Postprocessing-filters"><a href="#Postprocessing-filters" class="headerlink" title="Postprocessing filters"></a>Postprocessing filters</h3><p>学习一些后处理效果的 Shader，如 edge-aware sharpening filter 和 defocus blur 效果。</p>
<h3 id="Learning-to-approximate-simulation"><a href="#Learning-to-approximate-simulation" class="headerlink" title="Learning to approximate simulation"></a>Learning to approximate simulation</h3><p>学习一些进行模拟的 Shader 将来的运行结果。</p>
<h2 id="Trace-有效性分析"><a href="#Trace-有效性分析" class="headerlink" title="Trace 有效性分析"></a>Trace 有效性分析</h2><p>这里主要做了两件事：</p>
<ol>
<li>哪些 Input feature 比较重要？<ul>
<li>这里作者采用求 Loss 关于 input trace feature 的一阶导数来评价重要性</li>
</ul>
</li>
<li>挑一个 Subset 来做训练？<ul>
<li>给定 m 个 feature 的训练 budget，如果要评价任意的 subset，即从 N 个里面抽 m 个来做训练的话，开销太大<ul>
<li>Oracle: 按 1 中所述重要性评分的前 m 个 input trace feature</li>
<li>Opponent: 按 1 中所述重要性评分的后 m 个 input trace feature</li>
<li>Uniform: 随便挑 m 个</li>
</ul>
</li>
<li>发现 Oracle &gt; Opponent &gt; Uniform</li>
</ul>
</li>
<li>多个 Shader 一起学习<ul>
<li>多个 Shader 一起学习降噪任务，感觉就像训练一个真·denoiser</li>
</ul>
</li>
</ol>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-example-vulkan-app-flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/example-vulkan-app-flow/"><strong>一个示例 Vulkan 程序的全流程记录</strong></a>
      <small class=article-date-index>&nbsp; 2022-12-29</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/example-vulkan-app-flow/" class="article-date">
  <time datetime="2022-12-28T16:00:00.000Z" itemprop="datePublished">2022-12-29</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>一些有用的链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/blog/understanding-vulkan-synchronization">Khronos Blog - Understanding Vulkan Synchronization</a></li>
<li><a target="_blank" rel="noopener" href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/">Yet another blog explaining Vulkan synchronization - Maister’s Graphics Adventures</a></li>
</ul>
</blockquote>
<p>本文主要分析 <a target="_blank" rel="noopener" href="https://github.com/glfw/glfw">glfw</a> 库的 <a target="_blank" rel="noopener" href="https://github.com/glfw/glfw/blob/57cbded0760a50b9039ee0cb3f3c14f60145567c/tests/triangle-vulkan.c">tests&#x2F;triangle-vulkan.c</a> 文件。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><blockquote>
<p>Update 2023-02-13: 补上了漏掉的创建逻辑设备的一步 vkCreateDevice</p>
</blockquote>
<ul>
<li>demo_init<ul>
<li>demo_init_connection<ul>
<li>glfwSerErrorCallback</li>
<li>gladLoadVulkanUserPtr: 设定 glad 使用 glfwGetInstanceProcAddress 来装载所有的 Vulkan 函数指针地址</li>
</ul>
</li>
<li>demo_init_vk<ul>
<li>启用验证层:<ul>
<li>vkEnumerateInstanceLayerProperties</li>
<li>demo_check_layers: 检查需要的验证层集合是否存在</li>
</ul>
</li>
<li>glfwGetRequiredInstanceExtensions: 获得需要的平台 Surface 扩展</li>
<li>准备启用的 Instance 扩展列表<ul>
<li>VK_EXT_debug_report</li>
<li>VK_KHR_portability_enumeration</li>
</ul>
</li>
<li>vkCreateInstance</li>
<li>vkEnumeratePhysicalDevices</li>
<li>检查设备是否支持 VK_KHR_swapchain<ul>
<li>vkEnumerateDeviceExtensionProperties</li>
</ul>
</li>
<li>vkCreateDebugReportCallbackEXT</li>
<li>vkGetPhysicalDeviceProperties</li>
<li>vkGetPhysicalDeviceQueueFamilyProperties</li>
<li>vkGetPhysicalDeviceFeatures</li>
</ul>
</li>
</ul>
</li>
<li>demo_create_window<ul>
<li>glfwWindowHint</li>
<li>glfwCreateWindow</li>
<li>glfwSetWindowUserPointer</li>
<li>glfwSetWindowRefreshCallback</li>
<li>glfwSetFramebufferSizeCallback</li>
<li>glfwSetKeyCallback</li>
</ul>
</li>
<li>demo_init_vk_swapchain<ul>
<li>glfwCreateWindowSurface<ul>
<li>内部调用 vkCreateWin32SurfaceKHR</li>
</ul>
</li>
<li>查找支持 Present 和 Graphics 的 Queue，需要是同一个 Queue<ul>
<li>vkGetPhysicalDeviceSurfaceSupportKHR</li>
<li><code>queueFlags &amp; VK_QUEUE_GRAPHICS_BIT</code></li>
</ul>
</li>
<li>demo_init_device<ul>
<li>vkCreateDevice: 创建 logical device<ul>
<li>VkDeviceCreateInfo<ul>
<li><code>.pQueueCreateInfos</code><ul>
<li><code>.queueFamilyIndex</code></li>
<li><code>.queueCount</code></li>
<li><code>.pQueuePriorities</code></li>
</ul>
</li>
<li><code>.ppEnabledLayerNames</code></li>
<li><code>.ppEnabledExtensionNames</code>: 要启用的设备扩展<blockquote>
<p>似乎把 Instance 扩展的名字扔进去也行？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkGetDeviceQueue</li>
<li>选择一个最优的 Surface format<ul>
<li>vkGetPhysicalDeviceSurfaceFormatsKHR</li>
</ul>
</li>
<li>vkGetPhysicalDeviceMemoryProperties</li>
</ul>
</li>
<li>demo_prepare<ul>
<li>创建 Command Pool<ul>
<li>vkCreateCommandPool</li>
</ul>
</li>
<li>分配一个 Command Buffer<ul>
<li>vkAllocateCommandBuffers<ul>
<li>VkCommandBufferAllocateInfo:<ul>
<li><code>.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY</code></li>
<li><code>.commandBufferCount = 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_buffers<ul>
<li>检查 Surface Capabilities 和 Present Modes<ul>
<li>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</li>
<li>vkGetPhysicalDeviceSurfacePresentModesKHR</li>
</ul>
</li>
<li>创建交换链<ul>
<li>计算 Swapchain Image Extent</li>
<li><code>.preTransform</code> 使用 <code>VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code>，如果没有则使用当前 Surface Transform</li>
<li><code>.minImageCount</code> 使用 Surface Capabilities 的 minImageCount</li>
<li><code>.presentMode</code> 选择 <code>VK_PRESENT_MODE_FIFO_KHR</code></li>
<li>vkCreateSwapchainKHR</li>
<li>如果有老的交换链： vkDestroySwapchainKHR</li>
<li>vkGetSwapchainImagesKHR 拿到 VkImage 格式的交换链图像</li>
<li>为每个交换链图像调用 vkCreateImageView 创建 Color Attachment View<blockquote>
<p>Componet Swizzle: TODO check spec</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_depth<ul>
<li>vkCreateImage 创建 depth image<ul>
<li><code>.arrayLayers</code> 可以指定 texture array 的 dimension</li>
</ul>
</li>
<li>vkGetImageMemoryRequirements 获得 image 的内存要求</li>
<li>选择内存大小和内存类型<ul>
<li>memory_type_from_properties : todo check this</li>
</ul>
</li>
<li>vkAllocateMemory 分配 image 所需内存，返回 VkDeviceMemory</li>
<li>vkBindImageMemory 将分配的 VkDeviceMemory 绑定到 VkImage</li>
<li>demo_set_image_layout<ul>
<li>如果 <code>demo-&gt;setup_cmd</code> 为空，则<ul>
<li>调用 vkAllocateCommandBuffers 从 <code>demo-&gt;cmd_pool</code> 中分配 <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> 的 Buffer</li>
<li>vkBeginCommandBuffer</li>
</ul>
</li>
<li>准备 Image Memory Barrier<ul>
<li>VkImageMemoryBarrier<ul>
<li><code>.srcAccessMask = 0</code><ul>
<li>不需要给 src stage 的任何读&#x2F;写操作 made coherent</li>
</ul>
</li>
<li><code>.dstAccessMask</code>:<ul>
<li>对于 <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>，设置为 <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code></li>
</ul>
</li>
<li><code>.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED</code>，也就是垃圾数据</li>
<li><code>.newLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
</ul>
</li>
</ul>
</li>
<li>录制 Pipeline Barrier<ul>
<li>vkCmdPipelineBarrier<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是 wait for nothing</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是任何下面的指令在开始前都需要等待 Barrier 执行完</li>
<li>同时传入前面的 Image Mmeory Barrier</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkCreateImageView 创建深度缓冲对应图像的 ImageView</li>
</ul>
</li>
<li>demo_prepare_textures<ul>
<li>vkGetPhysicalDeviceFormatProperties 获得 <code>VK_FORMAT_B8G8R8A8_UNORM</code> 的 VkFormatProperties</li>
<li>对于每张 texture<blockquote>
<p>用 <code>texture_object</code> 来管理每个 texture</p>
<ul>
<li>VkSampler sampler</li>
<li>VkImage iamge;</li>
<li>VkImageLayout imageLayout;</li>
<li>VkDeviceMemory mem;</li>
<li>VkImageView view;</li>
<li>int32_t tex_width, tex_height;</li>
</ul>
</blockquote>
<ul>
<li>如果 sampler 支持（对此种 format 的）线性分块 <code>(props.linearTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul>
<li>demo_prepare_texture_image with required_props &#x3D; <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code><ul>
<li>vkCreateImage</li>
<li>vkGetImageMemoryRequirements</li>
<li>memory_type_from_properties<ul>
<li>对设备支持的每种内存类型，枚举其是否符合前面 <code>required_props</code> 的要求</li>
</ul>
</li>
<li>vkAllocateMemory</li>
<li>vkBindImageMemory</li>
<li>如果 memory type 有性质 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code><ul>
<li>vkGetImageSubresourceLayout</li>
<li>vkMapMemory: 映射到地址空间</li>
<li>填充之</li>
<li>vkUnmapMemory</li>
</ul>
</li>
<li>设置 image layout (前面分析过)<ul>
<li><code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> -&gt; <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code></li>
<li>demo_set_image_layout</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果 sampler 不支持对此种 format 的线性分块，但支持 optimal 分块 <code>(props.optimalTilingFeatures &amp;  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul>
<li>分别准备 host coherent 和 host visible 的 staging texture 和 GPU device local 的 texture<ul>
<li>demo_prepare_texture_image * 2<ul>
<li>这里 device local 的显然没能力初始化</li>
</ul>
</li>
<li>注意 memory props</li>
</ul>
</li>
<li>改 layout 以便使用 transfer 命令<ul>
<li>staging texture: VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</li>
<li>device local texture: VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</li>
</ul>
</li>
<li>vkCmdCopyImage</li>
<li>将 device local texture 的 layout 改回来<ul>
<li>demo_set_image_layout</li>
</ul>
</li>
<li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul>
<li>vkEndCommandBuffer</li>
<li>vkQueueSubmit<ul>
<li>no wait &#x2F; signal semaphores</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkFreeCommandBuffers</li>
<li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li>
</ul>
</li>
<li>demo_destroy_texture_image 销毁 staging texture</li>
</ul>
</li>
<li>创建对应的 sampler 和 Image View<ul>
<li>vkCreateSampler</li>
<li>vkCreateImageView</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_vertices<blockquote>
<p>这里直接用了 Host visible &amp; Host coherent 的 memory 作为 vertex buffer<br>而不是 Device local 的，然后单开 staging buffer 做拷贝.</p>
<p>应该是偷懒了.jpg</p>
</blockquote>
<ul>
<li>vkCreateBuffer<ul>
<li>with <code>.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code></li>
</ul>
</li>
<li>vkGetBufferMemoryRequirements</li>
<li>memory_type_from_properties</li>
<li>vkAllocateMemory</li>
<li>vkMapMemory</li>
<li>vkUnmapMemory</li>
<li>vkBindBufferMemory</li>
<li>配置一些结构体<ul>
<li>VkPipelineVertexInputStateCreateInfo<ul>
<li>VkVertexInputBindingDescription</li>
<li>VkVertexInputAttributeDescription</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_layout<ul>
<li>vkCreateDescriptorSetLayout<ul>
<li>VkDescriptorSetLayoutCreateInfo</li>
<li><code>.pBindings = &amp;layout_binding</code><ul>
<li>layout_binding: 设置每个 binding 的位置都放什么 - 可以为数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const VkDescriptorSetLayoutBinding layout_binding = &#123;</span><br><span class="line">  .binding = 0,</span><br><span class="line">  .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,</span><br><span class="line">  .descriptorCount = DEMO_TEXTURE_COUNT,</span><br><span class="line">  .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">  .pImmutableSamplers = NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
See also: <a target="_blank" rel="noopener" href="https://vkguide.dev/docs/chapter-4/descriptors/">https://vkguide.dev/docs/chapter-4/descriptors/</a></li>
</ul>
</li>
</ul>
</li>
<li>vkCreatePipelineLayout<ul>
<li>VkPipelineLayoutCreateInfo: <code>demo-&gt;pipeline_layout</code><ul>
<li>指定了到 Descriptor Set Layouts 的数量和数组指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_render_pass<ul>
<li>vkCreateRenderPass<ul>
<li>VkRenderPassCreateInfo<ul>
<li><code>.pAttachments</code>: VkAttachmentDescription<ul>
<li><code>[0]</code>: Color Attachment<ul>
<li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code> 图像的 sample 数</li>
<li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code> color &amp; depth 内容在 subpass 开始时如何处理</li>
<li><code>.storeOp = VK_ATTACHMENT_STORE_OP_STORE</code> color &amp; depth 内容在 subpass 结束后如何处理</li>
<li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code> stencil 内容在 subpass 开始时如何处理</li>
<li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code> stencil 内容在 subpass 结束时如何处理</li>
<li><code>.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 开始前 image subresource 的 layout</li>
<li><code>.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 结束后 image subresource 将会被自动转换到的 layout</li>
</ul>
</li>
<li><code>[1]</code>: Depth Stencil Attachment<ul>
<li><code>.format = demo-&gt;depth.format</code></li>
<li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code></li>
<li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code></li>
<li><code>.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li>
<li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code></li>
<li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li>
<li><code>.initialLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
<li><code>.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pSubpasses</code>: VkSubpassDescription<blockquote>
<p>A single render pass can consist of multiple subpasses. Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. <a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes">Render passes - Vulkan Tutorial</a></p>
</blockquote>
<ul>
<li><code>.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code> 该 subpass 支持的 pipeline 类型</li>
<li><code>.pInputAttachments = NULL</code></li>
<li><code>.pColorAttachments = &amp;color_reference</code><ul>
<li><code>VkAttachmentReference &#123;.attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[0]</code></li>
</ul>
</li>
<li><code>.pDepthStencilAttachment = &amp;depth_reference</code><ul>
<li><code>VkAttachmentReference &#123;.attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[1]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pDependencies</code>: VkSubpassDependency 有多个 subpass 时指定 subpass 间的读写依赖关系<blockquote>
<p>和 vkCmdPipelineBarrier + VkMemoryBarrier 差不多，区别只是同步作用域限于指定的 subpass 间，而非所有在前在后的操作 (<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#VkSubpassDependency">Vulkan Spec</a>)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_pipeline<ul>
<li>vkCreatePipelineCache: (<em>optional</em> for pipeline creation)<blockquote>
<p>主要用来供实现缓存编译好的 Pipeline; 可以使用 allocator 限制其缓存数据的大小; 可以创建时导入之前 (应用程序) 的 Cache 等</p>
</blockquote>
</li>
<li>vkCreateGraphicsPipelines<ul>
<li>VkGraphicsPipelineCreateInfo<ul>
<li><code>.layout = demo-&gt;pipeline_layout</code></li>
<li><code>.pVertexInputState</code>: VkPipelineVertexInputStateCreateInfo<ul>
<li>已经在 <code>demo_prepare_vertices</code> 中准备好</li>
</ul>
</li>
<li><code>.pInputAssemblyState</code>: VkPipelineInputAssemblyStateCreateInfo<ul>
<li><code>.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code></li>
</ul>
</li>
<li><code>.pRasterizationState</code>: VkPipelineRasterizationStateCreateInfo<ul>
<li><code>.polygonMode = VK_POLYGON_MODE_FILL</code></li>
<li><code>.cullMode = VK_CULL_MODE_BACK_BIT</code></li>
<li><code>.frontFace = VK_FRONT_FACE_CLOCKWISE</code><ul>
<li>front-facing triangle orientation to be used for culling</li>
</ul>
</li>
<li><code>.depthClampEnable = VK_FALSE</code><ul>
<li>不启用深度截断</li>
</ul>
</li>
<li><code>.rasterizerDiscardEnable = VK_FALSE</code><ul>
<li>是否在光栅化阶段前立即丢弃片元</li>
</ul>
</li>
<li><code>.depthBiasEnable = VK_FALSE</code></li>
<li><code>.lineWidth = 1.0f</code><ul>
<li>光栅化线段宽度</li>
</ul>
</li>
</ul>
</li>
<li><code>.pColorBlendState</code>: VkPipelineColorBlendStateCreateInfo<ul>
<li><code>.pAttachments</code>: VkPipelineColorBlendAttachmentState，对每个 color attachment 定义 blend state<ul>
<li><code>[0]</code><ul>
<li><code>.colorWriteMask = 0xf</code><ul>
<li>写入 RGBA 全部四个通道 (<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap29.html#framebuffer-color-write-mask">Vulkan Spec</a>)</li>
</ul>
</li>
<li><code>.blendEnable = VK_FALSE</code><ul>
<li>不启用 Blending，直接写入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>.pMultisampleState</code>: VkPipelineMultisampleStateCreateInfo<ul>
<li><code>.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT</code></li>
<li><code>.pSampleMask = NULL</code></li>
</ul>
</li>
<li><code>.pViewportState</code>: VkPipelineViewportStateCreateInfo<ul>
<li><code>.viewportCount = 1</code></li>
<li><code>.scissorCount = 1</code></li>
<li>不过这里用的 <strong>Dynamic State</strong>，也就是 Viewport 和 Scissor 的信息是在录制 Command Buffer 时提供的，创建 Pipeline 时不提供<ul>
<li>详情看 <code>.pDynamicState</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pDepthStencilState</code>: VkPipelineDepthStencilStateCreateInfo<ul>
<li><code>.depthTestEnable = VK_TRUE</code></li>
<li><code>.depthWriteEnable = VK_TRUE</code></li>
<li><code>.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL</code></li>
<li><code>.depthBoundsTestEnable = VK_FALSE</code><ul>
<li>Samples coverage &#x3D; 0 if outside the bound predetermined</li>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap28.html#fragops-dbt">28.8. Depth Bounds Test</a></li>
</ul>
</li>
<li><code>.stencilTestEnable = VK_FALSE</code> 下面都是 Stencil test 的参数</li>
<li><code>.back.failOp = VK_STENCIL_OP_KEEP</code></li>
<li><code>.back.passOp = VK_STENCIL_OP_KEEP</code></li>
<li><code>.back.compareOp = VK_COMPARE_OP_ALWAYS</code></li>
<li><code>.front = ds.back</code></li>
</ul>
</li>
<li><code>.pStages</code>: VkPipelineShaderStageCreateInfo<ul>
<li><code>[0]</code><ul>
<li><code>.stage = VK_SHADER_STAGE_VERTEX_BIT</code></li>
<li><code>.pName = &quot;main&quot;</code></li>
<li><code>.module = demo_prepare_vs(demo)</code><ul>
<li>Call demo_prepare_shader_module with vert SPIR-V code<ul>
<li>vkCreateShaderModule with <code>size_t codeSize</code> &amp; <code>uint32_t *pCode</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>[1]</code><ul>
<li><code>.stage = VK_SHADER_STAGE_FRAGMENT_BIT</code></li>
<li><code>.pName = &quot;main&quot;</code></li>
<li><code>.module = demo_prepare_fs(demo)</code><ul>
<li>Similar with above</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>.pDynamicState</code>: VkPipelineDynamicStateCreateInfo<ul>
<li><code>.pDynamicStates = dynamicStateEnables</code><ul>
<li>启用了 <code>VK_DYNAMIC_STATE_VIEWPORT</code> 和 <code>VK_DYNAMIC_STATE_SCISSOR</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.renderPass</code>: VkRenderPass<br>传入之前创建的 VkRenderPass</li>
</ul>
</li>
</ul>
</li>
<li>vkDestroyPipelineCache</li>
<li>vkDestroyShaderModule * 2<ul>
<li>删除 vs 和 fs 的两个刚才创建的 Shader Module (<code>demo_prepare_vs</code> &#x2F; <code>demo_prepare_fs</code>)</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_pool<ul>
<li>vkCreateDescriptorPool<ul>
<li>VkDescriptorPoolCreateInfo<ul>
<li><code>.pPoolSizes = &amp;type_count</code><ul>
<li>VkDescriptorPoolSize<ul>
<li><code>.type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li>
<li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_set<ul>
<li>vkAllocateDescriptorSets：按 Descriptor Set Layouts 从 Descriptor Pool 中分配 Descriptor Sets<ul>
<li><code>.pSetLayouts = &amp;demo-&gt;desc_layout</code></li>
<li><code>.descriptorPool = demo-&gt;desc_pool</code></li>
</ul>
</li>
<li>vkUpdateDescriptorSets<br>支持 Write 和 Copy 两种形式的 Descriptor Set 更新请求<ul>
<li>VkWriteSescriptorSet<ul>
<li><code>.dstSet = demo-&gt;desc_set</code> 刚分配的 Descriptor Set</li>
<li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li>
<li><code>.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li>
<li><code>.pImageInfo = tex_descs</code><ul>
<li>VkDescriptorImageInfo: 具体的 Descriptor 内容<ul>
<li><code>.sampler = demo-&gt;textures[i].sampler</code></li>
<li><code>.imageView = demo-&gt;textures[i].view</code></li>
<li><code>.imageLayout = VK_IMAGE_LAYOUT_GENERAL</code><blockquote>
<p>感觉这里应该是选对应的才对，不知道这样可以不可以</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_framebuffers<ul>
<li>创建 <code>demo-&gt;swapchainImageCount</code> 个 VkFramebuffer<ul>
<li>vkCreateFramebuffer<ul>
<li>VkFramebufferCreateInfo<ul>
<li><code>.renderPass = demo-&gt;renderpass</code></li>
<li><code>.pAttachments</code>: VkImageView[]<ul>
<li><code>[0]</code>: Color Attachment, <code>demo-&gt;buffers[i].view</code><ul>
<li>That is, the swapchain image view</li>
</ul>
</li>
<li><code>[1]</code>: Depth Attachment<ul>
<li><code>demo-&gt;depth.view</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.width</code>, <code>.height</code></li>
<li><code>.layers = 1</code><blockquote>
<p>正如 VkImage 创建时也可以选择多 layer 一样，这里也可以；不过 Shader 默认写入第一层，除了 Geometry Shader</p>
<p>多 layer 的 Image &#x2F; Framebuffer 在 Shader 里面是用的 texture array 的语法来访问的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_run<ul>
<li>glfwWindowShouldClose: 检测窗口的 closing 标志</li>
<li>glfwPollEvent</li>
<li>demo_draw<ul>
<li>vkCreateSemaphore: <code>imageAcquiredSemaphore</code></li>
<li>vkCreateSemaphore: <code>drawCompleteSemaphore</code></li>
<li>vkAcquireNextImageKHR<blockquote>
<p>这里有一个问题，这里返回并不意味着 Present 完成 (推荐做法是 Present 设置 Semaphore，然后等 Semaphore)</p>
<p>那么，什么情况下这里会 block？<br>也可以参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64150186/lets-get-swapchains-image-count-straight">Let’s get swapchain’s image count straight - StackOverflow</a></p>
</blockquote>
<ul>
<li><code>timeout = UINT64_MAX</code></li>
<li><code>semaphore = imageAcquiredSemaphore</code></li>
<li><code>pImageIndex = &amp;demo-&gt;current_buffer</code>: index of the next image to use<ul>
<li>完成后会 signal 该 semaphore</li>
</ul>
</li>
<li>返回值<ul>
<li>VK_ERROR_OUT_OF_DATE_KHR<ul>
<li>demo_resize: 处理 resize 情况：<strong>Destroy everything</strong><ul>
<li>vkDestroyFramebuffer</li>
<li>vkDestroyDescriptorPool</li>
<li>vkFreeCommandBuffers</li>
<li>vkDestroyCommandPool</li>
<li>vkDestroyPipeline</li>
<li>vkDestroyRenderPass</li>
<li>vkDestroyPipelineLayout</li>
<li>vkDestroyDescriptorSetLayout</li>
<li>vkDestroyBuffer (vertex buffer)</li>
<li>vkFreeMemory (vertex buffer memory)</li>
<li>vkDestroyImageView</li>
<li>vkDestroyImage</li>
<li>vkDestroySampler</li>
<li>…</li>
<li>call <code>demo_prepare</code></li>
</ul>
</li>
<li>demo_draw: 重复调用一下自己</li>
</ul>
</li>
<li>VK_SUBOPTIMAL_KHR: 不是最优，但是也能 present，所以不管</li>
</ul>
</li>
</ul>
</li>
<li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul>
<li>vkEndCommandBuffer</li>
<li>vkQueueSubmit<ul>
<li>no wait &#x2F; signal semaphores</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkFreeCommandBuffers</li>
<li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li>
</ul>
</li>
<li>demo_draw_build_cmd<ul>
<li>vkBeginCommandBuffer: <code>demo-&gt;draw_cmd</code></li>
<li>vkCmdPipelineBarrier<ul>
<li>Execution barrier 部分<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)<blockquote>
<p><code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> is equivalent to <code>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code> with VkAccessFlags set to 0 when specified in the first synchronization scope, but specifies no stage of execution when specified in the second scope.</p>
</blockquote>
</li>
</ul>
</li>
<li>Memory barrier 部分: 对 color attachment 做 layout transition<ul>
<li>从 <code>VK_IMAGE_LAYOUT_UNDEFINED</code> -&gt; <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li>
<li><code>.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBeginRenderPass with <code>VK_SUBPASS_CONTENTS_INLINE</code><blockquote>
<p><code>VK_SUBPASS_CONTENTS_INLINE</code> specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers must not be executed within the subpass.</p>
</blockquote>
<ul>
<li>VkRenderPassBeginInfo<ul>
<li><code>.renderPass</code></li>
<li><code>.framebuffer</code> - 选择<strong>当前</strong>的 framebuffer，我们有 <code>swapchainImageCount</code> 个</li>
<li><code>.renderArea</code><ul>
<li><code>.offset.&#123;x, y&#125;</code></li>
<li><code>.extent.&#123;width, height&#125;</code></li>
</ul>
</li>
<li><code>.pClearValues = clear_values</code> (VkClearValue)<blockquote>
<p>这里是和 RenderPassCreateInfo 指定的 attachments 相对应的</p>
<p><code>pClearValues</code> is a pointer to an array of <code>clearValueCount</code> VkClearValue structures containing clear values for each attachment, if the attachment uses a <code>loadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> or if the attachment has a depth&#x2F;stencil format and uses a <code>stencilLoadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.</p>
</blockquote>
<ul>
<li><code>[0] = &#123;.color.float32 = &#123;0.2f, 0.2f, 0.2f, 0.2f&#125;&#125;</code></li>
<li><code>[1] = &#123;.depthStencil = &#123;demo-&gt;depthStencil, 0&#125;&#125;</code><ul>
<li><code>demo-&gt;depthStencil</code> 用来加一个“无形的墙”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBindPipeline<ul>
<li><code>pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code></li>
</ul>
</li>
<li>vkCmdBindDescriptorSets<ul>
<li><code>layout = demo-&gt;pipeline_layout</code><br>Recall: Pipeline layout &lt;&#x3D; Descriptor Set Layouts</li>
<li>Descriptor Sets</li>
</ul>
</li>
<li>vkCmdSetViewport<ul>
<li>VkViewport<ul>
<li><code>.height</code>, <code>.width</code>, <code>.minDepth</code>, <code>.maxDepth</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdSetScissor<ul>
<li>VkRect2D<ul>
<li><code>.extent.&#123;width, height&#125;</code></li>
<li><code>.offset.&#123;x, y&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBindVertexBuffers<blockquote>
<p>看 <a target="_blank" rel="noopener" href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp</a> 可能会印象更深刻</p>
</blockquote>
<ul>
<li>firstBinding 参数用于 (CPU 端) 指定绑定到哪里</li>
</ul>
</li>
<li>vkCmdDraw<ul>
<li><code>vertexCount = 3</code></li>
<li><code>instanceCount = 1</code></li>
<li><code>firstVertex = 0</code></li>
<li><code>firstInstance = 0</code></li>
</ul>
</li>
<li>vkCmdEndRenderPass</li>
<li>vkCmdPipelineBarrier<ul>
<li>Execution barrier:<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)</li>
</ul>
</li>
<li>Memory barrier:<blockquote>
<p>正如 transfer，present 也需要 layout 改变</p>
</blockquote>
<ul>
<li><code>.srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li>
<li><code>.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT</code></li>
<li><code>.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li>
<li><code>.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code></li>
</ul>
</li>
</ul>
</li>
<li>vkEndCommandBuffer: <code>demo-&gt;draw_cmd</code></li>
</ul>
</li>
<li>vkQueueSubmit<ul>
<li><code>.pCommandBuffers = &amp;demo-&gt;draw_cmd</code></li>
<li><code>.pWaitSemaphores = &amp;imageAcquiredSemaphore</code></li>
<li><code>.pWaitDstStageMask = &amp;pipe_stage_flags</code><ul>
<li><code>pWaitDstStageMask</code> is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.</li>
<li>这里设置成了 <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code></li>
<li>所以，相当于啥也没等</li>
</ul>
</li>
<li><code>.pSignalSemaphores = &amp;drawCompleteSemaphore</code></li>
</ul>
</li>
<li>vkQueuePresentKHR<ul>
<li>VkPresentInfoKHR<ul>
<li><code>.pWaitSemaphores = &amp;drawCompleteSemaphore</code></li>
<li><code>.pSwapchains = &amp;demo-&gt;swapchain</code><ul>
<li>可以多个，用来支持多个 swapchain 用一个 queue present 操作进行 present</li>
</ul>
</li>
<li><code>.pImageIndices = &amp;demo-&gt;current_buffer</code></li>
</ul>
</li>
<li>返回值<ul>
<li>VK_ERROR_OUT_OF_DATE_KHR<ul>
<li>demo_resize</li>
</ul>
</li>
<li>VK_SUBOPTIMAL_KHR<ul>
<li>啥事不干</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkDestroySemaphore: <code>imageAcquiredSemaphore</code></li>
<li>vkDestroySemaphore: <code>drawCompleteSemaphore</code></li>
</ul>
</li>
<li>demo-&gt;depthStencil 周期改变</li>
<li>vkDeviceWaitIdle</li>
<li>如果到了指定的帧数，则 glfwSetWindowShouldClose</li>
</ul>
</li>
<li>demo_cleanup<ul>
<li>删除一万个东西 (literally)</li>
<li>glfwDestroyWindow</li>
<li>glfwTerminate</li>
</ul>
</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/data-driven-prt" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/data-driven-prt/"><strong>论文阅读 | 数据驱动的 PRT</strong></a>
      <small class=article-date-index>&nbsp; 2022-12-18</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/data-driven-prt/" class="article-date">
  <time datetime="2022-12-17T16:00:00.000Z" itemprop="datePublished">2022-12-18</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文省略了一大堆细节，详情参见论文。</p>
<p>TODO: 整理清楚各个维数，因为原论文也不甚详细；</p>
<p>更新后的版本会放到 <a href="https://blog.libreliu.info/paper-reading/data-driven-prt/">这里</a>，如果有。</p>
</blockquote>
<h2 id="Recap-Precomputed-Radiance-Transfer"><a href="#Recap-Precomputed-Radiance-Transfer" class="headerlink" title="Recap: Precomputed Radiance Transfer"></a>Recap: Precomputed Radiance Transfer</h2><blockquote>
<p>本节主要参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">GAMES 202 - 高质量实时渲染</a>课程的 Lecture 6 和 Lecture 7</p>
</blockquote>
<p>考虑渲染方程</p>
$$
L({\bf o}) = \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}
$$

<p>其中</p>
<ul>
<li>$ {\bf i}, {\bf o} $ 为入射和出射方向</li>
<li>$ L({\bf i}), L({\bf o}) $ 为入射和出射 radiance<ul>
<li>此处<strong>省略了</strong>作为参数的 shading point 位置 $ \bf x $，下同</li>
</ul>
</li>
<li>$ \rho $ 为 BRDF 函数</li>
<li>$ V $ 为 Visibility 项</li>
</ul>
<p>将 $ L({\bf i}) $ 项用级数的有限项进行近似，即</p>
$$
L({\bf i}) \approx \sum_{i=1}^{n} l_i B_i({\bf i})
$$

<blockquote>
<p>其中 $ B_i: S^2 \to \mathbb{R} $ 为基函数</p>
</blockquote>
<p>带入得到</p>
$$
\begin{aligned}
L({\bf o}) &= \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\
&\approx \sum_i l_i \int_{\mathcal{H}^2} B_i({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\
&= \sum_i l_i T_i({\bf o})
\end{aligned}
$$

<p>这里把上面的积分 (“Light transport term”) 记作 $ T_i $.</p>
<p>这里继续进行展开</p>
$$
T_i({\bf o}) \approx \sum_{j=1}^{m} t_{ij} B_j({\bf o})
$$

<p>所以我们得到</p>
$$
\begin{aligned}
L({\bf o}) &\approx \sum_i l_i T_i({\bf o}) \\
&\approx \sum_i l_i \left( \sum_j t_{ij} B_j({\bf o}) \right) \\
&\approx \sum_j \left( \sum_i l_i t_{ij} \right) B_j({\bf o}) \\
\end{aligned}
$$

<p>也就是说</p>
$$
L({\bf o}) 
\approx 
\begin{bmatrix}
l_1 & ... & l_n
\end{bmatrix}
\begin{bmatrix}
t_{11} & ... & t_{1m} \\
\vdots & & \vdots \\
t_{n1} & ... & t_{nm}
\end{bmatrix}
\begin{bmatrix}
B_1({\bf o}) \\ \vdots \\ B_m({\bf o})
\end{bmatrix}
$$

<p>那么，PRT 的框架就大致如下</p>
<ol>
<li><p>预计算</p>
<ul>
<li>对每个可能的 shading point $ {\bf x} $<ul>
<li>计算该物体的环境光在基函数下对应的系数 $ l_i $</li>
<li>计算该物体光传输展开系数 $ t_{ij} $</li>
</ul>
</li>
</ul>
<blockquote>
<p>当然，对于 Image based lighting，一般认为 $ L({\bf i}, {\bf x}) \approx L({\bf i}) $，那某些东西就不需要 per-shading point 存储</p>
</blockquote>
</li>
<li><p>运行时</p>
<ul>
<li>根据视角 $ {\bf o} $ 和位置 $ {\bf x} $ 来读取对应的向量并计算</li>
</ul>
</li>
</ol>
<blockquote>
<p>对于 Diffuse 物体，$ \rho({\bf i}, {\bf o}) $ 是常数，所以不需要继续展开 $ T_i $ 项</p>
</blockquote>
<blockquote>
<p>Remarks from paper: PRT methods bake the transport matrix using implicit light sources defined by the illumination basis.<br>Those light sources shade the asset with positive and negative radiance values. Hence, a dedicated light transport algorithm is used for them.</p>
</blockquote>
<h2 id="本文思路"><a href="#本文思路" class="headerlink" title="本文思路"></a>本文思路</h2><p>本文的框架只考虑<strong>漫反射</strong>，虽然结果上对于不是特别 Glossy 的材质应该都可以应用。</p>
<p>框架上的思路就是</p>
<ul>
<li>间接光 $ L_i({\bf x}; t) $ 和直接光 $ L_d({\bf i}, {\bf x}; t) $ 之间存在线性关系</li>
<li>框架：<ul>
<li>将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ I &#x3D; MD $<ul>
<li>相当于挑了一组基，每个基内部由同一个光照条件下各个位置的 $ L_d $ 组成</li>
</ul>
</li>
<li>对于给定的光照条件 $ x $ （各个位置 $ L_d $的值构成的列向量） ，如何求解 $ L_i $ ？<ul>
<li>首先把 $ x $ 分解到该 $ D $ 基下，得到系数向量 $ c &#x3D; (D^T D)^{-1} D^T x $</li>
<li>每个 $ D $ 基我们都存储有对应的输出，所以结果 $ y &#x3D; Mx &#x3D; I(D^T D)^{-1} D^T x $</li>
</ul>
</li>
</ul>
</li>
<li>近似：<ul>
<li>对 $ I $ 进行 SVD 分解并保留前 $ k $ 项，得到近似矩阵 $ I &#x3D; U \Sigma V^T \approx U_n \Sigma_n V_n^T $</li>
<li>$ y \approx U_n (\Sigma_n V_n^T) (D^T D)^{-1} D^T x $<ul>
<li>let $ M_n &#x3D; (\Sigma_n V_n^T) (D^T D)^{-1} D^T $</li>
</ul>
</li>
<li>存储 $ U_n $ 和 $ M_n $</li>
</ul>
</li>
<li>运行时：<ul>
<li>用 G-Buffer 得到 $ \mathcal{X}_D $ 空间上的各 $ L_d({\bf i}, {\bf x}; t) $ 的值</li>
<li>计算 $ y &#x3D; U_n M_n x $ 的值</li>
</ul>
</li>
</ul>
<h3 id="估计光传输矩阵"><a href="#估计光传输矩阵" class="headerlink" title="估计光传输矩阵"></a>估计光传输矩阵</h3><p>给定<strong>环境光</strong>条件 $ t \in \mathcal T $，那么在物体表面 $ {\bf x} $ 处，<strong>漫反射</strong>光传输方程的形式如下</p>
$$
L_i({\bf x}; t) = \frac{1}{2 \pi}\int_{\mathcal{H}^2} L_d({\bf i}, {\bf x}; t) V({\bf i}, {\bf x}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}
$$

<p>其中，$ L_i({\bf x}; t) $ 被称为间接光， $ L_d({\bf i}, {\bf x}; t) $ 被称为直接光</p>
<blockquote>
<p>$ L_d({\bf i}, {\bf x}; t) $ 不考虑环境和物体 inter-reflection; 推导中可以先忽略，虽然实际上对于有 inter-transmission 的情况应该也是可以应用的</p>
</blockquote>
<p>现在将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ \mathcal{X}_D $ 和 $ \mathcal{T}_D $ 两有限维空间，那么在这两个空间上， $ L_d $ 和 $ L_i $ 都可以表示为矩阵形式，这里规定每一列的元素在同一个环境光条件 $ {\bf i}, t $ 上。</p>
<blockquote>
<p>比如说，都在环境光为某点光源照射的情况； $ L_d({\bf i}, {\bf x}; t) $ 的 $ {\bf i} $ 一般意义上是依赖 $ t $ 的</p>
</blockquote>
<p>记得到的两个矩阵为 $ D $ 和 $ I $，则</p>
$$
I_k = f(D_k) \quad \forall k \in [0, |\mathcal{T}_D|]
$$

<p>从前面可以看到，这里的 $f$ 是线性算子 (<em>是嘛？</em>)，所以</p>
$$
I = MD
$$

<p>又假设我们离散 $ \mathcal T $ 空间离散的很好，那么对任意的环境光条件，<strong>直接光向量</strong> $ x $ 都可以表示成 $ D $ 的线性组合，满足</p>
$$
x = Dc
$$

<p>左右乘 $ M $ 得到</p>
$$
Mx = MDc = Ic
$$

<p>也就是说 $x$ 产生的间接光照可以用 $I$ 中列向量的线性组合来表示</p>
<p>因为 $ x &#x3D; Dc $，假设 $ D^T D $ 可逆，那么用左逆得到</p>
$$
c = (D^T D)^{-1} D^T x
$$

<p>那么</p>
$$
y = Mx = Ic = I (D^T D)^{-1} D^T x
$$

<p>这样就给出了<strong>任意直接光经过光传输</strong>的结果</p>
<h3 id="间接光基函数"><a href="#间接光基函数" class="headerlink" title="间接光基函数"></a>间接光基函数</h3><p>我们认为，间接光所对应的空间的秩比较低，所以用 SVD 分解然后保留前 $ n $ 项</p>
$$
I = U \Sigma V^T \approx U_n \Sigma_n V_n^T = U_n C_n
$$

<p>其中记 $ C_n &#x3D; \Sigma_n V_n^T $</p>
<p>带回去，得到任意直接光组合经过光传输方程的近似结果</p>
$$
\begin{aligned}
y &\approx U_n C_n (D^T D)^{-1} D^T x \\
&\approx U_n M_n x
\end{aligned}
$$

<p>其中 $ M_n &#x3D; C_n (D^T D)^{-1} D^T $</p>
<h3 id="直接光编码"><a href="#直接光编码" class="headerlink" title="直接光编码"></a>直接光编码</h3><p>如果有需要的话，可以考虑 SH 基函数，详见文章</p>
<h2 id="对比经典-PRT"><a href="#对比经典-PRT" class="headerlink" title="对比经典 PRT"></a>对比经典 PRT</h2><p>First, because classical PRT restricts the frequency content of the incoming lighting, we can see that the directional light leaks behind the object. Our method <strong>does not restrict the frequency content of incoming light</strong> but rather <strong>the space of possible indirect illumination</strong>.  Hence, we can better reproduce such lighting scenario. </p>
<p>Furthermore, classical PRT is performed on the vertices of the asset. This can cause interpolation artifacts when the asset is poorly tessellated, and it also links performance to the vertex count. Since we rely on a <strong>meshless approach</strong>, we are free of issues.</p>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p><strong>Sparse Illumination Measurement</strong>. As shown in Section 3.3, the sampling of the measurement points is linked to the achievable lighting dimensionality. Thus, it needs to be sufficiently dense to reproduce the space of observable lighting configurations. It follows that a lighting scenario mixing many light types might require a denser sampling. </p>
<p><strong>No Directionality</strong>. We reconstruct a diffuse appearance when reconstructing indirect illumination. However, since our method does not depend on the encoding of the measured indirect illumination, it can be extended to reconstruct glossy appearances e.g. directional distributions using directional sampling or any basis such as Spherical Harmonics. However, our method is likely to be restricted to low frequency gloss here and will not work to render specular reflections. </p>
<p><strong>Large Assets</strong>. Our solution is not designed to handle assets such as levels in a game. Because we handle light transport globally and reduce it with a handful of basis functions, we cannot reconstruct the interconnected interiors or large environments in which the combinatorics of possible illumination is large. For such case, our method would require to be extended to handle modular transfer between disjoint transport solutions (Similar to Loos et al. [2011]).</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/continuous-mis" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/continuous-mis/"><strong>论文阅读 | 连续多重重要性采样</strong></a>
      <small class=article-date-index>&nbsp; 2022-11-05</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/continuous-mis/" class="article-date">
  <time datetime="2022-11-04T16:00:00.000Z" itemprop="datePublished">2022-11-05</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章扩展了 Veach 在 1995 年提出的、用于 Monte Carlo 多重重要性采样 (Multiple Importance Sampling)，将其推广到了具有<strong>无限</strong>的<strong>连续</strong>采样策略的情况。</p>
<h2 id="多重重要性采样-MIS"><a href="#多重重要性采样-MIS" class="headerlink" title="多重重要性采样 (MIS)"></a>多重重要性采样 (MIS)</h2><blockquote>
<p>本方法比较详细的讨论可以参考 <em>Optimally Combining Sampling Techniques<br>for Monte Carlo Rendering</em> 这篇 SIGGRAPH’95 的论文，是 Veach 和 Guibas 很高引用的文章之一。</p>
<p>也可以参考 <a target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling">Importance Sampling | PBR Book 3rd</a>，不过里面没有证明。</p>
</blockquote>
<p>对于积分</p>
$$
I = \int_\Omega f(x) dx
$$

<p>我们希望用 Monte Carlo 采样的方法进行积分值的估计。</p>
<p>多重重要性采样 (Multiple Importance Sampling, MIS) 的大致思路如下：有 $ m $ 个采样策略，每个采样策略都可以对样本空间 $ \Omega $ 进行采样，并且每种策略都有概率密度函数 $ p_i(x) $。</p>
<p>对于 Multi-sample MIS，要分别使用每种采样策略<strong>独立</strong>采样 $ n_i $ 次，获得总计 $ \sum_{i&#x3D;1}^{m} n_i $ 个采样，然后使用如下的式子进行积分的估计：</p>
$$
\langle I \rangle_{mis} = \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})}
$$

<p>其中 $ x_{i, j} $ 表示第 $ i $ 个采样策略第 $ j $ 次采样获得的值，$ w_i(x) $ 为 $ m $ 个与 MIS 相关的权重函数。</p>
<p>首先可以证明，这 $ m $ 个权重函数只要满足 $ \sum_{i&#x3D;1}^m w_i(x) &#x3D; 1 $，那么 $ \langle I \rangle_{mis} $ 就是无偏的：</p>
$$
\begin{aligned}
\operatorname{E}[\langle I \rangle_{mis}] &= \operatorname{E}\left[ \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\
&= \sum_{i=1}^m \frac{1}{n_i} \operatorname{E}\left[ \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\
&= \sum_{i=1}^m \operatorname{E}\left[ \frac{w_i(x_{i,1}) f(x_{i, 1})}{p_i(x_{i,1})} \right] \quad (\because \text{i.i.d})\\
&= \sum_{i=1}^m \int_\Omega \frac{w_i(x) f(x)}{p_i(x)} p_i(x) dx \\
&= \sum_{i=1}^m \int_\Omega w_i(x) f(x) dx \\
&= \int_\Omega \sum_{i=1}^m w_i(x) f(x) dx \\
&= \int_\Omega f(x) dx \\
&= I
\end{aligned}
$$

<p>那么，哪样的权重会让估计量的方差比较小呢？Veach 和 Guibas 在其论文中，给出了被称为 <strong>Balance Heuristic</strong> 的估计量：</p>
$$
\hat w_i (x) = \frac{c_i p_i(x)}{\sum_{j=1}^m c_j p_j(x)} \quad \text{where}\ c_i = n_i / \sum_{j=1}^{m} n_j 
$$

<p>并且他们证明了，使用 $ { \hat w_i(x) }<em>{i&#x3D;1}^m $ 作为权重函数构造的估计量 $ \langle \hat I</em>{mis} \rangle $ 和<strong>任意的</strong>权重函数构造的估计量 $ \langle I_{mis} \rangle $ 的方差满足下面的关系：</p>
$$
\operatorname{V}[\langle \hat I \rangle_{mis}] \le \operatorname{V}[\langle I \rangle_{mis}] + \left( \frac{1}{\min_i n_i} - \frac{1}{\sum_i n_i} \right) I^2 
$$

<p>这其实在说，Balance Heuristic 从渐进意义上来说是方差比较低的估计。</p>
<p>有的时候，我们只希望采样一次。这种情况下，我们可以首先以 $P(t&#x3D;i)$ 的概率去采样我们将要使用的采样方法 $t$，然后再使用 MIS 积分估计量：</p>
$$
\langle I \rangle_{mis} = \frac{w_t(x_{t,1}) f(x_{t,1})}{p_t(x_{t,1}) P(t=i)}
$$

<p>其中 $ p_t(x_{t,1}) $ 表示采样方法为 $ t $ 情况下抽样到 $ x_{t,1} $ 的条件概率。</p>
<p>Veach 的论文中证明，Balance Heuristic 在任何 One-sample MIS 的情形下都是最优的权重组合。</p>
<h2 id="连续多重重要性采样-Continuous-MIS"><a href="#连续多重重要性采样-Continuous-MIS" class="headerlink" title="连续多重重要性采样 (Continuous MIS)"></a>连续多重重要性采样 (Continuous MIS)</h2><p>West 等人将上面的工作进行了进一步的推广：如果现在有连续的无限多种采样策略，那么也可以将 MIS 中的估计量进行推广，得到<strong>连续多重重要性采样</strong> (Continuous Multiple Importance Sampling, CMIS)。</p>
<p>定义采样方法空间 $ \mathcal{T} $，在其上的每个元素 $ t \in \mathcal{T} $ 都是一种采样策略。</p>
<p>那么自然可以想到，将 $ w_i(x) $ 推广为一个 $ \mathcal{T} \times \mathcal{X} \to \mathrm{R} $ 的函数 $ w(t, x) $，归一化条件 $ \sum_i w_i(x) &#x3D; 1 $ 推广为 $ \int_\mathcal{T} w(t, x) dt &#x3D; 1 $。</p>
<p>类似的，可以定义 One-sample CMIS 积分估计量</p>
$$
\langle I \rangle_{CMIS} = \frac{w(t, x)f(x)}{p(t, x)} = \frac{w(t, x)f(x)}{p(t) p(x|t)}
$$

<p>其中 $ p(t) $ 是选择策略 $ t $ 的概率密度， $ p(x|t) $ 是在策略 $ t $ 下采样得到 $ x $ 的条件概率。</p>
<p>同时，只要满足如下两个条件，上面的估计量就是无偏的：</p>
<ol>
<li>$ \int_\mathcal{T} w(t, x) dt = 1 $ 对任何 $ x \in \operatorname{supp} f(x) $ 成立</li>
<li>当 $ p(t, x) &#x3D; 0 $ 时，$ w(t, x) &#x3D; 0 $ <blockquote>
<p>为什么？</p>
</blockquote>
</li>
</ol>
<p>类比 MIS，CMIS 也可以定义 Balance Heuristic 如下：</p>
$$
\bar w(t, x) = \frac{p(t)p(x|t)}{\int_\mathcal{T} p(t') p(x|t') dt'} = \frac{p(t, x)}{\int_\mathcal{T} p(t', x)dt} = \frac{p(t, x)}{p(x)}
$$

<blockquote>
<p>那么其实可以看到，用 Balance Heristic 的 $ w(t, x) $ 带入到 $ \langle I \rangle_{CMIS} $ 之后，其实就会化简成为 $ f(x) &#x2F; p(x) $，只不过这里的 $ p(x) $ 是 $ p(t, x) $ 的边缘分布。</p>
</blockquote>
<h2 id="随机多重重要性采样-Stochastic-MIS"><a href="#随机多重重要性采样-Stochastic-MIS" class="headerlink" title="随机多重重要性采样 (Stochastic MIS)"></a>随机多重重要性采样 (Stochastic MIS)</h2><p>前面的方法会面临一个问题，有的时候 $ p(x) &#x3D; \int_\mathcal{T} p(t’, x)dt $ 是没有闭式解的，这样去算 $ \bar w(t, x) $ 的时候会遇到问题。所以，West 等人又提出了随机多重重要性采样 (Stochastic MIS, SMIS)。</p>
<p>SMIS 首先假设在 $ \mathcal{T} \times \mathcal{X} $ 中独立的采样 $ (t_1, x_1), …, (t_n, x_n) $ 共 $n$ 组点。</p>
<blockquote>
<p>TODO: implement me</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="Path-Reuse"><a href="#Path-Reuse" class="headerlink" title="Path Reuse"></a>Path Reuse</h4><h4 id="Spectral-Rendering"><a href="#Spectral-Rendering" class="headerlink" title="Spectral Rendering"></a>Spectral Rendering</h4><h4 id="Volume-Single-Scattering"><a href="#Volume-Single-Scattering" class="headerlink" title="Volume Single Scattering"></a>Volume Single Scattering</h4>
      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-example-d3d11-app-flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/example-d3d11-app-flow/"><strong>一个示例 D3D11 程序的全流程记录</strong></a>
      <small class=article-date-index>&nbsp; 2022-10-19</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/example-d3d11-app-flow/" class="article-date">
  <time datetime="2022-10-18T16:00:00.000Z" itemprop="datePublished">2022-10-19</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇是笔者进行 RenderDoc drivers 层分析时一并记录下来的，是一个渲染 Cube 的简单 D3D11 程序与 API 交互的全流程的记录。</p>
<p>以 <a target="_blank" rel="noopener" href="https://github.com/libreliu/DirectX11-With-Windows-SDK/tree/master/Project%2001-09/03%20Rendering%20a%20Cube">DirectX11-With-Windows-SDK - Rendering A Cube</a> 为例进行说明。</p>
<blockquote>
<p>DXGI (<strong>D</strong>irect<strong>X</strong> <strong>G</strong>raphics <strong>I</strong>nfrastructure) 负责抽象和交换链、DAL 相关的公共部分。关于 DXGI 的资料可以参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi">MSDN</a>。</p>
<p>DXGI 封装了多种对象：</p>
<ul>
<li>显示适配器 (IDXGIAdapter): 一般对应一块显卡，也可以对应 Reference Rasterizer，或者支持虚拟化的显卡的一个 VF 等</li>
<li>显示输出 (IDXGIOutput): 显示适配器的输出，一般对应一个显示器</li>
<li>交换链 (IDXGISwapChain): 用来暂存要显示到输出窗口&#x2F;全屏幕的 1 到多个 Surface 的对象<ul>
<li><code>g_pSwapChain-&gt;GetBuffer</code> 可以拿到表示 Back Buffer 的 <code>ID3D11Texture</code></li>
<li>从 <code>g_pd3dDevice-&gt;CreateRenderTargetView</code> 来创建一个封装该 Texture 的 <code>ID3D11RenderTargetView</code></li>
<li><code>g_pd3dDeviceContext-&gt;OMSetRenderTargets</code> 来设置管线的 RenderTarget</li>
<li><code>g_pd3dDeviceContext-&gt;RSSetViewports</code> 来设置管线的 Viewport</li>
</ul>
</li>
</ul>
</blockquote>
<!--

> 和 DRM (master) 的相应概念的对比：
> - NOTE: 我只看过 DRM Master (?) 的相关 API
> 
> DRM 里面有
> - KMS:
>   - CRT Controller, Encoder, Connector, Plane
>   - 感觉 IDXGIAdapter 约等于 /dev/dri/card0 ... 等加速设备
>   - 但也不是，因为 DRM 的 master 节点的访问限制 (?)
>   - TODO: 理一理 DRM
> - Buffer Object Management

-->

<h2 id="GameApp-Init"><a href="#GameApp-Init" class="headerlink" title="GameApp::Init()"></a><code>GameApp::Init()</code></h2><ul>
<li><code>D3DApp::Init()</code><ul>
<li><code>InitMainWindow()</code><ul>
<li><code>RegisterClass(WNDCLASS *)</code>: 注册</li>
<li><code>AdjustWindowRect()</code></li>
<li><code>CreateWindow()</code></li>
<li><code>ShowWindow()</code></li>
<li><code>UpdateWindow()</code></li>
</ul>
</li>
<li><code>InitDirect3D()</code><ul>
<li><p><code>D3D11CreateDevice()</code>: 采用 11.1 的 Feature Level，不行则降级</p>
<p>该函数会返回 Immediate Context (<code>ID3D11DeviceContext</code>), 设备 (<code>ID3D11Device</code>) 和特性等级</p>
</li>
<li><p><code>ID3D11Device::CheckMultisampleQualityLevels</code>: 查询给定 DXGI_FORMAT 是否支持给定倍数的 MSAA</p>
</li>
<li><p>将前面的 <code>ID3D11Device</code> Cast 到 <code>IDXGIDevice</code></p>
<blockquote>
<p>An <code>IDXGIDevice</code> interface implements a derived class for DXGI objects that produce image data.</p>
</blockquote>
</li>
<li><p><code>IDXGIDevice::GetAdapter</code> 拿到 <code>IDXGIAdapter</code></p>
<blockquote>
<p>The <code>IDXGIAdapter</code> interface represents a display subsystem (including one or more GPUs, DACs and video memory).</p>
</blockquote>
</li>
<li><p><code>IDXGIAdapter::GetParent</code> 拿到 <code>IDXGIFactory1</code></p>
<blockquote>
<p>这里的 <code>GetParent</code> 是 <code>IDXGIAdapter</code> 作为 <code>IDXGIObject</code> 的方法，可以获得构造它的工厂类。</p>
<p>The <code>IDXGIFactory1</code> interface implements methods for generating DXGI objects.</p>
</blockquote>
</li>
<li><p>尝试将 <code>IDXGIFactory1</code> Cast 到 <code>IDXGIFactory2</code> (DXGI 1.2 新增)</p>
<ul>
<li>如果支持 DXGI 1.2，则用 <code>CreateSwapChainForHwnd</code> 来创建交换链</li>
<li>否则，用 <code>CreateSwapChain</code> 来创建交换链<blockquote>
<p>这两个函数都可以创建窗口 &#x2F; 全屏幕交换链；DXGI 1.2 增加了新的、到其它输出目标的交换链创建功能，所以这里进行了重构。</p>
<p>也要注意，不同 DirectX 可以支持的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/ne-dxgi-dxgi_swap_effect">交换链的交换行为类型</a>是不同的。大体上，交换链的交换行为可以分为</p>
<ul>
<li>DISCARD vs SEQUENTIAL: 可以参考 <a target="_blank" rel="noopener" href="https://gamedev.stackexchange.com/questions/58654/what-is-the-difference-between-dxgi-swap-effect-discard-and-dxgi-swap-effect-seq">StackExchange</a>，区别就是一个驱动可以放心扔掉，另一个必须保留回读可能</li>
<li>FILP vs BLIT (Bit Block Transfer): 决定是用交换指针还是数据拷贝的方法来从交换链被 Present 的 Surface 中拿取数据</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><code>IDXGIFactory1::MakeWindowAssociation</code> 来取消让 DXGI 接收 Alt-Enter 的键盘消息并且切换窗口和全屏模式</p>
</li>
<li><p><code>D3D11SetDebugObjectName()</code></p>
<ul>
<li><code>ID3D11DeviceChild::SetPrivateData(WKPDID_D3DDebugObjectName, ...)</code> 来设置资源的内部数据，这里是调试名称</li>
</ul>
</li>
<li><p><code>DXGISetDebugObjectName()</code></p>
<ul>
<li><code>IDXGIObject::SetPrivateData(WKPDID_D3DDebugObjectName, ...)</code> 来设置资源的内部数据，这里是调试名称</li>
</ul>
</li>
<li><p><code>OnResize()</code></p>
<ul>
<li><code>IDXGISwapChain::ResizeBuffers()</code></li>
<li><code>IDXGISwapChain::GetBuffer()</code> 拿到 <code>ID3D11Texture2D</code> 形式的 Back Buffer</li>
<li><code>IDXGISwapChain::CreateRenderTargetView()</code> 创建绑定到上面 Back Buffer 的 Texture 的渲染目标视图</li>
<li><code>D3D11SetDebugObjectName</code> 来设置 Back Buffer 的调试名称 </li>
<li><code>ID3D11Device::CreateTexture2D()</code> 来创建深度模板缓冲 (Depth Stencil Buffer)，类型 <code>ID3D11Texture2D</code>，包含大小，MipLevel，采样描述等</li>
<li><code>ID3D11Device::CreateDepthStencilView()</code> 来创建前面缓冲对应的深度模板视图</li>
<li><code>ID3D11DeviceContext::OMSetRenderTargets()</code> 来将渲染目标视图和深度木板视图绑定到管线</li>
<li><code>ID3D11DeviceConetxt::RSSetViewports()</code> 绑定 Viewport 信息到光栅器状态</li>
<li><code>D3D11SetDebugObjectName()</code> 设置调试前面各种视图对象的对象名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>InitEffect()</code><ul>
<li><code>CreateShaderFromFile()</code>: 传入 CSO (Compiled Shader Object) 和 Shader 文件，输出 <code>ID3DBlob *</code><ul>
<li>如果有缓存，则用 <code>D3DReadFileToBlob</code> 装入，并返回</li>
<li><code>D3DCompileFromFile()</code>: 编译并生成 <code>ID3DBlob</code> 对象</li>
<li>如果指定了缓存路径，则 <code>D3DWriteBlobToFile()</code> 进行输出<blockquote>
<p>分别创建了 <code>vs_5_0</code> 和 <code>ps_5_0</code> Shader Model 的 Shader Blob</p>
</blockquote>
</li>
</ul>
</li>
<li><code>ID3D11Device::CreateVertexShader()</code>，根据 Shader Bytecode 创建 <code>ID3D11VertexShader</code> 对象<blockquote>
<p>注意这个函数支持传入 Class Linkage，这是一种在 Shader 间共享类型和变量的机制，在 Shader Model 5 被引入。更详细的用法可以参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/overviews-direct3d-11-hlsl-dynamic-linking-class">Dynamic Linking Class | MSDN</a></p>
<p>TODO: 研究一下</p>
</blockquote>
</li>
<li><code>ID3D11Device::CreateInputLayout()</code> 传入输入元素描述符和 Shader，传出 <code>ID3D11InputLayout</code> 对象</li>
<li><code>ID3D11Device::CreatePixelShader()</code> ，根据 Shader Bytecode 创建 <code>ID3D11PixelShader</code> 对象</li>
</ul>
</li>
<li><code>InitResource()</code><ul>
<li><code>ID3D11Device::CreateBuffer()</code> 创建顶点缓冲区 (<code>ID3D11Buffer</code>) ，并传入初始化数据</li>
<li><code>ID3D11Device::CreateBuffer()</code> 创建索引缓冲区 (<code>ID3D11Buffer</code>) ，并传入初始化数据</li>
<li><code>ID3D11DeviceContext::IASetIndexBuffer()</code> 设置 Immediate Context 绑定索引缓冲区</li>
<li><code>ID3D11Device::CreateBuffer()</code> 创建常量缓冲区 (<code>ID3D11Buffer</code>) ，不是用初始化数据<ul>
<li>此处设置 <code>D3D11_BUFFER_DESC</code> 的 <code>CPUAccessFlags</code> 为 <code>D3D11_CPU_ACCESS_WRITE</code>，让 CPU 可以改变其值</li>
</ul>
</li>
<li><code>ID3D11DeviceContext::IASetVertexBuffers()</code> 设置顶点缓冲区，stride 和 offset</li>
<li><code>ID3D11DeviceContext::IASetPrimitiveTopology()</code> 设置图元类型</li>
<li><code>ID3D11DeviceContext::IASetInputLayout()</code> 设置输入布局</li>
<li><code>ID3D11DeviceContext::VSSetShader()</code> 绑定顶点着色器到管线</li>
<li><code>ID3D11DeviceContext::VSSetConstantBuffers()</code> 设置常量缓冲区<blockquote>
<p>这里当然是拿着 ID3D11Buffer 去设置</p>
</blockquote>
</li>
<li><code>ID3D11DeviceContext::PSSetShader()</code> 设置像素着色器</li>
<li><code>D3D11SetDebugObjectName()</code> 将 Input Layout, Shader 和 Buffer 设置好调试用名字</li>
</ul>
</li>
</ul>
<h2 id="GameApp-Run"><a href="#GameApp-Run" class="headerlink" title="GameApp::Run()"></a><code>GameApp::Run()</code></h2><blockquote>
<p>关于 Windows 消息机制的相关介绍可以参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues">About messages and message queues | MSDN</a>。</p>
</blockquote>
<p>运行首先依赖 Windows 窗口程序本身的主事件循环（<code>PeekMessage()</code> &#x3D;&gt; <code>TranslateMessage()</code> &#x3D;&gt; <code>DispatchMessage()</code>)。</p>
<p>主窗口的消息处理函数中，主要会处理：</p>
<ul>
<li><code>WM_SIZE</code>: 如果在 <code>WM_ENTERSIZEMOVE</code> 和 <code>WM_EXITSIZEMOVE</code> 中间，则忽略，否则调用 <code>OnResize()</code> 重新配置交换链并绑定到管线</li>
<li><code>WM_ACTIVATE</code>: 窗口不活跃时暂停渲染</li>
<li><code>WM_DESTROY</code>: 窗口退出消息</li>
</ul>
<p>如果没有待处理的窗口消息，则会进入：</p>
<ul>
<li><code>CalculateFrameStats()</code>: 根据定时器计算时长并更新窗口标题</li>
<li><code>UpdateScene()</code>: 更新场景 (主要是更新常量缓冲)<ul>
<li>计算更新后的常量缓冲区值</li>
<li><code>ID3D11DeviceContext::Map</code> 传入 Constant Buffer 对象<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map">MSDN</a>: Gets a pointer to the data contained in a subresource, and denies the GPU access to that subresource.</p>
<p>这里要指定映射类型 (CPU 可读，CPU 可写，CPU 可写且原内容可放弃)；不过，这里还有一种类型，叫做 <code>D3D11_MAP_WRITE_NO_OVERWRITE</code>，这块 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_map">MSDN 的文档</a>有比较详细的解释。</p>
<p>也可以看看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341476240">这篇</a>知乎专栏作为参考。</p>
</blockquote>
<!-- TODO: 调查一下这个问题 --></li>
<li><code>memcpy(mappedData.pData, &amp;cpuCBuffer, sizeof(cpuConstBuffer))</code> 将数据拷贝到 <code>D3D11_MAPPED_SUBRESOURCE::pData</code> 成员处</li>
<li><code>ID3D11DeviceContext::Unmap</code> 解除内存映射</li>
</ul>
</li>
<li><code>DrawScene()</code>: 绘制场景<ul>
<li><code>ID3D11DeviceContext::ClearRenderTargetView()</code>: 用给定颜色清空渲染目标视图</li>
<li><code>ID3D11DeviceContext::ClearDepthStencilView()</code>: 用给定深度和模板值清空深度模板视图</li>
<li><code>ID3D11DeviceContext::DrawIndexed()</code>: 绘制给定的立方体</li>
<li><code>IDXGISwapChain::Present(SyncInterval=0, flags=0)</code>: 告知交换链已经完成绘制，可以呈现，并且要求立即呈现<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">IDXGISwapChain::Present</a>: Presents a rendered image to the user.</p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/icarus-nerf" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/icarus-nerf/"><strong>论文阅读 | ICARUS: NeRF 硬件加速器</strong></a>
      <small class=article-date-index>&nbsp; 2022-10-07</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/icarus-nerf/" class="article-date">
  <time datetime="2022-10-06T16:00:00.000Z" itemprop="datePublished">2022-10-07</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章介绍了 NeRF 硬件加速的实现。</p>
<h2 id="NeRF-回顾"><a href="#NeRF-回顾" class="headerlink" title="NeRF 回顾"></a>NeRF 回顾</h2><img src="/paper-reading/icarus-nerf/nerf-overview.png" class="" title="NeRF Overview from Original Paper">

<p>Neural Radiance Field，简称 NeRF，最开始在 ECCV 2020 上<a target="_blank" rel="noopener" href="https://www.matthewtancik.com/nerf">被提出</a>，提出了以神经网络编码辐射场的一种技术，并且将其运用到了基于图片的场景重建等多个领域中，是近年来受关注度相当高的一篇工作。</p>
<p>NeRF 的网络部分输入为 5D: 位置 $ (x,y,z) $ 和朝向 $ (\theta, \phi) $，输出为该位置的 RGB 颜色和密度。</p>
<p>NeRF 在给定相机位置下最终渲染的输出用类似体渲染 (Volumetric Rendering) 的办法来实现。</p>
<h3 id="NeRF-体渲染"><a href="#NeRF-体渲染" class="headerlink" title="NeRF 体渲染"></a>NeRF 体渲染</h3><p>对给定的相机光线 $ {\bf r}(t) &#x3D; {\bf o} + t{\bf d} $ 来说，最终输出的颜色 $ {\bf C}(r) $ 以下式表示：</p>
$$
C({\bf r}) = \int_{t_n}^{t_f} T(t) \sigma({\bf r}(t)) {\bf c}({\bf r}(t), {\bf d}) dt 
$$

<p>其中：</p>
<ul>
<li>$ T(t) = \exp (-\int_{t_n}^{t} \sigma({\bf r}(s)) ds ) $ 为光线从 $ t_n $ 能打到 $ t $ 的概率<ul>
<li>比如说，如果射线穿过的部分密度都比较大，那 $ T(t) $ 就会比较小</li>
</ul>
</li>
<li>$ \sigma({\bf r}(t)) $ 是该 $ t $ 对应的点 $ {\bf r}(t) $ 的密度</li>
<li>$ {\bf c}({\bf r}(t), {\bf d}) $ 是网络给定方向和位置后输出的 RGB 颜色值</li>
<li>$ t_n $ 和 $ t_f $ 分别为射线进入和射出 NeRF 有效区域的包围盒时所对应的最近和最远参数值</li>
</ul>
<p>不过这个积分显然不能很容易的解析求解，NeRF 的做法是采用数值积分的那一套。</p>
<p>首先，利用分层抽样 (stratified sampling) 的技术，将 $ [t_n, t_f] $ 分成 $ N $ 个均匀的小区间，然后在每个小区间均匀采样出一个 $ t_i $ 出来。</p>
<p>然后，用下面的量 $ \hat C({\bf r}) $ 来估计上面的 $ C({\bf r}) $：</p>
$$
\hat C({\bf r}) = \sum_{i=1}^{N} T_i (1-\exp(-\sigma_i \delta_i)) {\bf c}_i
$$

<p>其中：</p>
<ul>
<li>$ T_i = \exp(- \sum_{j=1}^{i-1} \sigma_j \delta_j) $</li>
<li>$ \delta_i = t_{i+1} - t_i $ 为两临近采样点的距离</li>
</ul>
<blockquote>
<p>为什么会变成这个形式？可以参考 arXiv 上的 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2209.02417.pdf">Volume Rendering Digest (for NeRF)</a></p>
</blockquote>
<!-- 没看，TODO: 研究一下 -->

<p>原文中提到，从所有的 $ ({\bf c}_i, \delta_i) $ 对考虑的话，$ \hat C(r) $ 的计算显然是可微的，并且可以看成从最开始一直用 $ \alpha_i &#x3D; 1 - \exp(\sigma_i \delta_i) $ 的透明度往上面做 alpha blending。</p>
<!-- TODO: why alpha value like that -->

<h3 id="NeRF-网络"><a href="#NeRF-网络" class="headerlink" title="NeRF 网络"></a>NeRF 网络</h3><p>网络部分用位置编码 (Positional Encoding) + Coarse MLP + Fine MLP。</p>
<h4 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h4><p>位置编码用来改善网络对高频细节的学习效果。</p>
<p>位置编码层可以如下描述：</p>
$$
\gamma(p) = (\sin(2^0 \pi p), \cos(2^0 \pi p), ..., \sin(2^{L-1} \pi p), \cos(2^{L-1} \pi p))
$$

<h4 id="Coarse-amp-Fine-MLP"><a href="#Coarse-amp-Fine-MLP" class="headerlink" title="Coarse &amp; Fine MLP"></a>Coarse &amp; Fine MLP</h4><p>NeRF 同时使用两个 MLP 来表示场景，一个粗粒度 MLP 和一个细粒度 MLP。</p>
<p>渲染的时候，首先用分层抽样的办法，在粗粒度网络中用前面提到的体渲染方法进行渲染，并且得到输出 $ \hat C_c(r) $：</p>
$$
\hat C_c(r) = \sum_{i=1}^{N_c} w_i c_i, \quad w_i = T_i (1-\exp(\sigma_i \delta_i))
$$

<p>然后，计算归一化权重 $ \hat w_i &#x3D; w_i &#x2F; \sum_{i&#x3D;1}^{N_c} w_i $，并且用计算好的归一化权重作为概率分布函数 (cumulative distribution function)，再在这条直线上采样 $ N_f $ 个位置，将这 $ N_c + N_f $ 个位置送入细粒度 MLP 进行推理，再用前面的办法渲染得到最终的颜色值。</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>采用简单的把 Coarse MLP 和 Fine MLP 与真实值之间的 $ L^2 $ 损失直接加起来的办法。</p>
<h2 id="ICARUS"><a href="#ICARUS" class="headerlink" title="ICARUS"></a>ICARUS</h2><img src="/paper-reading/icarus-nerf/icarus-overview.png" class="" title="ICARUS Overview">

<h3 id="NeRF-计算过程回顾"><a href="#NeRF-计算过程回顾" class="headerlink" title="NeRF 计算过程回顾"></a>NeRF 计算过程回顾</h3><ol>
<li>对像素所发出射线上的采样，得到点 $ ({\bf p}_1, …, {\bf p}_N) $</li>
<li>查询 MLP 网络：$ ({\bf p}_i, {\bf d}_i) \to ({\bf c_i}, \sigma_i) $</li>
<li>进行多次 alpha-blending</li>
</ol>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>架构设计时主要有以下目标：</p>
<ol>
<li>“端到端” - 芯片输入位置和方向，输出像素颜色，减少片上片外数据交换的额外开销（计算时间、功耗）</li>
<li>使用定点数 - 有效降低浮点数运算开销</li>
<li>架构设计要一定灵活性，尽量兼容比较多的 NeRF 衍生网络</li>
</ol>
<h4 id="如何使用定点数？"><a href="#如何使用定点数？" class="headerlink" title="如何使用定点数？"></a>如何使用定点数？</h4><p>目前的实现是将在 GPU 上训练好的 NeRF 的权重进行量化 (quantization)，再导出。不过，目前也有一些工作在 quantization-aware training 方面，可能对这个网络的训练过程有所帮助。</p>
<h3 id="位置编码单元-PEU"><a href="#位置编码单元-PEU" class="headerlink" title="位置编码单元 (PEU)"></a>位置编码单元 (PEU)</h3><p>设计位置编码单元 (Positional Encoding Unit, PEU) 的目的是在 PEU 前和 PEU 后的向量维数增加了很多倍（对原 NeRF 来说位置是 20 倍，方向是 8 倍），如果在 ICARUS 内部进行计算的话，可以减少很大一部分外部存储传输，降低传输总用时。</p>
<p>PEU 部件主要在做这件事：</p>
$$
\phi(x; A) = [\cos A^T x, \sin A^T x]
$$

<p>其中 $ A $ 一般为一个行数比列数多的矩阵，用来升维。</p>
<p>PEU 单元对应的设计如下 (Fig. 4(b))：</p>
<img src="/paper-reading/icarus-nerf/peu-overview.png" class="" title="PEU Overview">

<p>可以看到，就是矩阵乘法单元和 CORDIC 单元的组合。</p>
<blockquote>
<p>一些关于矩阵乘和 CORDIC 单元的大概印象：<br>矩阵乘：有很多工作，比如搜索 Systolic array 等等</p>
<ul>
<li>不过我不清楚 SOTA 情况<br>CORDIC: <a target="_blank" rel="noopener" href="https://zipcpu.com/dsp/2017/08/30/cordic.html">https://zipcpu.com/dsp/2017/08/30/cordic.html</a></li>
<li>不过我也不清楚 SOTA 情况</li>
</ul>
</blockquote>
<p>具体设计上来说，ICARUS 支持对 dim&#x3D;3 和 dim&#x3D;6 的两种输入进行位置编码，并且扩展到 dim&#x3D;128。PEU 内部设计有两个 3x128 的内存块和 6 组 MAC (Multiply-ACcumulate) 单元，当计算 dim&#x3D;6 的输入时会全部启用，当计算 dim&#x3D;3 的输入时只启用一半。</p>
<h3 id="MLP-Engine"><a href="#MLP-Engine" class="headerlink" title="MLP Engine"></a>MLP Engine</h3><p>MLP 引擎主要进行 $ f(Wx+b) $ 类型的计算。</p>
<p>MLP 引擎包含有：</p>
<ul>
<li>一个 Multi-output Network block (MONB)，负责计算中间的隐藏层</li>
<li>一个 Single-output network block (SONB)，负责计算最后的输出层<ul>
<li>不继续用 MONB 的原因是，全连接的 MONB 比只输出一个数字的 SONB 面积要大得多</li>
</ul>
</li>
<li>两个 activation memory block</li>
</ul>
<p>对于 MLP 计算来说，实现是这样的：</p>
<img src="/paper-reading/icarus-nerf/mlp-compution-overview.png" class="" title="MLP Overview">

<p>首先，将 MLP 的权重拆成 64 x 64 的小块，方便硬件上的复用，并且同样的权重可以被多组输入向量复用，从而降低内存带宽开销，代价方面只需要暂存该 batch 内的中间结果就可以（这里选择 <code>batch_size=128</code>）。</p>
<p>每个 64 x 64 的矩阵-向量乘法再进行分片，变成按矩阵列分割的 64 个列向量 - 向量的内积乘法（即 $ [\alpha_1 … \alpha_{64}] [x_1 … x_{64}]^T $，每个 $ \alpha_i x_i $ 的部分和用一个 RMCM 模块实现：</p>
<img src="/paper-reading/icarus-nerf/working_principle_rmcm.png" class="" title="RMCM Principle">

<p>大概来说，是因为乘法可以变成移位加法：</p>
$$
3x = 1x << 1 + 1x
$$

<p>所以权重 load 进来的作用就是预先选择好路径上的移位和加法器，然后数据从这些器件中流过去就行。</p>
<p>另一个优化是高一半的移位和加法路径直接用上一次的值来替换，然后网络训练的时候也作此改动。这样可以节省 1&#x2F;3 的面积，同时输出基本没有视觉质量损失。</p>
<p>SONB 的架构基本上和 MONB 差不多，只是 RMCM 块用不到了，用普通的向量乘法块就可以了。</p>
<img src="/paper-reading/icarus-nerf/sonb-overview.png" class="" title="SONB Overview">

<h3 id="Volume-Rendering-Unit"><a href="#Volume-Rendering-Unit" class="headerlink" title="Volume Rendering Unit"></a>Volume Rendering Unit</h3><img src="/paper-reading/icarus-nerf/VRU-Overview.png" class="" title="VRU Overview">

<p>VRU 模块主要要负责下面的计算：</p>
<img src="/paper-reading/icarus-nerf/VRU-classic.png" class="" title="VRU Classic">

<p>这里，他处理成下面的形式：</p>
<img src="/paper-reading/icarus-nerf/VRU-rewrite.png" class="" title="VRU Rewrite">

<p>然后用上面的网络计算。</p>
<h3 id="原型验证"><a href="#原型验证" class="headerlink" title="原型验证"></a>原型验证</h3><img src="/paper-reading/icarus-nerf/FPGA-prototyping.png" class="">

<p>验证平台使用的是 Synopsys HAPS-80 S104，验证时使用的工艺是 40nm CMOS 工艺。</p>
<img src="/paper-reading/icarus-nerf/icarus-comparation.png" class="">

<!-- 
#### 调整到 Surface Light Field 任务

> TODO

-->
      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/pbr-feature-line" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/pbr-feature-line/"><strong>论文阅读 | 基于物理的特征线渲染</strong></a>
      <small class=article-date-index>&nbsp; 2022-08-28</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/pbr-feature-line/" class="article-date">
  <time datetime="2022-08-27T16:00:00.000Z" itemprop="datePublished">2022-08-28</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章介绍了基于物理的特征线渲染方法。</p>
<p>特征线渲染是一种非真实感渲染技术，常常被用在剪影、产品效果图等一些需要特殊的艺术效果的场合。</p>
<p>本篇文章提出的，基于路径方法的特征线渲染方法，是基于如下的两方面观察：</p>
<ol>
<li>从路径的角度出发，现有的特征线渲染方法将特征线处理成了光源</li>
<li>特征线相交测试可以对任意的边开展，而不仅仅是在屏幕空间中</li>
</ol>
<p>基于上面的观察，本文提出的方法</p>
<ol>
<li>对一整个路径中每条路径段分别进行和特征线的相交测试</li>
<li>将交到的特征线视为吸收所有入射光，然后辐射用户自定义颜色的光源</li>
</ol>
<blockquote>
<p>TL;DR: 用 Path Tracing 做描边，把要描的边处理成光源，让描边也有景深、色散和反射等效果。</p>
</blockquote>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法的基本架构很简单。</p>
<p>从传统的 Path Tracer 出发：</p>
<ol>
<li>对每个 path segment 依次进行和特征线的相交判断，并且</li>
<li>如果相交，则将特征线视为理想光源，并不再追下面的光源</li>
</ol>
<h3 id="相交判断"><a href="#相交判断" class="headerlink" title="相交判断"></a>相交判断</h3><p>从该 path segment 出发，以固定扩张率和当前路径总长度做一锥体，寻找锥体中的特征线。</p>
<p>实现上，本文采用从锥体较窄的一端发射查询射线，并且判断交点是否为特征线上的点的方法来进行判断，可能和 cone tracing 比较相似。</p>
<img src="/paper-reading/pbr-feature-line/cone-intersection-test.png" class="" title="cone-intersection-test">

<h3 id="采样权重修改"><a href="#采样权重修改" class="headerlink" title="采样权重修改"></a>采样权重修改</h3><p>前面提到，“如果相交，则将特征线视为理想光源，并不再追下面的光源”。本文中会将这种情况整条采样路径每个点的 pdf 值处理成和打到刚好有光源位于这里的情况完全一致。</p>
<p>不过，这样会让整个估计变成有偏估计，因为还存在有特征线（i.e. 有光源）但是没有采样到的情况，这种情况使用正常 pdf 会让最后相机处接收的 Irradiance 期望偏小，也就是特征线会比无偏的情况更不明显。</p>
<p>比较幸运的是，通过加密相交判断中发射的查询射线的数量，可以渐进的趋于无偏的情况。</p>
<img src="/paper-reading/pbr-feature-line/progressively-unbias.png" class="" title="progressively-unbias">

<h3 id="特征线判据"><a href="#特征线判据" class="headerlink" title="特征线判据"></a>特征线判据</h3><p>特征线的判断通过锥体中采样到的点和本 path segment 的起点和终点联合进行判断，主要有 MeshID, Albedo, Normal 和 Depth 四个方面的判据。</p>
<img src="/paper-reading/pbr-feature-line/feature-line-condition.png" class="" title="feature-line-condition">

<blockquote>
<p>其中 $ t_{\text{depth}} $ 文中提到有一个较为启发的设置方法。</p>
</blockquote>
<p>各项的效果如图所示：</p>
<img src="/paper-reading/pbr-feature-line/feature-line-condition-breakdown.png" class="" title="feature-line-condition-breakdown">

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>可以参考本文 Teaser：</p>
<img src="/paper-reading/pbr-feature-line/teaser.png" class="" title="teaser">

<p>可以看到，本文渲染的特征线有色散、景深模糊、反射等基于物理的效果。</p>
<h2 id="未来的工作"><a href="#未来的工作" class="headerlink" title="未来的工作"></a>未来的工作</h2><p>文章最后主要提及了如下的 Future Work：</p>
<ul>
<li>其它路径采样方法 (i.e. BDPT)</li>
<li>特征线锥形区域估计改进</li>
<li>特征线区域缓存</li>
<li>特征线模型改进<ul>
<li>反射 &#x2F; 半透特征线模型等</li>
</ul>
</li>
<li>将 lens blur 和色散效果集成到 <a target="_blank" rel="noopener" href="https://pixl.cs.princeton.edu/pubs/Cole_2006_DGI/index.php">Stylized Focus</a><ul>
<li>Stylized Focus 主要通过多个光栅化 pass 的叠加来实现风格化的景深和聚焦效果</li>
</ul>
</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
      </nav>
    

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Libre Liu&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true,
    },
    options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>
