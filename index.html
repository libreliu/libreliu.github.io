<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>libreliu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="libreliu&#39;s blog">
<meta property="og:url" content="https://blog.libreliu.info/">
<meta property="og:site_name" content="libreliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Libre Liu">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/logo.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="libreliu's blog" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/paper-summary">Paper Reading</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.libreliu.info"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer">
      <article id="post-intrusion-investigation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/intrusion-investigation/"><strong>炼丹炉被黑始末 (a.k.a. 这下服务器变回转寿司了，最美味的一集)</strong></a>
      <small class=article-date-index>&nbsp; 2024-02-28</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/intrusion-investigation/" class="article-date">
  <time datetime="2024-02-27T16:00:00.000Z" itemprop="datePublished">2024-02-28</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>炼丹炉被黑了，以下是事情经过：</p>
<h2 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h2><ul>
<li><p>2024&#x2F;2&#x2F;27：师兄发现在实验室服务器上登陆的网络通被网络信息中心留言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">您好！</span><br><span class="line"></span><br><span class="line">您使用的IP地址 xxx.xxx.xx.xxx 存在通信异常行为，</span><br><span class="line">请尽快对系统进行处理，否则网络信息中心中心将暂停该机的对外通信。</span><br><span class="line"></span><br><span class="line">科大网络信息中心 (联系方式略)</span><br><span class="line"></span><br><span class="line">异常行为：</span><br><span class="line">xxx.xxx.xx.xx大量查询域名ircx.us.too,怀疑该IP已被入侵并被远程控制。</span><br></pre></td></tr></table></figure>
<p>留言共有两条：分别为 2024&#x2F;2&#x2F;21 20:44 和 2024&#x2F;2&#x2F;27 09:31 所留，均提示高频的 IRC 服务器域名 DNS 查询。</p>
<p>我简单用 <code>tcpdump -i lo port 53</code> 看了一下，发现了一秒钟多次的 DNS 查询。因为使用了 <code>systemd-resolved</code>，DNS 服务器为 systemd 的 127.0.0.53，故可以在本地回环链路上观察到。</p>
<p>经过观察，主要有到 <code>ircx.us.to</code>, <code>irc.dal.net</code>, <code>irc.undernet.org</code> 三个域名的查询，每秒查询超过 100 次。</p>
<p>显然，服务器应该是被黑了。</p>
</li>
<li><p>2024&#x2F;2&#x2F;28：在 @taoky 的帮助下进行了比较详尽的调查，花费了一个晚上。</p>
</li>
</ul>
<h2 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h2><p>该服务器位于科大校园网内，以 100Mbps 以太网链路接入管科楼，拥有学校的 IPv4 和 IPv6 地址，没有专门的网络通，需要上网时同学会登陆自己的网络通账号。</p>
<p>服务器为 Ubuntu 20.04 LTS，插有 10 (9?) 块 RTX3090 显卡。平常同学们通过 ssh 公钥登陆，或通过 (密码 + TOTP Code) 进行登陆（采用 <code>libpam-google-authenticator</code>，参考 <a target="_blank" rel="noopener" href="https://ubuntu.com/tutorials/configure-ssh-2fa#2-installing-and-configuring-required-packages">link</a>）。</p>
<p>服务器共有 25 个用户，其中 5 个拥有 sudo 权限，3 个位于 docker 组。Docker daemon 运行在 root。</p>
<p>利用 <code>netstat -nlp</code> 可以看到上面有 pgyvpn，ZeroTier 等程序。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>大概的分析时间线如下：</p>
<h3 id="确定哪个进程在发出-DNS-请求"><a href="#确定哪个进程在发出-DNS-请求" class="headerlink" title="确定哪个进程在发出 DNS 请求"></a>确定哪个进程在发出 DNS 请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -np | grep 127.0.0.53:53 | grep udp</span><br><span class="line">udp        0      0 127.0.0.1:41511         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp      768      0 127.0.0.1:43814         127.0.0.53:53           ESTABLISHED 5973/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:44384         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:46012         127.0.0.53:53           ESTABLISHED 1989649/[           </span><br><span class="line">udp      768      0 127.0.0.1:52710         127.0.0.53:53           ESTABLISHED 5975/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:55295         127.0.0.53:53           ESTABLISHED 1989647/[           </span><br><span class="line">udp      768      0 127.0.0.1:55728         127.0.0.53:53           ESTABLISHED 5976/./nobody       </span><br><span class="line">udp        0      0 127.0.0.1:55801         127.0.0.53:53           ESTABLISHED 1986059/[kwor       </span><br><span class="line">udp        0      0 127.0.0.1:56095         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:57082         127.0.0.53:53           ESTABLISHED 2178005/[           </span><br><span class="line">udp        0      0 127.0.0.1:58772         127.0.0.53:53           ESTABLISHED -                   </span><br><span class="line">udp        0      0 127.0.0.1:59061         127.0.0.53:53           ESTABLISHED 1995387/[           </span><br><span class="line">udp        0      0 127.0.0.1:59165         127.0.0.53:53           ESTABLISHED 1986012/[           </span><br><span class="line">udp        0      0 127.0.0.1:60684         127.0.0.53:53           ESTABLISHED -                   </span><br></pre></td></tr></table></figure>

<p>可以看到怀疑对象有 PID 为 5976 和 1989649 等几个进程。</p>
<p>不过，登登登登：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ps aux | grep 5975</span><br><span class="line">lzt        40314  0.0  0.0  19764  2856 pts/11   S+   22:41   0:00 grep --color=auto 5975</span><br></pre></td></tr></table></figure>

<p>这要拜 Rootkit 所赐，因为 <code>/etc/ld.so.preload</code> 里面加入了一些内容。不过也没事，可以用静态链接的 busybox 来看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./busybox cat /etc/ld.so.preload</span><br><span class="line">/usr/local/lib/dbus-collector/libdbus_x86_64.so</span><br><span class="line">/usr/local/lib/network.so</span><br><span class="line">$ sudo ./busybox ps aux | grep 5975</span><br><span class="line"> 5975 zx        5:43 ./nobody nmop</span><br><span class="line">44054 lzt       0:00 grep --color=auto 5975</span><br><span class="line">$ sudo ./busybox readlink -f /proc/5975/exe</span><br><span class="line">/home/zx/.cpan/nobody</span><br></pre></td></tr></table></figure>

<p>仔细检查，共有下面的用户拥有 .cpan：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/spf/.cpan</span><br><span class="line">/home/xy/.cpan</span><br><span class="line">/home/zx/.cpan</span><br></pre></td></tr></table></figure>

<p>另外观察一下另外几个进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./busybox readlink -f /proc/1986059/exe</span><br><span class="line">/usr/bin/crond</span><br><span class="line">$ sudo ./busybox readlink -f /proc/1989647/exe</span><br><span class="line">/usr/bin/a</span><br><span class="line"># 下同</span><br></pre></td></tr></table></figure>

<h2 id="cron-日志暴露的内容"><a href="#cron-日志暴露的内容" class="headerlink" title="cron 日志暴露的内容"></a>cron 日志暴露的内容</h2><p>另外，在 journalctl 的 cron 条目里面可以额外发现一些信息：</p>
<details>
  <summary>太长了，点这里观看</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">2月 28 22:53:01 GPU crontab[62015]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:54:01 GPU crontab[63492]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65423]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65424]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65427]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65425]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65428]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65429]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65430]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65423]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:55:01 GPU CRON[65424]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:55:01 GPU crontab[65438]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65425]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:55:01 GPU CRON[65426]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:56:01 GPU CRON[67335]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67338]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67334]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67339]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67336]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67340]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67342]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67334]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:56:01 GPU CRON[67335]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:56:01 GPU CRON[67336]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:56:01 GPU crontab[67351]: (yyy) LIST (yyy)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:56:01 GPU CRON[67337]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69561]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69564]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69562]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69560]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69565]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69566]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69567]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69562]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:57:01 GPU CRON[69560]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:57:01 GPU CRON[69561]: pam_unix(cron:session): session closed for user root</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: (CRON) info (No MTA installed, discarding output)</span><br><span class="line">2月 28 22:57:01 GPU CRON[69563]: pam_unix(cron:session): session closed for user yyy</span><br><span class="line">2月 28 22:58:01 GPU CRON[70918]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70917]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70919]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70920]: pam_unix(cron:session): session opened for user yyy by (uid=0)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70921]: (root) CMD (/.dbus/auto &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70923]: (xy) CMD (/home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70922]: (root) CMD (/root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70924]: (yyy) CMD (/dev/shm/.m-1013/dbus-collector.seed)</span><br><span class="line">2月 28 22:58:01 GPU CRON[70919]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">2月 28 22:58:01 GPU CRON[70918]: pam_unix(cron:session): session closed for user root</span><br></pre></td></tr></table></figure>

</details>

<p>这里可以额外看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/shm/.m-1013/dbus-collector.seed</span><br><span class="line">/root/.cpan/.cache/update</span><br><span class="line">/.dbus/auto</span><br></pre></td></tr></table></figure>

<p>三个脚本。</p>
<h2 id="用户账户的信息"><a href="#用户账户的信息" class="headerlink" title="用户账户的信息"></a>用户账户的信息</h2><p>可以看到被篡改的 <code>passwd</code> 和 <code>group</code>；木马甚至贴心的留了 <code>passwd-</code> 和 <code>group-</code> 作为备份…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ diff /etc/passwd /etc/passwd-</span><br><span class="line">78d77</span><br><span class="line">&lt; ghost:x:0:0::/:/bin/bash</span><br><span class="line">$ diff /etc/group /etc/group-</span><br><span class="line">1c1</span><br><span class="line">&lt; root:x:0:</span><br><span class="line">---</span><br><span class="line">&gt; root:x:0:bin</span><br><span class="line">21c21</span><br><span class="line">&lt; sudo:x:27:omnisky,chz,lzt,gjf,hy,nobody,bin</span><br><span class="line">---</span><br><span class="line">&gt; sudo:x:27:omnisky,chz,lzt,gjf,hy,nobody</span><br></pre></td></tr></table></figure>

<p><code>lastlog</code> 中提供了一些登陆信息。其中 <code>ghost</code> (a.k.a. <code>root</code>) 账户于 2 月 26 日被另一科大 IP 地址的主机登陆。由网络信息中心的相关老师查询得知上面登陆着其它 lab 的网络通。</p>
<p><code>ghost            pts/2    xxx.xxx.xxx.xx   一 2月 26 02:42:02 +0800 2024</code></p>
<blockquote>
<p>与 root 时间相同。</p>
</blockquote>
<h2 id="日志和文件修改时间"><a href="#日志和文件修改时间" class="headerlink" title="日志和文件修改时间"></a>日志和文件修改时间</h2><p>syslog 已经被 rotate, auth.log 被 rotate 或者被入侵程序删除了。</p>
<p>auth 里面可以发现 1 月 28 号就有 crontab 活动了：</p>
<details>
  <summary>太长了，点这里观看</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Jan 28 00:00:01 GPU CRON[524365]: pam_unix(cron:session): session opened for user root by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524366]: pam_unix(cron:session): session opened for user xy by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524367]: pam_unix(cron:session): session opened for user zx by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524368]: pam_unix(cron:session): session opened for user zx by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524369]: pam_unix(cron:session): session opened for user spf by (uid=0)</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524365]: pam_unix(cron:session): session closed for user root</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524366]: pam_unix(cron:session): session closed for user xy</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524367]: pam_unix(cron:session): session closed for user zx</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524368]: pam_unix(cron:session): session closed for user zx</span><br><span class="line">Jan 28 00:00:01 GPU CRON[524369]: pam_unix(cron:session): session closed for user spf</span><br></pre></td></tr></table></figure>

</details>

<h2 id="其他异常文件"><a href="#其他异常文件" class="headerlink" title="其他异常文件"></a>其他异常文件</h2><p>根目录多了很多花里胡哨的东西。</p>
<details>
  <summary>太长了，点这里观看</summary>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ ./busybox ls -alh /</span><br><span class="line">total 13M    </span><br><span class="line">drwxr-xr-x   26 root     root        4.0K Feb 28 11:22 .</span><br><span class="line">drwxr-xr-x   26 root     root        4.0K Feb 28 11:22 ..</span><br><span class="line">drwxr-xr-x    3 10000    jyx         4.0K Feb 25 17:28 .dbus</span><br><span class="line">lrwxrwxrwx    1 root     root           7 Jan 10  2023 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x    4 root     root        4.0K Dec  1  2019 boot</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 cdrom</span><br><span class="line">drwxr-xr-x   11 root     root        4.0K Dec  1  2019 data</span><br><span class="line">drwxr-xr-x   24 root     root        4.0K Dec  1  2019 data1</span><br><span class="line">drwxr-xr-x    4 root     root        4.0K Dec  1  2019 data2</span><br><span class="line">drwxr-xr-x   19 root     root        5.6K Dec  1  2019 dev</span><br><span class="line">drwxr-xr-x  149 root     root       12.0K Feb 28 23:44 etc</span><br><span class="line">-rw-r--r--    1 root     root        8.6M Feb 25 17:03 good</span><br><span class="line">drwxr-xr-x   31 root     root        4.0K Feb 28 10:21 home</span><br><span class="line">-rwxr-xr-x    1 root     root       61.4K Dec  1  2019 kwk</span><br><span class="line">lrwxrwxrwx    1 root     root           7 Jan 10  2023 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx    1 root     root           9 Jan 10  2023 lib32 -&gt; usr/lib32</span><br><span class="line">lrwxrwxrwx    1 root     root           9 Jan 10  2023 lib64 -&gt; usr/lib64</span><br><span class="line">lrwxrwxrwx    1 root     root          10 Jan 10  2023 libx32 -&gt; usr/libx32</span><br><span class="line">drwx------    2 root     root       16.0K Dec  1  2019 lost+found</span><br><span class="line">drwxr-xr-x    3 root     root        4.0K Dec  1  2019 media</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 mnt</span><br><span class="line">-rwxr-xr-x    1 root     root        4.0M Dec  1  2019 mx</span><br><span class="line">drwxr-xr-x   24 root     root        4.0K Dec  1  2019 old_os</span><br><span class="line">drwxr-xr-x    7 root     root        4.0K Dec  1  2019 opt</span><br><span class="line">dr-xr-xr-x 1422 root     root           0 Dec  1  2019 proc</span><br><span class="line">drwx------   12 root     root        4.0K Feb 28 23:44 root</span><br><span class="line">drwxr-xr-x   39 root     root        1.3K Feb 29 00:29 run</span><br><span class="line">lrwxrwxrwx    1 root     root           8 Jan 10  2023 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   11 root     root        4.0K Dec  1  2019 snap</span><br><span class="line">drwxr-xr-x    2 root     root        4.0K Dec  1  2019 srv</span><br><span class="line">dr-xr-xr-x   13 root     root           0 Dec  1  2019 sys</span><br><span class="line">drwxrwxrwt  647 root     root      148.0K Feb 29 00:30 tmp</span><br><span class="line">drwxr-xr-x   14 root     root        4.0K Dec  1  2019 usr</span><br><span class="line">drwxr-xr-x   16 root     root        4.0K Dec  1  2019 var</span><br><span class="line">drwxrwxr-x    2 root     root        4.0K Feb 28 11:26 x</span><br></pre></td></tr></table></figure>

</details>

<p>多了 <code>/x</code>，<code>/mx</code> 和 <code>/kwk</code>，<code>/good</code>，<code>/.dbus</code>。</p>
<h2 id="crontab-分析"><a href="#crontab-分析" class="headerlink" title="crontab 分析"></a>crontab 分析</h2><details>
  <summary>太长了，点这里观看</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ls -alh /var/spool/cron/crontabs/</span><br><span class="line">total 28K</span><br><span class="line">drwx-wx--T 2 root crontab 4.0K 2月  26 13:57 .</span><br><span class="line">drwxr-xr-x 3 root root    4.0K 8月  31  2022 ..</span><br><span class="line">-rw------- 1 root crontab  291 2月  25 17:28 root</span><br><span class="line">-rw------- 1 spf  crontab  277 2月  17  2023 spf</span><br><span class="line">-rw------- 1 xy   crontab  233 2月  17  2023 xy</span><br><span class="line">-rw------- 1 yyy  crontab  261 2月  26 13:57 yyy</span><br><span class="line">-rw------- 1 zx   crontab  343 2月  20  2023 zx</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/yyy</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (- installed on Mon Feb 26 13:57:19 2024)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line"># DO NOT REMOVE THIS LINE. dbus-kernel</span><br><span class="line">* * * * * /dev/shm/.m-1013/dbus-collector.seed</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/root</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (/tmp/crontab.ZblArV/crontab installed on Sun Feb 25 17:28:18 2024)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">* * * * * /.dbus/auto &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /root/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/zx</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (.autobotchk1676891606017226.97733 installed on Mon Feb 20 19:13:26 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">0,10,20,30,40,50 * * * * /home/zx/.cpan/dumb.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">0,10,20,30,40,50 * * * * /home/zx/.cpan/nmop.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/spf</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (.autobotchk1676636637503791.1778717 installed on Fri Feb 17 20:23:57 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">0,10,20,30,40,50 * * * * /home/spf/.cpan/spf.botchk &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">$ sudo cat /var/spool/cron/crontabs/xy</span><br><span class="line"># DO NOT EDIT THIS FILE - edit the master and reinstall.</span><br><span class="line"># (cron installed on Fri Feb 17 18:26:23 2023)</span><br><span class="line"># (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</span><br><span class="line">* * * * * /home/xy/.cpan/.cache/update &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

</details>

<p>其中 <code>/home/xy/.cpan/.cache/update</code> 脚本的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">if test -r /home/xy/.cpan/.cache/mech.pid; then</span><br><span class="line">pid=$(cat /home/xy/.cpan/.cache/mech.pid)</span><br><span class="line">if $(kill -CHLD $pid &gt;/dev/null 2&gt;&amp;1)</span><br><span class="line">then</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">cd /home/xy/.cpan/.cache</span><br><span class="line">./run &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>其实就是调用 run 的，然后 run 来启动 botnet 的客户端。</p>
<h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><blockquote>
<p>Special thanks to @taoky.</p>
</blockquote>
<ul>
<li><code>/kwk</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/6e4d58a1fe5d7add270d5819ac8e8c17a0aff8d928be185d563b569759972979">VirusTotal</a><ul>
<li>会把自己假装成 <code>[kworker/0:0]</code></li>
<li>作为 IRCBot 连接到 <code>#ddoser</code> 频道</li>
</ul>
</li>
<li><code>/mx</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/c21368ef860eaef0ac1c259f1fb584ab752044824021d8ca9455b41c44f2b08a">VirusTotal</a><ul>
<li>加壳了的 golang 程序</li>
</ul>
</li>
<li><code>/good</code> 是个 tar.gz，里面看起来是那个 “dbus” 程序，可以用来挖门罗币<ul>
<li><code>README</code>: <del>最担心你不会用恶意软件的一集</del><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(: I MAKE THIS FOR FREE, SHARE IT IF YOU LIKE :)</span><br><span class="line">  ==========================================</span><br><span class="line">            noname but not nobody</span><br><span class="line"></span><br><span class="line">This miner can run as root or user :)</span><br><span class="line"></span><br><span class="line">Simple &amp; easy to use. No naughty backdoor.</span><br><span class="line"></span><br><span class="line">Commands :</span><br><span class="line">----------</span><br><span class="line">1. Create config.json first, use : ./mkcfg &lt;Mining Pool:Port&gt; &lt;Worker ID&gt; &lt;Wallet&gt;</span><br><span class="line">2. Start the mining : ./start</span><br><span class="line"></span><br><span class="line">Note :</span><br><span class="line">------</span><br><span class="line">For proxy, use : ./mkcfg &lt;Mining Pool Proxy:Port&gt; &lt;Worker ID&gt; &lt;Wallet&gt;</span><br><span class="line"></span><br><span class="line">Extra :</span><br><span class="line">------</span><br><span class="line">32       = Change into 32-bit</span><br><span class="line">64       = Change into 64-bit</span><br><span class="line">power-on = Extra command :D</span><br><span class="line"></span><br><span class="line">Source files from https://github.com/xmrig (has no virus except you&#x27;re gay)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><code>dbus/bash</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/e9422ff3a83835b47aac93912eca4de2c5d361d0a743672bf7ae6621ea10c226">VirusTotal</a></li>
<li><code>dbus/hide</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/b21d43db4ea65ac178199d1aed1fea0352de0f268a46fbc13fcb719ce50042c9">VirusTotal</a></li>
<li><code>dbus/power-on</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/738abe5627539b952768e19135db62aac37469e6c9a4f08b29e61bee30ef6cdf">VirusTotal</a><ul>
<li>作为 IRCBot 连接到 <code>#kaiten</code> 频道<blockquote>
<p>“Kaiten”这个名称源自日语，意为“回转寿司”，可能是因为这种恶意软件就像回转寿司那样在受控系统之间“旋转”指令。通过IRC频道，攻击者可以远程控制和指挥受感染的机器进行各种活动，包括但不限于发动DDoS攻击、窃取数据、安装更多的恶意软件等。</p>
<p><strong>“这下服务器变回转寿司了，最美味的一集”</strong> (courtesy @taoky)</p>
</blockquote>
</li>
<li>会把自己假装成 <code>[kworker/0:0]</code></li>
<li>可以执行一系列 DDoS 攻击和 remote code execution 命令</li>
</ul>
</li>
<li><code>xtra/</code>:<ul>
<li><code>centos</code> <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/efebb75160eda563e3684619d0ace367366b18bb180fcdbbdbe83269fd530e28">VirusTotal</a></li>
<li><code>ubuntu</code> <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/137f0a89bd16dd0fcc89229bf6de37a230d49e812b47b4482aff6db45b7ac74a">VirusTotal</a></li>
<li><code>32</code> <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/b63b26edbaf0a95cb34d72cfe5aef3ee3c8a565b98faa1ee51c3694b10720837">VirusTotal</a></li>
<li><code>64</code> <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/a7155491bcde2c4bc89f9f37d03c668e32cdb15ad992dd8c3d96b709b494a542">VirusTotal</a></li>
</ul>
</li>
</ul>
</li>
<li><code>/home/spf/.cpan/</code>: 一个 botnet 程序，里面一堆 Tcl 脚本和一些可执行文件<ul>
<li><code>hide</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/e560ae6672fc7c09bfb72f6a1939f0b03108ed5b0a7d2ef1f5c49211e9d6d02c">VirusTotal</a></li>
<li><code>nobody</code>: 无检出，strings 一把看起来像 Tcl 解释器 + 一些奇怪东西，<a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/3fcfaa232e3471c5d40c9396507291d3be34eaafb60f44fd243f23974bd5f001">VirusTotal</a></li>
</ul>
</li>
<li><code>/dev/shm/.m-1013/dbus-collector</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/21c6dfcbd865b57cf5a15f4dc9498e378a7ccec7bbea9ff446884a9b5cb572ec/">VirusTotal</a></li>
<li><code>/x</code>: 端口扫描和 SSH 暴力攻击程序<ul>
<li><code>x/ban</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/2ef26484ec9e70f9ba9273a9a7333af195fb35d410baf19055eacbfa157ef251">VirusTotal</a></li>
<li><code>x/m</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/9aa8a11a52b21035ef7badb3f709fa9aa7e757788ad6100b4086f1c6a18c8ab2">VirusTotal</a></li>
<li><code>x/SSH</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/6163a3ca3be7c3b6e8449722f316be66079207e493830c1cf4e114128f4fb6a4">VirusTotal</a></li>
</ul>
</li>
<li><code>/usr/local/lib/dbus-collector/libdbus_x86_64.so</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/2aed4d101703a74dcc0f5c51506cc376136872c864fc0484a5684cda9c81685b">VirusTotal</a><ul>
<li>尝试隐藏 <code>dbus_collector</code>，通过 hook readdir{64} 并且解析是否是对 <code>/proc</code> 的列目录；如果是，则返回去掉自己结果的列目录结果，从而达到在 ps 和 htop 等工具中隐藏的目的</li>
</ul>
</li>
<li><code>/usr/local/lib/network.so</code>: <a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/file/987d390480b55dcf61e18106b326e706a7a14c7cb6c8f13c35a5b90e068166b6">VirusTotal</a><ul>
<li>尝试隐藏自己，通过 hook readdir{64} 并且解析是否是对 <code>/proc</code> 的列目录；如果是，则返回去掉自己结果的列目录结果，从而达到在 ps 和 htop 等工具中隐藏的目的</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>病毒已经有 root 权限</li>
<li>由于发现的比较晚，很多日志 rotate 了，并且日志没有配置实时发送到远程服务器等，导致基本很难断定最初的入侵是什么时候发生的。不过基本可以确定，病毒最早在 1 月 28 日或之前就已经黑进系统了。</li>
<li>系统里面一共有四种类型的病毒：挖矿病毒，DDoS肉鸡病毒，远程控制病毒，SSH扫描病毒；同时，有病毒有隐藏功能，会在 &#x2F;etc&#x2F;ld.so.preload 里面写上自己的动态库，导致所有动态链接的程序运行前均调用病毒程序</li>
<li>远程控制病毒会互相连接，并且存在通过authorized_keys互相跳转的可能性；但是auth.log已经看不到那么远的日志了，可能是被rotate或者删除了</li>
<li>可以通过publickey方式登陆服务器的账户最好检查一下自己的主机是否已经中毒（因为publickey跳转是一种可能的感染路径，虽然没有读 code 证实）</li>
</ol>
<p>远程控制病毒用的是 IRC 和黑客以及其他节点保持连接，并且存在对方进一步下载其它payload（比如，勒索病毒）的可能性。</p>
<blockquote>
<p>此时只能建议大家赶紧备份数据到自己的机器，同时注意服务器上所有的可执行程序都应该认为是<em>不可信任的</em>：即，存在被病毒感染的可能性。有些存在任意代码执行的文件格式也存在被入侵的理论可能（比如 torch 非 safetensor 的 checkpoint 文件）</p>
</blockquote>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-mesa-radv-digestion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/mesa-radv-digestion/"><strong>Mesa radv 源码阅读（一）: 如何跟踪图形栈、Vulkan Loader、Mesa 派发机制</strong></a>
      <small class=article-date-index>&nbsp; 2023-07-02</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/mesa-radv-digestion/" class="article-date">
  <time datetime="2023-07-01T16:00:00.000Z" itemprop="datePublished">2023-07-02</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>变更记录:</p>
<ul>
<li>2023-02-11: 开始写作本文</li>
<li>2023-02-16: 基本完成</li>
<li>2023-07-02: 移出草稿区</li>
</ul>
</blockquote>
<p>Mesa radv 全称 Mesa Vulkan Radeon 驱动，用于 Linux 桌面平台下 AMD Radeon 独立和集成显示卡的 Vulkan 用户态驱动支持。本文主要为备忘性质，记录笔者调试和跟踪代码过程中的发现。</p>
<p>笔者本人接触 Linux 图形栈的时间并不很长，其中很多地方还不甚明了，如有缺漏之处，请批评指正。</p>
<p>您可以在博客对应的<a target="_blank" rel="noopener" href="https://github.com/libreliu/libreliu.github.io">仓库</a> 的 Issue 区和我取得联系。</p>
<blockquote>
<p>本文的实验均开展于截至写作时最新版本的 Arch Linux。<br>使用的主要软件版本如下：</p>
<ul>
<li>mesa 22.3.3<ul>
<li><a target="_blank" rel="noopener" href="https://gitlab.freedesktop.org/mesa/mesa/">https://gitlab.freedesktop.org/mesa/mesa/</a></li>
</ul>
</li>
<li>vulkan-icd-loader 1.3.240<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader">https://github.com/KhronosGroup/Vulkan-Loader</a></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="前言：如何跟踪-Linux-图形栈？"><a href="#前言：如何跟踪-Linux-图形栈？" class="headerlink" title="前言：如何跟踪 Linux 图形栈？"></a>前言：如何跟踪 Linux 图形栈？</h2><p>截至目前，笔者认为图形栈的跟踪和开发，较常规的 Linux 服务端开发等工作要更为复杂。</p>
<p>这种复杂性主要来源于：</p>
<ol>
<li>厂商图形实现是高度定制化的，在通用图形 API (e.g. Vulkan, OpenGL) 下，厂商有很大的自由度来填补从用户程序图形 API 到真正向图形处理器发送命令的过程<ul>
<li>e.g. AMD 的 mesa Vulkan 开源驱动 radv 会经过 vulkan-icd-loader 到 mesa 到 libdrm 到内核态 amdgpu</li>
</ul>
</li>
<li>用户的图形应用程序还需要经过窗口系统和混成器 (compositor) 才能显示到屏幕上，图形实现需要和混成器紧密配合<ul>
<li>X11 (DIX, DDX), GLX, DRI2, DRI3, Wayland, egl…</li>
<li>历史包袱比较多</li>
</ul>
</li>
</ol>
<p>除此之外，上面的两个方面，其中各个环节的接口文档都不甚清晰，且接口演进也比较频繁，很多时候需要「一竿子捅到底」，将各个库和软件的源码连在一起阅读，才知道真正发生了什么。</p>
<h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><p>针对这种情况，首先需要比较方便的 C&#x2F;C++ 源码阅读软件，笔者目前使用的是 OpenGrok。</p>
<p>该软件对源码的语义理解并不很强，因为其仅仅是采用 ctags 的方法进行简单的解析，对于需要经过预处理器的一些嵌入的宏 （比如 <code>#define WSI_CB(cb) PFN_vk##cb cb</code> 这种样式的成员定义宏）支持并不好。其优势主要体现在跳转快速 (HTML 链接点击即跳转)，以及还算方便的 Full search 功能（比如要搜索某个函数指针成员 <code>wait</code> 在哪里被调用，可以搜 <code>&quot;-&gt;wait&quot;</code> 和 <code>&quot;.wait&quot;</code>）。某种意义上，笔者认为该软件可以认为是本地部署的、可以看不仅仅是内核的软件代码的增强版本 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/">elixir</a>。</p>
<blockquote>
<p>其实感觉可以做一个用 Arch Linux 的 makepkg 构建过程中生成 <code>compile_commands.json</code> 并且用这个信息来指导源码阅读的工作流，最好信息都可以离线 bake 然后静态的托管到某些网站上。目前我还没发现有这样的工具存在。</p>
<p>TODO: 调研<a target="_blank" rel="noopener" href="https://github.com/KDAB/codebrowser">静态的 CodeBrowser</a>。</p>
</blockquote>
<p>另一个比较有用的准备工作是，把一个软件包的依赖的源码全部下载下来放在一起，统一放到 OpenGrok 里面，这样可以极大加速跨软件包的符号和定义的查找工作。</p>
<blockquote>
<p>这里我选择 Arch Linux 的 pacman 包作为起点进行依赖查找。</p>
<p>值得注意的是，Arch 的包管理模型中有 “虚拟包” 的概念，比如 <code>opengl-driver</code> 可以被 depend 和 provide，但是并不对应一个具体的包；这样的依赖很多时候需要人工去 resolve。</p>
<p>TODO: 等整套工具比较完善之后，写一篇博客介绍如何将系列包的源码全部拉下来。</p>
</blockquote>
<h3 id="动态跟踪"><a href="#动态跟踪" class="headerlink" title="动态跟踪"></a>动态跟踪</h3><p>另一个十分有用的步骤自然是运行时的行为跟踪了。</p>
<p>行为跟踪主要是采用 GDB + debuginfod + (感兴趣的软件包的) <code>-debug</code> 软件包。</p>
<p>在没有加载调试符号的情况下，GDB 的 <code>step</code> 似乎会直接越过外部函数，这种时候可以考虑 <code>layout asm</code> 看汇编，用 <code>stepi</code> 进到 call 指令里面去，GDB 此时的 backtrace 会打印出该函数所在地址对应的动态链接库 (当然，应该是从进程地址空间信息 <code>/proc/&lt;PID&gt;/maps</code> 反查的)，但具体的函数则不详。动态链接库信息可以用来让你想想到底是什么东西缺符号。</p>
<p>正确配置的 debuginfod 可以完成自动拉取加载的动态链接库的符号的工作，不过要看到源码本身还是需要安装 debug 包。</p>
<blockquote>
<p>安装好 -debug 包后，对应的源码会在 <code>/usr/src/debug/</code> 下。</p>
</blockquote>
<p>debug 包的主要获取方法有两种，详情可以参考 <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Debugging/Getting_traces">Debugging&#x2F;Getting traces - ArchWiki</a>：</p>
<ol>
<li>特定的 Archlinux mirror<ul>
<li><a target="_blank" rel="noopener" href="https://geo.mirror.pkgbuild.com/">https://geo.mirror.pkgbuild.com/</a></li>
<li>但是个别包似乎会出现 debug 包内源码不全的情况，如 <code>vulkan-icd-loader</code>，不清楚具体原因；方法 2 无此问题</li>
</ul>
</li>
<li>自己编译</li>
</ol>
<p>关于如何编译 debug 包，值得简单记两笔。</p>
<p>打 debug 包需要 </p>
<ol>
<li>拉 PKGBUILD <ul>
<li>可以考虑用 <code>asp</code> 这个工具自动从 GitHub (https 的话需要配合 <code>proxychains</code> 科学上网) 上面拉对应的 recipe </li>
<li><a target="_blank" rel="noopener" href="https://xyne.dev/projects/pbget/">pbget</a> 这个工具不知道是否可以用于自动化的把依赖项目的 recipe 全部拉下来 (?)<ul>
<li>我自己测试是不行，不过是用 Python 3 + pyalpm 写的，有一定的研究和修改价值</li>
</ul>
</li>
</ul>
</li>
<li>进行编译<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/DeveloperWiki:Building_in_a_clean_chroot">ArchWiki</a> 推荐使用 clean chroot 编译，这样也方便设定单独的 makepkg 的设置 </li>
<li>使用 Wiki 中描述的，方便的方法如下：<ol>
<li>安装 devtools 包 </li>
<li>更改 chroot 环境内的 makepkg 配置，启用 OPTIONS 中的 debug 和 strip<ul>
<li><code>/usr/share/devtools/makepkg-$&#123;arch&#125;.conf</code> 这里 arch 选择 x86_64</li>
<li>(optional) 把并行编译的 -j 也设置好，不过有些构建系统会自动检测并启用并行编译</li>
</ul>
</li>
<li>在有 PKGBULID 的文件夹下面运行 <code>extra-x86_64-build</code>，然后装源码包和二进制包 （pacman -U)<ul>
<li>包检查不过去没啥事；两个包都要装上，因为调试符号匹配的时候应该是有一个随机生成的 UUID 来做的</li>
<li>如果想给 makepkg 传参需要加两个 –，比如 <code>extra-x86_64-build -- -- --skippgpcheck</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>在看 elfutils 的时候同时看到了一个工具 <code>eu-stack</code>，可以用来截取某个进程当前时刻所有线程的栈信息，并且可以加选项 <code>-m</code> 来用 debuginfod 进行符号查找。</p>
<p>感觉在分析 GUI 程序高 CPU 占用的性能分析的场合，<code>eu-stack</code> 可以作为一种采样手段使用。</p>
<h2 id="Vulkan-Loader"><a href="#Vulkan-Loader" class="headerlink" title="Vulkan Loader"></a>Vulkan Loader</h2><p>Vulkan Loader 是垫在各个 Vulkan 驱动和用户程序中间的层，主要用来解决多设备枚举使用的问题。</p>
<h3 id="驱动枚举"><a href="#驱动枚举" class="headerlink" title="驱动枚举"></a>驱动枚举</h3><p>Vulkan Loader 有默认的 ICD (Installable Client Driver) 的<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-discovery-on-linux">搜索路径</a>，向系统中安装的驱动程序会通过在给定的 ICD 路径（可能是文件夹，也可能是 Windows 注册表）中写入信息的方式来向 Vulkan Loader 报告自己的信息。</p>
<p>例如，<code>/usr/share/vulkan/icd.d/radeon_icd.x86_64.json</code> 中的信息如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ICD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;api_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.3.230&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;library_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/lib/libvulkan_radeon.so&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file_format_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，核心的信息是 <code>library_path</code>。(Ref: <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-manifest-file-format">LoaderDriverInterface.md @ Vulkan-Loader</a>)</p>
<p>另一种传入 ICD 信息的方法是 <code>VK_DRIVER_FILES</code> 环境变量（<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderInterfaceArchitecture.md#elevated-privilege-caveats">不过在 root 权限下无效</a>），可以通过指定这个变量的方式，强制 Vulkan Loader 只考虑某些路径。</p>
<p>比如 <code>VK_DRIVER_FILES=/usr/share/vulkan/icd.d/radeon_icd.x86_64.json vulkaninfo</code> 可以只启用 mesa radv 实现。</p>
<h3 id="驱动入口发现"><a href="#驱动入口发现" class="headerlink" title="驱动入口发现"></a>驱动入口发现</h3><p>每个驱动要实现 <code>vk_icdGetInstanceProcAddr</code> 这个调用，和 (&gt;&#x3D; Version 4) <code>vk_icdGetPhysicalDeviceProcAddr</code> 这个调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(VKAPI_PTR *PFN_vkVoidFunction)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的调用，如 vkCreateInstance，会把第一个参数置为空</span></span><br><span class="line"><span class="comment">// 先用这个调用拿到 `vkGetDeviceProcAddr`，再进行 device level 的调用</span></span><br><span class="line">VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL <span class="title function_">vk_icdGetInstanceProcAddr</span><span class="params">(</span></span><br><span class="line"><span class="params">   VkInstance instance,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span>* pName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要用于 VkPhysicalDevice 为第一个参数的 Vulkan API 派发</span></span><br><span class="line"><span class="comment">// - 否则 Vulkan Loader 会认为这个命令是 logical device command，</span></span><br><span class="line"><span class="comment">//   从而尝试传入 VkDevice 对象 </span></span><br><span class="line"><span class="comment">// 典型用途是一些 loader 不知道的物理设备扩展</span></span><br><span class="line"><span class="comment">// (&gt;= Version 7) 这个接口需要可以从 vk_icdGetInstanceProcAddr 获得</span></span><br><span class="line">PFN_vkVoidFunction <span class="title function_">vk_icdGetPhysicalDeviceProcAddr</span><span class="params">(</span></span><br><span class="line"><span class="params">   VkInstance instance,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span>* pName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>有些厂商会在同一个库里面实现几套 API 的用户态实现 (e.g. <code>nvidia_icd.json</code> 中的 <code>libGLX_nvidia.so.0</code>)，但驱动程序不能把 Vulkan 官方的函数名占用掉。</p>
<p>动态链接到 Vulkan Loader 的<strong>用户程序</strong>是通过系统例程 (<code>dlsym</code> 或者 <code>GetProcAddress</code>) 获得 <code>vkGetInstanceProcAddr</code> 和 <code>vkGetDeviceProcAddr</code> 两个函数的地址并且调用的方式来枚举其它 Vulkan API 调用的函数地址的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, <span class="type">const</span> <span class="type">char</span>* pName)</span><br><span class="line">PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, <span class="type">const</span> <span class="type">char</span>* pName)</span><br></pre></td></tr></table></figure>

<p>Loader 的 <code>vkGetInstanceProcAddr</code> 的行为在<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-unknown-physical-device-extensions">官方文档</a>中有记录。</p>
<p>简单来说，就是用 <code>vk_icdGetInstanceProcAddr</code> 一路往下找，找到的会记录在跳转表中，之后在 terminator 那边可以直接跳转过去，不用再获取。</p>
<h3 id="驱动-Vulkan-对象句柄要求"><a href="#驱动-Vulkan-对象句柄要求" class="headerlink" title="驱动 Vulkan 对象句柄要求"></a>驱动 Vulkan 对象句柄要求</h3><blockquote>
<p>Ref: <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-dispatchable-object-creation">https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#driver-dispatchable-object-creation</a></p>
</blockquote>
<p>另一个值得了解的是 Vulkan 对象模型。<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#fundamentals-objectmodel-overview">3.3 Object Model @ Vulkan Spec</a> 中提到，Vulkan API 层面提供的 <code>VkXXXXX</code> 等类型均为 Vulkan 对象的句柄，句柄分为可分派的 (dispatchable) 和不可分派的 (non-dispatchable) 两种。</p>
<ul>
<li>可分派句柄 <code>VK_DEFINE_HANDLE()</code>: 指向某对用户不可见的具体实现类型的指针<ul>
<li>截至 Vulkan SDK 1.3.236 有 <code>VkInstance</code>, <code>VkPhysicalDevice</code>, <code>VkDevice</code>, <code>VkQueue</code>, <code>VkCommandBuffer</code></li>
</ul>
</li>
<li>不可分派句柄 <code>VK_DEFINE_NON_DISPATCHABLE_HANDLE()</code>：64-bit 整数类型，具体意义由实现决定<ul>
<li>如果开启了 <a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#private-data">Private Data</a> 扩展的话，显然也得是指向内部实现类型的某指针（类似可分派句柄）</li>
<li>否则，实现可以决定在这 64-bit 里面直接编码好信息，不用指针</li>
</ul>
</li>
</ul>
<p>在此基础上，Vulkan Loader 要求驱动程序返回可分派句柄时：</p>
<ol>
<li>句柄作为指针指向的内部实现的前 <code>sizeof(uintptr)</code> 个字节要空出来，留待 Vulkan Loader 将这一位置的值替换成跳转表地址<ul>
<li>这也要求，指向的内部实现需要是 POD 的，否则可能会有虚表等结构加在实例前面，和这一要求冲突</li>
</ul>
</li>
<li>这个空出来的位置，需要调用 <code>include/vulkan/vk_icd.h</code> 中的 <code>set_loader_magic_value</code> 设置成 <code>ICD_LOADER_MAGIC</code> (目前是 <code>0x01CDC0DE</code>)，Vulkan Loader 拿到之后会用 <code>valid_loader_magic_value</code> 来检测驱动程序是否正确实现了这一要求</li>
</ol>
<h3 id="特例-WSI-扩展"><a href="#特例-WSI-扩展" class="headerlink" title="特例: WSI 扩展"></a>特例: WSI 扩展</h3><blockquote>
<p>Ref: <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#handling-khr-surface-objects-in-wsi-extensions">https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderDriverInterface.md#handling-khr-surface-objects-in-wsi-extensions</a></p>
</blockquote>
<p>在下面的平台上，<code>VkSurfaceKHR</code> 可以由 Vulkan Loader 负责创建和销毁：</p>
<ul>
<li>Wayland, XCB, Xlib</li>
<li>Windows</li>
<li>Android, MacOS, QNX</li>
</ul>
<p>对相应的 <code>vkCreateXXXSurfaceKHR</code> 调用，Loader 创建 VkIcdSurfaceXXX 结构，驱动程序拿到 <code>VkSurfaceKHR</code> 后可以将其视为到 <code>VkIcdSurfaceXXX</code> 的指针。</p>
<p>不过，如果驱动想自己接管，暴露所有 WSI KHR 要求的接口给驱动就可以了 (创建销毁，枚举 Surface 相关属性、呈现模式，创建交换链)。</p>
<h2 id="Mesa-Vulkan-radv"><a href="#Mesa-Vulkan-radv" class="headerlink" title="Mesa Vulkan radv"></a>Mesa Vulkan radv</h2><p>Mesa 是一个相对比较庞大的项目。</p>
<p>本次要看的 Mesa Vulkan radv 驱动的代码主要分布在：</p>
<ul>
<li><code>src/amd/vulkan/</code>: radv_ 开头的主要代码</li>
<li><code>src/vulkan</code>: 驱动公共设施</li>
</ul>
<p>Mesa 的构建系统使用 Meson，<code>src/amd/vulkan/meson.build</code> 中的 <code>libvulkan_radeon</code> 就是构建出的 radv 驱动动态链接库了。</p>
<h3 id="函数派发"><a href="#函数派发" class="headerlink" title="函数派发"></a>函数派发</h3><blockquote>
<p>Ref: <a target="_blank" rel="noopener" href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/docs/vulkan/dispatch.rst">https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/docs/vulkan/dispatch.rst</a></p>
</blockquote>
<p>我们先看 <code>vk_icdGetInstanceProcAddr</code> 的派发流程：</p>
<ul>
<li><code>vk_icdGetInstanceProcAddr</code> (src&#x2F;amd&#x2F;vulkan&#x2F;radv_device.c)</li>
<li><code>radv_GetInstanceProcAddr</code>  (src&#x2F;amd&#x2F;vulkan&#x2F;radv_device.c)</li>
<li><code>vk_instance_get_proc_addr</code> (src&#x2F;vulkan&#x2F;runtime&#x2F;vk_instance.c)</li>
</ul>
<p>传入的 <code>radv_instance_entrypoints</code> 是一个全局变量，给出了 Instance Level 的驱动实现的函数指针。其<strong>内容</strong>是在构建过程中生成的 <code>src/amd/vulkan/radv_entrypoints.c</code> 中赋值的，而<strong>类型</strong>则是在构建过程中生成的 <code>src/vulkan/util/vk_dispatch_table.h</code> 中定义的 <code>vk_instance_entrypoint_table</code> 类型的结构体。</p>
<p><code>radv_entrypoints.c</code> 定义了很多 <code>radv_XXXX</code> 形式的弱符号，并且将这些符号凑成了</p>
<ul>
<li><code>radv_instance_entrypoints</code></li>
<li><code>radv_physical_device_entrypoints</code></li>
<li><code>radv_device_entrypoints</code></li>
<li><code>sqtt_device_entrypoints</code></li>
<li><code>metro_exodus_device_entrypoints</code></li>
<li><code>rra_device_entrypoints</code></li>
</ul>
<p>几张表，表中填写了全部弱符号的值。根据弱符号的性质，如果程序中的其他地方没有定义相应的函数，对应的值就会为空。</p>
<p><code>vk_dispatch_table.h</code> 和 <code>vk_dispatch_table.c</code> 本身是用 <code>vk_dispatch_table_gen.py</code> 和 Vulkan Registry XML 生成出来的。</p>
<p>而常用的这几个派发用的函数都是在生成的 <code>vk_dispatch_table.c</code> 中定义的：</p>
<ul>
<li><code>vk_instance_dispatch_table_get_if_supported</code></li>
<li><code>vk_physical_device_dispatch_table_get_if_supported</code></li>
<li><code>vk_device_dispatch_table_get_if_supported</code></li>
</ul>
<p>如果对应的函数实际上没有实现 (比如 <code>radv_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI</code> 这个华为公司的扩展显然就没有)，那么前面几个派发表查询函数查询的结果就会为 NULL。</p>
<p>至于 CreateDevice 等处出现的 <code>vk_instance_dispatch_table</code>，则是多个 entrypoint table “综合”的结果，这样就可以实现比如 <code>radv_xxx</code> 没有就回退到 <code>vk_common_xxx</code> 的效果。</p>
<h3 id="vk-common-xxx"><a href="#vk-common-xxx" class="headerlink" title="vk_common_xxx"></a><code>vk_common_xxx</code></h3><p>一些公共入口点，里面包含了：</p>
<ul>
<li>用 <code>VkFoo2()</code> 实现 <code>VkFoo()</code> 的一些替代逻辑，这样驱动就可以把老的接口删掉，由中间层来做兼容</li>
<li>VkFence，VkSemaphore 和 VkQueueSubmit2 的默认实现<ul>
<li>当然，也需要驱动提供一些东西，比如 <code>vk_sync_type</code> 的实现</li>
</ul>
</li>
</ul>
<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><ul>
<li><code>radv_physical_device</code>: <del>万物之始</del><ul>
<li><code>radv_CreateDevice</code></li>
</ul>
</li>
<li>句柄操作：<ul>
<li><code>VK_DEFINE_HANDLE_CASTS</code>: 定义（带自己搓的类型检查的）转换函数</li>
<li><code>VK_FROM_HANDLE</code>：从 <code>VkXXX</code> 转到 Mesa 驱动自己的结构体的句柄</li>
</ul>
</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-qem-mesh-simplification" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/qem-mesh-simplification/"><strong>可能是史上最详尽的 QEM 网格简化算法解释</strong></a>
      <small class=article-date-index>&nbsp; 2023-04-11</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/qem-mesh-simplification/" class="article-date">
  <time datetime="2023-04-10T16:00:00.000Z" itemprop="datePublished">2023-04-11</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>注：请根据上下文猜测哪些是矢量，哪些是标量，因为作者懒得打了。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QEM 算法（<a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=288280">Garland and Heckbert [1998]</a>）是网格简化领域的经典算法。</p>
<h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><p><a target="_blank" rel="noopener" href="https://github.com/byreave/MeshSimplification-QEM">GitHub - byreave&#x2F;MeshSimplification-QEM: A C++implementation of QEM algorithm.</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/WZFish/QEM-MeshSimplification">GitHub - WZFish&#x2F;QEM-MeshSimplification</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/songrun/SeamAwareDecimater">GitHub - songrun&#x2F;SeamAwareDecimater: Mesh simplification with UV’s boundary preserved</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/MeshFrame/MeshFrame/blob/master/Examples/MeshSimplifyQEM/mesh.cpp">GitHub - MeshFrame&#x2F;MeshFrame: A light-weighted, efficient and header-only mesh processing frame work</a></p>
<h2 id="QEM-Original"><a href="#QEM-Original" class="headerlink" title="QEM Original"></a>QEM Original</h2><blockquote>
<p>出现于文章 <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">Surface Simplification Using Quadric Error Metrics</a> 中</p>
</blockquote>
<h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>设现在有网格 $ M &#x3D; (V, F) $，规定<strong>可收缩顶点对</strong>为</p>
<ol>
<li>原网格中的边</li>
<li>$ \| v_1 - v_2\| < \epsilon $ 的顶点对 $ (v_1, v_2) $</li>
</ol>
<p>对每个三角形 $ F_i $，设构成该三角形的三个顶点为 $ v_0, v_1, v_2 $，则 $ F_i $ 上的点 $ v_f $ 满足方程</p>
$$
(\vec v_f- \vec v_0) \cdot \vec n = 0 \Rightarrow \vec v_f \cdot \vec n - \vec {v_0} \cdot \vec n = 0
$$

<p>其中面法线 $ \vec n $ 满足</p>
$$
\vec {n} =  \frac{(\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0)}{\| (\vec v_1 -\vec  v_0) \times (\vec v_2 - \vec v_0) \|}
$$


<p>空间中任意一点 $ v $ 到平面 $ F_i $ 的距离的平方为</p>
$$
\begin{aligned}
d^2(v, F_i) &= \| (\vec v-\vec v_0) \cdot \vec n \|^2 \\
&= (n^\mathbf{T} v - n^\mathbf{T} v_0 )^2 \\
&= v^\mathbf{T} (nn^\mathbf{T}) v - 2 n^\mathbf{T} v_0 n^\mathbf{T}v + (n^\mathbf{T} v_0)^2
\end{aligned}
$$
<p>定义</p>
$$
\begin{aligned}
{\bf A}_{3\times 3} &= n n^\mathbf{T}\\ 
d &= -n^\mathbf{T} v_0 \\
\vec b_{3 \times 1} &= d n \\
c &= d^2
\end{aligned}
$$
<p>则</p>
$$
d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c
$$
<p>这个距离平方也可以写成齐次形式</p>
$$
d^2(v, F_i) = h^\mathbf{T} {\bf Q} h \\
\text{where} \ {\bf Q}_{4\times4} = \begin{pmatrix} {\bf A}_{3 \times 3} & b_{3 \times 1} \\ b^\mathbf{T} _{1 \times 3}& c_{1 \times 1} \end{pmatrix} \ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}
$$
<p>所以，对于每一个平面 $ F_i $，都可以定义一个二次型 $ Q_{F_i}(v) &#x3D; h^\mathbf{T} \mathbf{Q} h $，其为任意一点 $ v$ 到该平面距离的平方。</p>
<p>对于顶点 $ v $，该顶点到相邻的所有表面的距离平方和可以表示为 $ \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i}(v) &#x3D; (\sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i})(v) $ 。</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>QEM 算法的框架如下：</p>
<ul>
<li><p>每个顶点 $ v_i $ 按上面的方法赋予一个 Q 矩阵，$ Q_{v_i} &#x3D; \sum_{i \in \operatorname{neigh}(v_i)} Q_{F_i} $</p>
</li>
<li><p>收缩 $(v_i, v_j)$ 边到 $ v’ $ 时，定义这次收缩的代价为 $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$；每次全局的选择最小代价的边进行收缩</p>
<ul>
<li>如何选择 $ v’ $？有 Optimal Placement 和 Subset Placement 两种形式：<ol>
<li><p>(<strong>Optimal Placement</strong>) $ {\bf A} $ 可逆时</p>
<p>令 $ \frac{\partial}{\partial v}(v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c) &#x3D; 0 $，解得 $ v_\text{optimal} &#x3D; -{\bf A}^{-1} b $ </p>
</li>
<li><p>(<strong>Subset Placement</strong>) $ {\bf A} $ 不可逆时，选择两个端点或中点；看哪个 edge loss 小</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>收缩后的顶点 $ v’ $ 更新</p>
<blockquote>
<p>这里对算法有两种理解，第一种是按初始计算的方法重新按邻面赋予 Q 矩阵（这样就是一个完全 local 的方法），第二种理解是合并两个顶点，则将对应的 Q 矩阵也进行合并。</p>
<p>文章中的做法是<strong>第二种理解</strong>，从文章提到 implicit track sets of planes 可以知道。不过在 Discussion 处也讨论了这种做法的问题：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><em>Second, the information accumulated in the quadrics is essentially implicit, which can at times be problematic. Suppose we join together two cubes and would like to remove the planes associated with the now defunct interior faces. Not only is it, in general, difficult to determine what faces are defunct, there is no clear way to reliably remove the appropriate planes from the quadrics. As a result, our algorithm does not do as good a job at simplification with aggregation as we would like.</em></p>
</blockquote>
<ul>
<li>$ Q_{v'} = Q_{v_1} + Q_{v_2} $</li>
</ul>
<p>值得注意的是， $ Q(v’) &#x3D; (Q_{v_i} + Q_{v_j})(v’)$ 会导致一些 double counting 的现象发生，即有些公共面构造的 Q 分量被重复求和了。但作者提到，这样的重复对效果的影响有限。</p>
<blockquote>
<p>这里引用了 Donald E. Knuth. The Art of Computer Programming, volume 1. Addison Wesley, Reading, MA, Third edition, 1997.</p>
<p>不是很懂高德纳老爷子和 inclusion-exclusion rule 对效果的改善的关系…</p>
</blockquote>
<h3 id="Preserving-Boundaries"><a href="#Preserving-Boundaries" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>对于不希望边界移动的情况，可以首先标记将边标记为<strong>正常边</strong>和<strong>边界边</strong>两种（这个边界边不一定需要是真的网格边界，只是比较不希望移动的边）。</p>
<p>对于标记为<strong>边界边</strong>的边 $(v_1, v_2)$，令和其相邻的所有面的 Q 矩阵中增加一项反映到垂直于该平面、且过该<strong>边界边</strong>的一个平面的距离平方的项。</p>
<p>设边界边 $(v_1, v_2)$，不妨设某个相邻的三角形 $ F_i $ 的三个顶点为 $v_1, v_2, v_3$，则与之相对的边界平面 $ F_{B_i} $ 可以计算如下</p>
$$
n_{F_i} = \operatorname{normalize}{ \left((v_2 - v_1) \times (v_3 - v_1) \right)} \\
n_{F_{B_i}} = \operatorname{normalize}{\left( n_{F_i} \times (v_2 - v_1) \right)} \\
\forall v \in F_{B_i},\ \vec {n_{F_{B_i}}} \cdot (\vec v - \vec {v_1}) = 0 \Rightarrow \vec {n_{F_{B_i}}} \cdot \vec v +(- \vec {n_{F_{B_i}}} \cdot \vec {v_1}) = 0
$$
<p>则到边界平面 $ F_{B_i} $ 的距离平方计算如下：</p>
$$
d^2(v, F_{B_i}) = h^\mathbf{T} \mathbf{Q} h \\
\text{where} \ {\bf Q}_{4\times4} = 
\begin{pmatrix}
{\bf A}_{3 \times 3} & b_{3 \times 1} \\
b^\mathbf{T} _{1 \times 3}& c_{1 \times 1}
\end{pmatrix} = 
\begin{pmatrix}
n_{F_{B_i}}n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) {n_{F_{B_i}}} \\
(- n_{F_{B_i}} \cdot {v_1}) n_{F_{B_i}}^{\bf T} & (- n_{F_{B_i}} \cdot {v_1}) ^2
\end{pmatrix}
\ \text{and} \ h= \begin{pmatrix} \vec v \\ 1 \end{pmatrix}
$$
<p>把他加入到相邻面的 Q 矩阵中，最后就会进入各个边的 Q 矩阵。</p>
<h2 id="Appearance-Preserving-QEM"><a href="#Appearance-Preserving-QEM" class="headerlink" title="Appearance Preserving QEM"></a>Appearance Preserving QEM</h2><blockquote>
<p>出现于文章 <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~garland/Papers/quadric2.pdf">Simplifying Surfaces with Color and Texture using Quadric Error Metrics</a> 中</p>
</blockquote>
<p>对于<strong>连续</strong>的顶点属性来说，可以通过把他们加入向量中一起优化的方法来解决。这种方法本质上是原来 QEM 的推广，将原来的到平面的距离推广为了到平面上三点的位置和其它顶点属性共同确定的<strong>超平面</strong>的距离。</p>
<p>同时，本文中调整了<strong>可收缩顶点对</strong>的定义，将其限制在了原三角网格中的边的范围内，因为可靠性不够好。</p>
<blockquote>
<p>Our experience has shown that, while greedy edge contraction produces consistently good results on many kinds of models, greedy contraction of arbitrary pairs is not as robust and does not perform as consistently.</p>
</blockquote>
<h3 id="Formulation-1"><a href="#Formulation-1" class="headerlink" title="Formulation"></a>Formulation</h3><p>将上面的三角形 $ F_i $ 的各个顶点 $ v_i $ 从 $ \mathbb{R}^3 $ 推广到 $ \mathbb{R}^n $，我们知道 3 个 $ \mathbb{R}^n $ 中的点（非线性相关）仍然确定一个 $ \mathbb{R}^2 $ 平面，这个平面的两个<strong>标准正交</strong>基向量 $ e_1 $，$ e_2 $ 可以用 Schmidt 正交化的办法得到：</p>
$$
\begin{aligned}
e_1 &= \operatorname{normalize}{(v_2-v_1)} \\
e_2 &= \operatorname{normalize}{((v_3 - v_1) - (e_1 \cdot (v_3 - v_1)) e_1)}
\end{aligned}
$$
<p>这样，对于 $ v \in \mathbb{R}^n $，有</p>
$$
\begin{aligned}
d^2(v, F_i) &= \| v - v_1 \|^2 - ((v-v_1)\cdot e_1)^2 - ((v-v_1)\cdot e_2)^2 \\
&= (v-v_1)^{\bf T}(v-v_1) - ((v-v_1)^{\bf T}e_1)(e_1^{\bf T}(v-v_1)) - ((v-v_1)^{\bf T}e_2)(e_2^{\bf T}(v-v_1)) \\
&= (v^{\bf T} v - v_1^{\bf T}v-v^{\bf T} v_1 + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - v^{\bf T}e_1 e_1^{\bf T} v_1 + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - v^{\bf T}e_2 e_2^{\bf T} v_1 + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v)^{\bf T} + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)^{\bf T}  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= (v^{\bf T} v - 2v_1^{\bf T}v + v^{\bf T}_1 v_1) - \\
& \ \quad (v^{\bf T}e_1 e_1^{\bf T}v -v^{\bf T}_1 e_1 e_1^{\bf T}v - (v_1^{\bf T} e_1 e_1^{\bf T} v) + v_1^{\bf T} e_1 e_1^{\bf T} v_1) - \\
& \ \quad (v^{\bf T}e_2 e_2^{\bf T}v -v^{\bf T}_1 e_2 e_2^{\bf T}v - (v_1^{\bf T} e_2 e_2^{\bf T} v)  + v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(v^{\bf T}_1 e_1 e_1^{\bf T} + v^{\bf T}_1 e_2 e_2^{\bf T}-v_1^{\bf T}) v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2(e_1 e_1^{\bf T}v_1 +e_2 e_2^{\bf T} v_1 - v_1)^{\bf T} v + (v^{\bf T}_1 v_1 -v_1^{\bf T} e_1 e_1^{\bf T} v_1 - v_1^{\bf T} e_2 e_2^{\bf T} v_1) \\
&= v^{\bf T} ({\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T}) v + 2((e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1)^{\bf T} v + (v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2)

\end{aligned}
$$
<p>仿照前面，整理成 Q 矩阵的形式</p>
$$
d^2(v, F_i) = v^\mathbf{T} {\bf A} v + 2b^\mathbf{T} v + c \\
\text{where}\ \left\{
\begin{aligned}
{\bf A}_{n\times n} &= {\bf I} - e_1 e_1^{\bf T} - e_2 e_2^{\bf T} \\
{\bf b}_{n\times 1} &= (e_1 \cdot v_1)e_1  +(e_2 \cdot v_1)e_2 - v_1 \\
c_{1\times 1} &= v_1 \cdot v_1 - (v_1\cdot e_1)^2 - (v_1 \cdot e_2)^2
\end{aligned}
\right.
$$


<h3 id="Preserving-Boundaries-1"><a href="#Preserving-Boundaries-1" class="headerlink" title="Preserving Boundaries"></a>Preserving Boundaries</h3><p>将原始的 QEM 边界处理方法直接搬到 $ \mathbb{R}^n $ 会比较困难，因为 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面有很多个。</p>
<blockquote>
<p>平面在 $ \mathbb{R}^n $ 中即为一个 $ \mathbb{R}^2 $ 子空间，垂直于该平面的向量现在构成一个“法空间”（其为 $ \mathbb{R} ^n &#x2F; \mathbb{R} ^2 $ 的商空间），其维数为 $ n - 2 $，那 $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点并且垂直于一个平面的平面 $ \iff $  $ \mathbb{R}^n $ 下过两个 $ \mathbb{R}^n $ 的点和一个法空间中的点  $ \Rightarrow $ 这样的平面至少有 $ n - 2 $ 个</p>
</blockquote>
<p>所以，这里考虑直接锁边界。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/./qem-mesh-simplification.assets/image-20230420220930080.png" alt="image-20230420220930080"></p>
<p>0.5 ratio</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-play-with-spirv" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/play-with-spirv/"><strong>SPIR-V 初探 (一) - Fragment Shader</strong></a>
      <small class=article-date-index>&nbsp; 2023-03-29</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/play-with-spirv/" class="article-date">
  <time datetime="2023-03-28T16:00:00.000Z" itemprop="datePublished">2023-03-29</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文主要关注 SPIR-V 1.6。</p>
<p>前面分支 &#x2F; 循环 &#x2F; 函数等测试主要是在 Fragment 这种 OpEntrypoint 下调用的子函数内部进行测试的。</p>
<p>下面的实验基本使用 <a target="_blank" rel="noopener" href="https://shader-playground.timjones.io/">Shader Playground</a> 的 glslang trunk (上面写使用的 2022-09-19 的版本)，其中：</p>
<ul>
<li>Shader stage 选择 <strong>frag</strong></li>
<li>Target 选择 Vulkan 1.3</li>
<li>Output format 选择 SPIR-V</li>
</ul>
<h3 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2">https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2</a></li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>通过例子来学习 SPIR-V 会比较快捷，也比较容易理解。</p>
<p>SPIR-V 本身是 SSA 形式的 IR，且指令 format 较为规整，易于解析 (虽然大家都是调库，也不会用手解析 SPIR-V 的)。</p>
<p>规范文档参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/">Khronos SPIR-V Registry</a></li>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html">SPIR-V Unified Specifications</a></li>
</ul>
<p>同时推荐用 <a target="_blank" rel="noopener" href="https://shader-playground.timjones.io/">Shader Playground</a> 来方便直接看到 SPIR-V Disassembly。</p>
<p>据博主本人测试，OpenAI 的 GPT-4 有<strong>不错</strong>的 SPIR-V 到 GLSL 反汇编能力。</p>
</blockquote>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>从反汇编结果可以看到，SPIR-V Module 有比较整齐的形式，事实上这些形式是规定好的：<a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_logical_layout_of_a_module">Logical Layout of a Module - SPIR-V Specification</a>。</p>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.6</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 6                                                  ; Bound; where all &lt;id&gt;s in this module are</span><br><span class="line">                                                            ; guaranteed to satisfy 0 &lt; id &lt; Bound</span><br><span class="line">; Schema: 0                                                 ; Instruction Schema; Reserved, not used for now</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450                ; Addressing model = Logical</span><br><span class="line">                                                            ; Logical 模式下面，指针只能从已有的对象中创建，指针的地址也都是假的</span><br><span class="line">                                                            ;   （也就是说，不能把指针的值拷贝到别的变量中去）</span><br><span class="line">                                                            ; 也有一些带有物理指针的 Addressing Model 和相应的 Memory Model</span><br><span class="line">                                                            ;   =&gt; 留待后文探索</span><br><span class="line">                                                            ; Memory Model = GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot;           ; Execution Model = Fragment</span><br><span class="line">                                                            ; Entrypoint = %main (用 OpFunction 定义的某个 Result ID)</span><br><span class="line">                                                            ; Name = &quot;main&quot; (Entrypoint 要有一个字符串名字)</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft        ; The coordinates decorated by FragCoord</span><br><span class="line">                                                            ; appear to originate in the upper left,</span><br><span class="line">                                                            ; and increase toward the right and downward.</span><br><span class="line">                                                            ; Only valid with the Fragment Execution Model.</span><br><span class="line">               OpSource ESSL 310                            ; 标记源语言; ESSL = OpenGL ES Shader Language</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会发现 %main 这个 result id 是在后面定义的，但是前面却引用到了。</p>
<p>对于 <code>SPV_OPERAND_TYPE_ID</code>, <code>SPV_OPERAND_TYPE_MEMORY_SEMANTICS_ID</code>, <code>SPV_OPERAND_TYPE_SCOPE_ID</code> 来说，正常都需要先定义（是某个指令的 result id）再引用，但是可以前向定义的指令除外。</p>
<p>可前向定义的指令可以参考 <a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/SPIRV-Tools/blob/1021ec302f568cd83fee9f4eaa763dadb66e40b0/source/val/validate_id.cpp#L49">source&#x2F;val&#x2F;validate_id.cpp:L122 @ SPIRV-Tools</a>，其中包括：</p>
<ul>
<li>全部的 <code>OpTypeXXX</code> 类指令</li>
<li>其它一大堆，主要是执行模式等 metadata、Decorate、分支、device side invoke 等<ul>
<li>可以参考 <code>spvOperandCanBeForwardDeclaredFunction (source/operand.cpp @ SPIRV-Tools)</code> 这个函数</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="简单的函数"><a href="#简单的函数" class="headerlink" title="简单的函数"></a>简单的函数</h3><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Circle</span><span class="params">( vec2 uv, vec2 p, <span class="type">float</span> r, <span class="type">float</span> blur )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = length(uv - p);</span><br><span class="line">    <span class="type">float</span> c = smoothstep(r, r-blur, d);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">%1 = OpExtInstImport &quot;GLSL.std.450&quot;                        ; 引入外部指令集</span><br><span class="line">%float = OpTypeFloat 32</span><br><span class="line">%v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Function_v2float = OpTypePointer Function %v2float</span><br><span class="line">%_ptr_Function_float = OpTypePointer Function %float       ; 定义指针类型，指向的变量的 Storage Class 为 Function</span><br><span class="line">%10 = OpTypeFunction %float %_ptr_Function_v2float %_ptr_Function_v2float %_ptr_Function_float %_ptr_Function_float</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line">%Circle_vf2_vf2_f1_f1_ = OpFunction %float None %10        ; 返回值类型 %float，Function Control 类型无</span><br><span class="line">                                                           ; 函数类型 %10 - float (vec2, vec2, float, float)</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float  ; 拿到各个 parameter 的 result id</span><br><span class="line">          %p = OpFunctionParameter %_ptr_Function_v2float  </span><br><span class="line">          %r = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">       %blur = OpFunctionParameter %_ptr_Function_float    </span><br><span class="line">         %16 = OpLabel                                     ; 一个基本块的开始 (2.2.5. Control Flow)</span><br><span class="line">          %d = OpVariable %_ptr_Function_float Function    ; 定义 float 变量, Storage Class 为 Function </span><br><span class="line">          %c = OpVariable %_ptr_Function_float Function    ; =&gt; 变量可以被 OpLoad / OpStore</span><br><span class="line">         %39 = OpLoad %v2float %uv                         ; 结果类型 %v2float, 装载 %uv 变量的值</span><br><span class="line">         %40 = OpLoad %v2float %p</span><br><span class="line">         %41 = OpFSub %v2float %39 %40                     ; Operand2 - Operand1，结果类型 %v2float</span><br><span class="line">         %42 = OpExtInst %float %1 Length %41              ; Execute an instruction in an imported set of extended instructions</span><br><span class="line">                                                           ; Set (也就是这里的 %1) is the result of an OpExtInstImport instruction.</span><br><span class="line">                                                           ; 后面的 Set 中的 Instruction 是 “Length”，操作数是 %41</span><br><span class="line">               OpStore %d %42                              ; 存到 %d 变量的存储中</span><br><span class="line">         %44 = OpLoad %float %r</span><br><span class="line">         %45 = OpLoad %float %r</span><br><span class="line">         %46 = OpLoad %float %blur</span><br><span class="line">         %47 = OpFSub %float %45 %46                       ; %blur - %r</span><br><span class="line">         %48 = OpLoad %float %d</span><br><span class="line">         %49 = OpExtInst %float %1 SmoothStep %44 %47 %48  ; SmoothStep(%r, %blur - %r, %d)</span><br><span class="line">               OpStore %c %49</span><br><span class="line">         %50 = OpLoad %float %c</span><br><span class="line">               OpReturnValue %50                           ; 不返回值的话使用 OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<h3 id="函数的-in-x2F-out-参数"><a href="#函数的-in-x2F-out-参数" class="headerlink" title="函数的 in &#x2F; out 参数"></a>函数的 in &#x2F; out 参数</h3><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inoutTest</span><span class="params">(in vec2 uv, out <span class="type">float</span> o1, in <span class="type">float</span> i2, out vec2 o2)</span> &#123;</span><br><span class="line">    o2 = uv;</span><br><span class="line">    o1 = i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">         %v1 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %t1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %t2 = OpVariable %_ptr_Function_float Function</span><br><span class="line">         %v2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">      %param = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">    %param_0 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_1 = OpVariable %_ptr_Function_float Function</span><br><span class="line">    %param_2 = OpVariable %_ptr_Function_v2float Function</span><br><span class="line">         %24 = OpLoad %v2float %v1</span><br><span class="line">               OpStore %param %24</span><br><span class="line">         %27 = OpLoad %float %t2</span><br><span class="line">               OpStore %param_1 %27</span><br><span class="line">         %29 = OpFunctionCall %void %inoutTest_vf2_f1_f1_vf2_ %param %param_0 %param_1 %param_2</span><br><span class="line">         %30 = OpLoad %float %param_0   ; 可以看到，就是实现了 %param_0 变量内值的变化</span><br><span class="line">               OpStore %t1 %30</span><br><span class="line">         %31 = OpLoad %v2float %param_2</span><br><span class="line">               OpStore %v2 %31</span><br><span class="line">               OpStore %fragColor %38</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br><span class="line">%inoutTest_vf2_f1_f1_vf2_ = OpFunction %void None %10</span><br><span class="line">         %uv = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line">         %o1 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %i2 = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %o2 = OpFunctionParameter %_ptr_Function_v2float</span><br><span class="line"></span><br><span class="line">         %16 = OpLabel</span><br><span class="line">         %17 = OpLoad %v2float %uv</span><br><span class="line">               OpStore %o2 %17</span><br><span class="line">         %18 = OpLoad %float %i2</span><br><span class="line">               OpStore %o1 %18</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">testIf</span><span class="params">(<span class="type">float</span> range)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (range &lt; <span class="number">1.0</span>)</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip some lines</span></span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">; == 相关定义 ==</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line"></span><br><span class="line">; == 函数 ==</span><br><span class="line"> %testIf_f1_ = OpFunction %int None %22</span><br><span class="line">      %range = OpFunctionParameter %_ptr_Function_float</span><br><span class="line">         %25 = OpLabel                                    ; 基本块开始</span><br><span class="line">        %c_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %c_0 %int_0</span><br><span class="line">         %68 = OpLoad %float %range                       </span><br><span class="line">         %71 = OpFOrdLessThan %bool %68 %float_1          ; check if %68 (loaded from %range) &lt; %float_1</span><br><span class="line">               OpSelectionMerge %73 None                  ; Declare a structured selection</span><br><span class="line">                                                          ; This instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.</span><br><span class="line">                                                          ; Selection Control = None; 这里可以给 Hint 提示此分支是否应该 remove</span><br><span class="line">                                                          ; 并且指定 Merge Block 为 %73，也就是分支结束的地方</span><br><span class="line">               OpBranchConditional %71 %72 %75            ; 如果 %71 为 true, 则跳到 %72 标号，否则跳到 %75 标号 - 标志基本块结束</span><br><span class="line">         %72 = OpLabel                                    ; </span><br><span class="line">               OpStore %c_0 %int_1</span><br><span class="line">               OpBranch %73                               ; Unconditional branch to %73</span><br><span class="line">         %75 = OpLabel</span><br><span class="line">               OpStore %c_0 %int_2</span><br><span class="line">               OpBranch %73</span><br><span class="line">         %73 = OpLabel</span><br><span class="line">         %77 = OpLoad %int %c_0</span><br><span class="line">               OpReturnValue %77</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>OpSelectionMerge</code></li>
<li><code>OpBranchConditional</code></li>
<li>两个基本块最后 <code>OpBranch</code> 到出口</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>Merge Instruction: <code>OpSelectionMerge</code> 或者 <code>OpLoopMerge</code> 两者之一，用在</li>
<li>Header Block: 包含 Merge Instruction 的 Block<ul>
<li>Loop Header: Merge Instruction 是 <code>OpLoopMerge</code> 的 Header Block</li>
<li>Selection Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpBranchConditional</code> 是终止指令的 Header Block</li>
<li>Switch Header: <code>OpSelectionMerge</code> 为 Merge Instruction, <code>OpSwitch</code> 是终止指令的 Header Block</li>
</ul>
</li>
<li>Merge Block: 在 Merge Instruction 作为 Merge Block 操作数的 Block</li>
<li>Break Block: 含有跳转到被 Loop Header 的 Merge Instruction 定义为 Merge Block 的 Block</li>
<li>Continue Block: 含有跳转到 <code>OpLoopMerge</code> 指令的 Continue Target 的 Block</li>
<li>Return Block: 包含 <code>OpReturn</code> 或者 <code>OpReturnValue</code> 的 Block</li>
</ul>
<blockquote>
<p>GPT-4: 在 SPIR-V 中，Merge Block 是一个特定类型的基本块（Basic Block），用于控制流程结构中收敛控制流的位置。当你在 SPIR-V 中使用分支结构（如 if-else 语句、循环等）时，Merge Block 表示在这些分支结构末端的汇合点。</p>
<p>SPIR-V 中的控制流结构使用特殊的操作码（如 OpSelectionMerge、OpLoopMerge）来定义。这些操作码告诉编译器如何解释控制流图（Control Flow Graph，CFG）。Merge Block 用于表示这些控制流结构的结束位置，它是控制流从不同路径重新合并到一条路径的地方。例如，一个 if-else 语句会有两个分支，这两个分支在 Merge Block 之后合并为单个执行路径。</p>
</blockquote>
<h4 id="while-循环-无-break"><a href="#while-循环-无-break" class="headerlink" title="while 循环 - 无 break"></a>while 循环 - 无 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None                 ; Declare a structured loop.</span><br><span class="line">                                                        ; This instruction must immediately precede</span><br><span class="line">                                                        ; either an OpBranch or OpBranchConditional </span><br><span class="line">                                                        ; instruction. </span><br><span class="line">                                                        ; That is, it must be the second-to-last </span><br><span class="line">                                                        ; instruction in its block.</span><br><span class="line">                                                        ; Merge Block = %87</span><br><span class="line">                                                        ; Continue target = %88</span><br><span class="line">               OpBranch %89</span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0     ; 有符号比较; if %90 (=count) &gt;= %int_0 (0)</span><br><span class="line">               OpBranchConditional %91 %86 %87          ; %91 == true ? jump to %86 : jump to %87 (FINISH)</span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93                         ; sum = sum + 1</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95                       ; count = count - 1</span><br><span class="line">               OpBranch %88</span><br><span class="line">         %88 = OpLabel</span><br><span class="line">               OpBranch %85                             ; 无条件回到 Loop 头</span><br><span class="line">         %87 = OpLabel</span><br><span class="line">         %96 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %96</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>相当于翻译成了如下格式的 SPIR-V：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%header_block = OpLabel</span><br><span class="line">                OpLoopMerge %merge_block %continue_block</span><br><span class="line">                OpBranch %loop_body</span><br><span class="line"></span><br><span class="line">   %loop_test = OpLabel</span><br><span class="line">                OpLoopMerge %loop_merge %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cond = ...          ; Some calculations</span><br><span class="line">                OpBranchConditional %loop_cond %loop_body %loop_merge</span><br><span class="line">   </span><br><span class="line">   %loop_body = OpLabel</span><br><span class="line">                ...          ; Some codes inside loop body</span><br><span class="line">                OpBranch %loop_cont</span><br><span class="line"></span><br><span class="line">   %loop_cont = OpLabel</span><br><span class="line">                OpBranch %loop_test</span><br><span class="line"></span><br><span class="line">  %loop_merge = OpLabel</span><br><span class="line">                ...          ; The &quot;following&quot; basic block</span><br></pre></td></tr></table></figure>

<h4 id="while-循环-带-break"><a href="#while-循环-带-break" class="headerlink" title="while 循环 - 带 break"></a>while 循环 - 带 break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testWhile</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">%testWhile_i1_ = OpFunction %int None %27</span><br><span class="line">      %count = OpFunctionParameter %_ptr_Function_int</span><br><span class="line">         %30 = OpLabel</span><br><span class="line">        %sum = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum %int_0</span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %85 = OpLabel</span><br><span class="line">               OpLoopMerge %87 %88 None</span><br><span class="line">               OpBranch %89</span><br><span class="line"></span><br><span class="line">         %89 = OpLabel</span><br><span class="line">         %90 = OpLoad %int %count</span><br><span class="line">         %91 = OpSGreaterThanEqual %bool %90 %int_0</span><br><span class="line">               OpBranchConditional %91 %86 %87</span><br><span class="line"></span><br><span class="line">         %86 = OpLabel</span><br><span class="line">         %92 = OpLoad %int %sum</span><br><span class="line">         %93 = OpIAdd %int %92 %int_1</span><br><span class="line">               OpStore %sum %93</span><br><span class="line">         %94 = OpLoad %int %count</span><br><span class="line">         %95 = OpISub %int %94 %int_1</span><br><span class="line">               OpStore %count %95</span><br><span class="line">         %96 = OpLoad %int %count</span><br><span class="line">         %97 = OpIEqual %bool %96 %int_2</span><br><span class="line">               OpSelectionMerge %99 None              ; If 的 Merge Block = %99</span><br><span class="line">               OpBranchConditional %97 %98 %99</span><br><span class="line"></span><br><span class="line">         %98 = OpLabel</span><br><span class="line">               OpBranch %87                           ; =&gt; break out of the loop =&gt; emit instruction</span><br><span class="line">                                                      ;    to branch to while&#x27;s merge block</span><br><span class="line"></span><br><span class="line">         %99 = OpLabel                                ; 正常走 =&gt; 到达 while 末尾 =&gt; emit 到 while</span><br><span class="line">               OpBranch %88                           ; 的 Continue Block</span><br><span class="line"></span><br><span class="line">         %88 = OpLabel                                ; Continue Block </span><br><span class="line">               OpBranch %85</span><br><span class="line"></span><br><span class="line">         %87 = OpLabel                                ; Merge Block</span><br><span class="line">        %101 = OpLoad %int %sum</span><br><span class="line">               OpReturnValue %101</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>break 作为一个基本块末尾，直接 emit 无条件 branch 来跳到 while 循环的 merge block。</li>
</ul>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>GLSL 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">testFor</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">%testFor_i1_ = OpFunction %int None %27</span><br><span class="line">    %count_0 = OpFunctionParameter %_ptr_Function_int</span><br><span class="line"></span><br><span class="line">         %33 = OpLabel</span><br><span class="line">      %sum_0 = OpVariable %_ptr_Function_int Function</span><br><span class="line">          %i = OpVariable %_ptr_Function_int Function</span><br><span class="line">               OpStore %sum_0 %int_0</span><br><span class="line">               OpStore %i %int_0</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %109 = OpLabel</span><br><span class="line">               OpLoopMerge %111 %112 None</span><br><span class="line">               OpBranch %113</span><br><span class="line"></span><br><span class="line">        %113 = OpLabel</span><br><span class="line">        %114 = OpLoad %int %i</span><br><span class="line">        %115 = OpLoad %int %count_0</span><br><span class="line">        %116 = OpSLessThan %bool %114 %115</span><br><span class="line">               OpBranchConditional %116 %110 %111</span><br><span class="line"></span><br><span class="line">        %110 = OpLabel</span><br><span class="line">        %117 = OpLoad %int %sum_0</span><br><span class="line">        %118 = OpIAdd %int %117 %int_1</span><br><span class="line">               OpStore %sum_0 %118</span><br><span class="line">               OpBranch %112</span><br><span class="line"></span><br><span class="line">        %112 = OpLabel                              ; Continuation Block</span><br><span class="line">        %119 = OpLoad %int %i                       ; for 循环的循环结束操作放到了这里</span><br><span class="line">        %120 = OpIAdd %int %119 %int_1</span><br><span class="line">               OpStore %i %120</span><br><span class="line">               OpBranch %109</span><br><span class="line"></span><br><span class="line">        %111 = OpLabel                              ; Merge Block</span><br><span class="line">        %121 = OpLoad %int %sum_0</span><br><span class="line">               OpReturnValue %121</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>Continuation Block 处现在 emit 了循环后维护操作</li>
</ul>
<h3 id="Uniform、BuiltIn-等其它-Scope-的变量"><a href="#Uniform、BuiltIn-等其它-Scope-的变量" class="headerlink" title="Uniform、BuiltIn 等其它 Scope 的变量"></a>Uniform、BuiltIn 等其它 Scope 的变量</h3><blockquote>
<p><code>OpSource</code>, <code>OpName</code>, <code>OpMemberName</code> 属于调试信息。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line">precision highp <span class="type">int</span>;</span><br><span class="line">precision mediump sampler3D;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Anonymous uniform block - Import member names to shader directly</span></span><br><span class="line">layout(binding = <span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">layout(location = <span class="number">0</span>) out vec4 outColor;</span><br><span class="line">layout(location = <span class="number">0</span>) in vec4 vertColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will not work:</span></span><br><span class="line"><span class="comment">// layout(binding = 0) uniform vec3 lightPos;</span></span><br><span class="line"><span class="comment">//  &#x27;non-opaque uniforms outside a block&#x27; : not allowed when using GLSL for Vulkan </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mainImage</span><span class="params">(out vec4 c, in vec2 f, in vec3 lightPos)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, lightPos);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input &#x2F; Output"></a>Input &#x2F; Output</h4><blockquote>
<p>所有可选 Decoration 可以参考 <a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Decoration</a></p>
</blockquote>
<p>对于 gl_FragCoord：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">                      OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">      %gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure>

<p>对于 Input Variable：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                      OpName %vertColor &quot;vertColor&quot;</span><br><span class="line">                      OpDecorate %vertColor Location 0</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">                      %vertColor = OpVariable %_ptr_Input_v4float Input</span><br></pre></td></tr></table></figure>

<p>对于 Output Variable：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                       OpName %outColor &quot;outColor&quot;</span><br><span class="line">                       OpDecorate %outColor Location 0</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">           %outColor = OpVariable %_ptr_Output_v4float Output</span><br></pre></td></tr></table></figure>

<p>使用时直接 <code>OpLoad</code> 就可以。</p>
<h4 id="Uniform-Block-Anonymous"><a href="#Uniform-Block-Anonymous" class="headerlink" title="Uniform Block (Anonymous)"></a>Uniform Block (Anonymous)</h4><blockquote>
<p>匿名的 Uniform Block，其成员是被引入了 Global Scope 的。</p>
<p>可以作为 OpenGL 的 uniforms outside a block 的平替。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniBlock &quot;uniBlock&quot;</span><br><span class="line">               OpMemberName %uniBlock 0 &quot;lightPos&quot;</span><br><span class="line">               OpMemberName %uniBlock 1 &quot;someOtherFloat&quot;</span><br><span class="line">               OpName %_ &quot;&quot;</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0             ; Structure type = %uniBlock</span><br><span class="line">                                                                 ; Member = 0</span><br><span class="line">                                                                 ; Decoration = Offset</span><br><span class="line">                                                                 ; Byte Offset = 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block                        ; Apply only to a structure type to establish</span><br><span class="line">                                                                 ; it is a memory interface block</span><br><span class="line">               OpDecorate %_ DescriptorSet 0                     ; Apply only to a variable. </span><br><span class="line">                                                                 ; Descriptor Set is an unsigned 32-bit integer </span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc. </span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">               OpDecorate %_ Binding 0                           ; Apply only to a variable.</span><br><span class="line">                                                                 ; Binding Point is an unsigned 32-bit integer</span><br><span class="line">                                                                 ; forming part of the linkage between the client</span><br><span class="line">                                                                 ; API and SPIR-V memory buffers, images, etc.</span><br><span class="line">                                                                 ; See the client API specification for more detail.</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float                      ; 后面指定所有成员的类型，这里是 &#123;vec3, float&#125;</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock         ; Storage Class = Uniform</span><br><span class="line">          %_ = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_v3float = OpTypePointer Uniform %v3float</span><br><span class="line"></span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %_ %int_0     ; Create a pointer into a composite object.</span><br><span class="line">                                                                 ; Base = %_, Indexes = &#123;%int_0&#125;</span><br><span class="line">                                                                 ; Each index in Indexes</span><br><span class="line">                                                                 ; - must have a scalar integer type</span><br><span class="line">                                                                 ; - is treated as signed</span><br><span class="line">                                                                 ; - if indexing into a structure, must be an </span><br><span class="line">                                                                 ;   OpConstant whose value is in bounds for selecting a member</span><br><span class="line">                                                                 ; - if indexing into a vector, array, or matrix, </span><br><span class="line">                                                                 ;   with the result type being a logical pointer type,</span><br><span class="line">                                                                 ;   causes undefined behavior if not in bounds.</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure>

<h4 id="Uniform-Block-Named"><a href="#Uniform-Block-Named" class="headerlink" title="Uniform Block (Named)"></a>Uniform Block (Named)</h4><p>把上面的示例程序里面的 <code>uniform uniBlock</code> 类型的不具名 Uniform Block 加一个实例名字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout(binding=<span class="number">0</span>) uniform uniBlock &#123;</span><br><span class="line">    uniform vec3 lightPos;</span><br><span class="line">    uniform <span class="type">float</span> someOtherFloat;</span><br><span class="line">&#125; uniInst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..skip some lines..</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;mainImage(outColor, gl_FragCoord.xy, uniInst.lightPos);&#125;</span><br></pre></td></tr></table></figure>

<p>下面是相关的 SPIR-V：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">               OpName %uniInst &quot;uniInst&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpMemberDecorate %uniBlock 0 Offset 0</span><br><span class="line">               OpMemberDecorate %uniBlock 1 Offset 12</span><br><span class="line">               OpDecorate %uniBlock Block</span><br><span class="line">               OpDecorate %uniInst DescriptorSet 0</span><br><span class="line">               OpDecorate %uniInst Binding 0</span><br><span class="line">   %uniBlock = OpTypeStruct %v3float %float</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">%_ptr_Uniform_uniBlock = OpTypePointer Uniform %uniBlock</span><br><span class="line">    %uniInst = OpVariable %_ptr_Uniform_uniBlock Uniform</span><br><span class="line">         %34 = OpAccessChain %_ptr_Uniform_v3float %uniInst %int_0</span><br><span class="line">         %35 = OpLoad %v3float %34</span><br></pre></td></tr></table></figure>

<p>可以看到，主要区别是 <code>%_</code> 变成了 <code>%uniInst</code>，其实就是 OpName 从 <code>&quot;&quot;</code> 变成了 <code>&quot;uniInst&quot;</code>，这样 SPIR-V 反汇编工具生成的反汇编能更好看一些而已。真正的 Result ID 等的逻辑关系都是没有变化的。</p>
<blockquote>
<p>当然，不知道反射库依赖不依赖 <code>OpName</code>，当然去掉了也不是没法反射就是了，只要 layout 一样，怼上去就得了。</p>
</blockquote>
<h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (binding = <span class="number">1</span>) uniform sampler2D samplerColor;</span><br><span class="line">layout (binding = <span class="number">2</span>) uniform texture2D tex;</span><br><span class="line">layout (binding = <span class="number">3</span>) uniform sampler samp;</span><br><span class="line">layout (location = <span class="number">0</span>) in vec2 inUV;</span><br><span class="line">layout (location = <span class="number">1</span>) in <span class="type">float</span> inLodBias;</span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    vec4 color = texture(samplerColor, inUV, inLodBias);</span><br><span class="line">      vec4 color2 = texture(sampler2D(tex, samp), inUV, inLodBias);</span><br><span class="line">    outFragColor = color + color2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 40</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %inUV %inLodBias %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %color &quot;color&quot;</span><br><span class="line">               OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">               OpName %inUV &quot;inUV&quot;</span><br><span class="line">               OpName %inLodBias &quot;inLodBias&quot;</span><br><span class="line">               OpName %color2 &quot;color2&quot;</span><br><span class="line">               OpName %tex &quot;tex&quot;</span><br><span class="line">               OpName %samp &quot;samp&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">               OpDecorate %samplerColor Binding 1</span><br><span class="line">               OpDecorate %inUV Location 0</span><br><span class="line">               OpDecorate %inLodBias Location 1</span><br><span class="line">               OpDecorate %tex DescriptorSet 0</span><br><span class="line">               OpDecorate %tex Binding 2</span><br><span class="line">               OpDecorate %samp DescriptorSet 0</span><br><span class="line">               OpDecorate %samp Binding 3</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Function_v4float = OpTypePointer Function %v4float</span><br><span class="line">         %10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">         %11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line">    %v2float = OpTypeVector %float 2</span><br><span class="line">%_ptr_Input_v2float = OpTypePointer Input %v2float</span><br><span class="line">       %inUV = OpVariable %_ptr_Input_v2float Input</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line">  %inLodBias = OpVariable %_ptr_Input_float Input</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">        %tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line">         %27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">       %samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %color = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">     %color2 = OpVariable %_ptr_Function_v4float Function</span><br><span class="line">         %14 = OpLoad %11 %samplerColor</span><br><span class="line">         %18 = OpLoad %v2float %inUV</span><br><span class="line">         %21 = OpLoad %float %inLodBias</span><br><span class="line">         %22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br><span class="line">               OpStore %color %22</span><br><span class="line">         %26 = OpLoad %10 %tex</span><br><span class="line">         %30 = OpLoad %27 %samp</span><br><span class="line">         %31 = OpSampledImage %11 %26 %30</span><br><span class="line">         %32 = OpLoad %v2float %inUV</span><br><span class="line">         %33 = OpLoad %float %inLodBias</span><br><span class="line">         %34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br><span class="line">               OpStore %color2 %34</span><br><span class="line">         %37 = OpLoad %v4float %color</span><br><span class="line">         %38 = OpLoad %v4float %color2</span><br><span class="line">         %39 = OpFAdd %v4float %37 %38</span><br><span class="line">               OpStore %outFragColor %39</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<ul>
<li>Sampler (<code>VK_DESCRIPTOR_TYPE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpName %samp &quot;samp&quot;</span><br><span class="line">OpDecorate %samp DescriptorSet 0</span><br><span class="line">OpDecorate %samp Binding 3</span><br><span class="line"></span><br><span class="line">%27 = OpTypeSampler</span><br><span class="line">%_ptr_UniformConstant_27 = OpTypePointer UniformConstant %27</span><br><span class="line">%samp = OpVariable %_ptr_UniformConstant_27 UniformConstant</span><br></pre></td></tr></table></figure></li>
<li>Sampled Image (<code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OpName %tex &quot;tex&quot;</span><br><span class="line">OpDecorate %tex DescriptorSet 0</span><br><span class="line">OpDecorate %tex Binding 2</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%_ptr_UniformConstant_10 = OpTypePointer UniformConstant %10</span><br><span class="line">%tex = OpVariable %_ptr_UniformConstant_10 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%26 = OpLoad %10 %tex</span><br><span class="line">%30 = OpLoad %27 %samp</span><br><span class="line">%31 = OpSampledImage %11 %26 %30</span><br><span class="line">%32 = OpLoad %v2float %inUV</span><br><span class="line">%33 = OpLoad %float %inLodBias</span><br><span class="line">%34 = OpImageSampleImplicitLod %v4float %31 %32 Bias %33</span><br></pre></td></tr></table></figure></li>
<li>Combined Image Sampler (<code>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code>)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OpName %samplerColor &quot;samplerColor&quot;</span><br><span class="line">OpDecorate %samplerColor DescriptorSet 0</span><br><span class="line">OpDecorate %samplerColor Binding 1</span><br><span class="line"></span><br><span class="line">%10 = OpTypeImage %float 2D 0 0 0 1 Unknown</span><br><span class="line">%11 = OpTypeSampledImage %10</span><br><span class="line">%_ptr_UniformConstant_11 = OpTypePointer UniformConstant %11</span><br><span class="line">%samplerColor = OpVariable %_ptr_UniformConstant_11 UniformConstant</span><br><span class="line"></span><br><span class="line">; 使用</span><br><span class="line">%14 = OpLoad %11 %samplerColor</span><br><span class="line">%18 = OpLoad %v2float %inUV</span><br><span class="line">%21 = OpLoad %float %inLodBias</span><br><span class="line">%22 = OpImageSampleImplicitLod %v4float %14 %18 Bias %21</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意关于 OpImage 和 OpSampledImage 的特殊规则：</p>
<ul>
<li>All <code>OpSampledImage</code> instructions must be in the same block in which their Result <code>&lt;id&gt;</code> are consumed. Result <code>&lt;id&gt;</code> from <code>OpSampledImage</code> instructions must not appear as operands to <code>OpPhi</code> instructions or <code>OpSelect</code> instructions, or any instructions other than the image lookup and query instructions specified to take an operand whose type is OpTypeSampledImage.</li>
<li>在 <code>spvtools::opt::InstrumentPass::MovePreludeCode @ source/opt/instrument_pass.cpp (SPIRV-Tools)</code> 中对该要求进行了处理。</li>
</ul>
</blockquote>
<h3 id="Storage-Buffer"><a href="#Storage-Buffer" class="headerlink" title="Storage Buffer"></a>Storage Buffer</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap14.html#descriptorsets-storagebuffer">14.1.7. Storage Buffer</a></p>
</blockquote>
<blockquote>
<p>我的一个疑惑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[]; </span><br><span class="line">    <span class="type">float</span> someEndingVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以，参考 https://github.com/KhronosGroup/SPIRV-Guide/blob/master/chapters/access_chains.md</span></span><br><span class="line"><span class="comment">// 的例子</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （应该）可以编译通过</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    <span class="type">float</span> someBeginningVar;</span><br><span class="line">&#125; objectBuffer;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectData</span> &#123;</span></span><br><span class="line">    vec4 model;</span><br><span class="line">    <span class="type">float</span> moreData;</span><br><span class="line">    vec4 padThis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WritableData</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> testData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) readonly buffer objectBufferType &#123;</span><br><span class="line">    ObjectData objects[];</span><br><span class="line">&#125; objectBuffer;</span><br><span class="line"></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">1</span>) buffer myWritableBufferType &#123;</span><br><span class="line">    WritableData datas[];</span><br><span class="line">&#125; writableBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="type">int</span>(gl_FragCoord.x * <span class="number">1000</span>);</span><br><span class="line">    outFragColor = objectBuffer.objects[index].model;</span><br><span class="line">    writableBuffer.datas[index].testData = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 42</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %gl_FragCoord %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %index &quot;index&quot;</span><br><span class="line">               OpName %gl_FragCoord &quot;gl_FragCoord&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpName %WritableData &quot;WritableData&quot;</span><br><span class="line">               OpMemberName %WritableData 0 &quot;testData&quot;</span><br><span class="line">               OpName %myWritableBufferType &quot;myWritableBufferType&quot;</span><br><span class="line">               OpMemberName %myWritableBufferType 0 &quot;datas&quot;</span><br><span class="line">               OpName %writableBuffer &quot;writableBuffer&quot;</span><br><span class="line">               OpDecorate %gl_FragCoord BuiltIn FragCoord</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line">               OpMemberDecorate %WritableData 0 Offset 0</span><br><span class="line">               OpDecorate %_runtimearr_WritableData ArrayStride 4</span><br><span class="line">               OpMemberDecorate %myWritableBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %myWritableBufferType BufferBlock</span><br><span class="line">               OpDecorate %writableBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %writableBuffer Binding 1</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Input_v4float = OpTypePointer Input %v4float</span><br><span class="line">%gl_FragCoord = OpVariable %_ptr_Input_v4float Input</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">%_ptr_Input_float = OpTypePointer Input %float</span><br><span class="line"> %float_1000 = OpConstant %float 1000</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_v4float = OpTypePointer Uniform %v4float</span><br><span class="line">%WritableData = OpTypeStruct %float</span><br><span class="line">%_runtimearr_WritableData = OpTypeRuntimeArray %WritableData</span><br><span class="line">%myWritableBufferType = OpTypeStruct %_runtimearr_WritableData</span><br><span class="line">%_ptr_Uniform_myWritableBufferType = OpTypePointer Uniform %myWritableBufferType</span><br><span class="line">%writableBuffer = OpVariable %_ptr_Uniform_myWritableBufferType Uniform</span><br><span class="line">  %float_123 = OpConstant %float 123</span><br><span class="line">%_ptr_Uniform_float = OpTypePointer Uniform %float</span><br><span class="line"></span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">      %index = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %16 = OpAccessChain %_ptr_Input_float %gl_FragCoord %uint_0</span><br><span class="line">         %17 = OpLoad %float %16</span><br><span class="line">         %19 = OpFMul %float %17 %float_1000</span><br><span class="line">         %20 = OpConvertFToS %int %19</span><br><span class="line">               OpStore %index %20</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br><span class="line">         %32 = OpLoad %v4float %31</span><br><span class="line">               OpStore %outFragColor %32</span><br><span class="line">         %38 = OpLoad %int %index</span><br><span class="line">         %41 = OpAccessChain %_ptr_Uniform_float %writableBuffer %int_0 %38 %int_0</span><br><span class="line">               OpStore %41 %float_123</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">               OpName %ObjectData &quot;ObjectData&quot;</span><br><span class="line">               OpMemberName %ObjectData 0 &quot;model&quot;</span><br><span class="line">               OpMemberName %ObjectData 1 &quot;moreData&quot;</span><br><span class="line">               OpMemberName %ObjectData 2 &quot;padThis&quot;</span><br><span class="line"></span><br><span class="line">               OpName %objectBufferType &quot;objectBufferType&quot;</span><br><span class="line">               OpMemberName %objectBufferType 0 &quot;objects&quot;</span><br><span class="line">               OpName %objectBuffer &quot;objectBuffer&quot;</span><br><span class="line">               OpMemberDecorate %ObjectData 0 Offset 0</span><br><span class="line">               OpMemberDecorate %ObjectData 1 Offset 16</span><br><span class="line">               OpMemberDecorate %ObjectData 2 Offset 32</span><br><span class="line">               OpDecorate %_runtimearr_ObjectData ArrayStride 48</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 NonWritable    ; 如果可变则无此 decorate</span><br><span class="line">               OpMemberDecorate %objectBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %objectBufferType BufferBlock</span><br><span class="line">               OpDecorate %objectBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %objectBuffer Binding 0</span><br><span class="line"> %ObjectData = OpTypeStruct %v4float %float %v4float</span><br><span class="line">%_runtimearr_ObjectData = OpTypeRuntimeArray %ObjectData           ; Declare a new run-time array type.</span><br><span class="line">                                                                   ; Its length is not known at compile time.</span><br><span class="line">                                                                   ; See OpArrayLength for getting the Length</span><br><span class="line">                                                                   ; of an array of this type.</span><br><span class="line">%objectBufferType = OpTypeStruct %_runtimearr_ObjectData</span><br><span class="line">%_ptr_Uniform_objectBufferType = OpTypePointer Uniform %objectBufferType</span><br><span class="line">%objectBuffer = OpVariable %_ptr_Uniform_objectBufferType Uniform</span><br><span class="line"></span><br><span class="line">; 访问</span><br><span class="line">; 使用 OpAccessChain 指令，该指令是 base, indices... 格式</span><br><span class="line">; 此例子： objectBuffer[0 th][index th][0 th] 来获得 model 的指针，该指针之后可以 load / store</span><br><span class="line">         %29 = OpLoad %int %index</span><br><span class="line">         %31 = OpAccessChain %_ptr_Uniform_v4float %objectBuffer %int_0 %29 %int_0</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-操作"><a href="#Atomic-操作" class="headerlink" title="Atomic 操作"></a>Atomic 操作</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc">https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/atomics.adoc</a></p>
</blockquote>
<p>GLSL 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line">layout (location = <span class="number">0</span>) out vec4 outFragColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std430 vs std140: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</span></span><br><span class="line">layout(std430, <span class="built_in">set</span> = <span class="number">1</span>, binding = <span class="number">0</span>) buffer statsBufferType &#123;</span><br><span class="line">    <span class="type">int</span> totalInvocations;</span><br><span class="line">&#125; statsBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// returns the value before the add</span></span><br><span class="line">    <span class="type">int</span> globalIdx = atomicAdd(statsBuffer.totalInvocations, <span class="number">1</span>);</span><br><span class="line">    outFragColor = vec4(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPIR-V 反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; SPIR-V</span><br><span class="line">; Version: 1.0</span><br><span class="line">; Generator: Khronos Glslang Reference Front End; 10</span><br><span class="line">; Bound: 26</span><br><span class="line">; Schema: 0</span><br><span class="line">               OpCapability Shader</span><br><span class="line">          %1 = OpExtInstImport &quot;GLSL.std.450&quot;</span><br><span class="line">               OpMemoryModel Logical GLSL450</span><br><span class="line">               OpEntryPoint Fragment %main &quot;main&quot; %outFragColor</span><br><span class="line">               OpExecutionMode %main OriginUpperLeft</span><br><span class="line">               OpSource GLSL 450</span><br><span class="line">               OpName %main &quot;main&quot;</span><br><span class="line">               OpName %globalIdx &quot;globalIdx&quot;</span><br><span class="line">               OpName %statsBufferType &quot;statsBufferType&quot;</span><br><span class="line">               OpMemberName %statsBufferType 0 &quot;totalInvocations&quot;</span><br><span class="line">               OpName %statsBuffer &quot;statsBuffer&quot;</span><br><span class="line">               OpName %outFragColor &quot;outFragColor&quot;</span><br><span class="line">               OpMemberDecorate %statsBufferType 0 Offset 0</span><br><span class="line">               OpDecorate %statsBufferType BufferBlock</span><br><span class="line">               OpDecorate %statsBuffer DescriptorSet 1</span><br><span class="line">               OpDecorate %statsBuffer Binding 0</span><br><span class="line">               OpDecorate %outFragColor Location 0</span><br><span class="line">       %void = OpTypeVoid</span><br><span class="line">          %3 = OpTypeFunction %void</span><br><span class="line">        %int = OpTypeInt 32 1</span><br><span class="line">%_ptr_Function_int = OpTypePointer Function %int</span><br><span class="line">%statsBufferType = OpTypeStruct %int</span><br><span class="line">%_ptr_Uniform_statsBufferType = OpTypePointer Uniform %statsBufferType</span><br><span class="line">%statsBuffer = OpVariable %_ptr_Uniform_statsBufferType Uniform</span><br><span class="line">      %int_0 = OpConstant %int 0</span><br><span class="line">%_ptr_Uniform_int = OpTypePointer Uniform %int</span><br><span class="line">      %int_1 = OpConstant %int 1</span><br><span class="line">       %uint = OpTypeInt 32 0</span><br><span class="line">     %uint_1 = OpConstant %uint 1</span><br><span class="line">     %uint_0 = OpConstant %uint 0</span><br><span class="line">      %float = OpTypeFloat 32</span><br><span class="line">    %v4float = OpTypeVector %float 4</span><br><span class="line">%_ptr_Output_v4float = OpTypePointer Output %v4float</span><br><span class="line">%outFragColor = OpVariable %_ptr_Output_v4float Output</span><br><span class="line">    %float_1 = OpConstant %float 1</span><br><span class="line">         %25 = OpConstantComposite %v4float %float_1 %float_1 %float_1 %float_1</span><br><span class="line">       %main = OpFunction %void None %3</span><br><span class="line">          %5 = OpLabel</span><br><span class="line">  %globalIdx = OpVariable %_ptr_Function_int Function</span><br><span class="line">         %14 = OpAccessChain %_ptr_Uniform_int %statsBuffer %int_0</span><br><span class="line">         %19 = OpAtomicIAdd %int %14 %uint_1 %uint_0 %int_1             ; Pointer = %14</span><br><span class="line">                                                                        ; Memory Scope = %uint_1 = 1</span><br><span class="line">                                                                        ; =&gt; Scope is the current device</span><br><span class="line">                                                                        ; Semantics = %uint_0 = 0</span><br><span class="line">                                                                        ; =&gt; None (relaxed)</span><br><span class="line">                                                                        ; Value = %uint_1 = 1</span><br><span class="line">               OpStore %globalIdx %19</span><br><span class="line">               OpStore %outFragColor %25</span><br><span class="line">               OpReturn</span><br><span class="line">               OpFunctionEnd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Memory Scope: <a target="_blank" rel="noopener" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-</a></p>
</blockquote>
<h2 id="Coming-soon"><a href="#Coming-soon" class="headerlink" title="Coming soon"></a>Coming soon</h2><ul>
<li>Matrix 类型</li>
<li>导数 <code>dFdx</code> &#x2F; <code>dFdy</code> &amp; <code>discard</code><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/gpuweb/gpuweb/issues/361">https://github.com/gpuweb/gpuweb/issues/361</a></li>
<li><a target="_blank" rel="noopener" href="http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/">http://www.xionggf.com/post/opengl/an_introduction_to_shader_derivative_functions/</a></li>
</ul>
</li>
<li>Group Ops</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/auto-shader-mesh-lod" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/auto-shader-mesh-lod/"><strong>论文阅读 | Automatic Mesh and Shader Level of Detail</strong></a>
      <small class=article-date-index>&nbsp; 2023-02-21</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/auto-shader-mesh-lod/" class="article-date">
  <time datetime="2023-02-20T16:00:00.000Z" itemprop="datePublished">2023-02-21</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章给出了在自适应划分的距离组下同时优化网格和 Shader 的 LOD 的优化算法。</p>
<p>文章中首先提出了被称为“交替优化”的优化算法，其中首先对 Shader 利用遗传算法进行变异，得到若干变体，再利用网格简化算法来以 image loss 进行网格简化，使得在给定距离上每个变体对应的运算代价小于给定开销，且误差上满足要求。之后，这些变体会进行排序，前 N% 的变体进入下一轮交替优化，反复多轮后得到结果。</p>
<p>针对交替优化耗时较长的问题，文章中还提出了“分别优化”的算法。该算法会首先分别对网格和 Shader 独立的进行简化，得到一系列质量单调下降的 Shader 和网格变体列，然后再针对每个距离组选择合适的网格和 Shader 对。为了让 LOD 组间的变化尽可能平滑，文章还设置了最平滑的 LOD 切换路线的查找，以及 LOD 组数量的优化操作。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li>网格简化和 LOD 生成</li>
<li>Shader 简化和 LOD 生成</li>
<li>基于外观的联合优化</li>
</ul>
<h2 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h2><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>对于 Shader 和网格简化问题，定义三元组 $ (M_i, S_i, d_i) $，其中</p>
<ul>
<li>$ M_i $ 为原网格 $ M $ 的第 $ i $ 个简化变体</li>
<li>$ S_i $ 为原 Shader $ S $ 的第 $ i $ 个简化变体 </li>
<li>$ d_i $ 为距相机的距离</li>
</ul>
<p>定义 $ \epsilon_a(i) $ 为简化 $ (M_i, S_i, d_i) $ 变体的绝对图像误差，其定义为</p>
$$
\epsilon_a (i) = \int_H \| f(M_i, S_i, d_i) - \bar{f}(M, S, d_i) \| dH
$$

<p>这里的作为误差模型的积分域 $ H &#x3D; V \times U \times X \times Y $ ，其中</p>
<ul>
<li>$ V $ 为离散的若干个 view direction</li>
<li>$ U $ 若干 Shader uniform 参数，如光照方向</li>
<li>$ X \times Y $ 为图像空间的两个维度</li>
</ul>
<p>这里的范数是 pixelwise RGB $ L^2 $ 范数。</p>
<p>另外，定义 $ \epsilon_t(i) $ 为两个简化组之间的视觉差异：</p>
$$
\epsilon_t (i) = \int_H \| f(M_i, S_i, d_{i+1}) - f(M_{i+1}, S_{i+1}, d_{i+1}) \| dH
$$

<p>这样，LOD 优化问题就可以看作下面的数学问题：</p>
$$
\mathop{\arg \min}_{M_i, S_i, d_i} t = Cost ( f(M_i, S_i, d_i) ) \\
\mathrm{s.t.}\quad \epsilon_a(i) < e_a (d_i) \cdot s_{d_i}
$$

<p>其中 Cost 为在该网格上应用此 Shader 进行着色的时间开销，$ e_a (d_i) $ 为在 $ d_i $ 距离的 absolute per-pixel error bound， $ s_{d_i} $ 为距离 $ d_i $ 时网格 $ M_i $ 的投影大小，</p>
<p>其中 $ e_a(d) $ 采用前面工作提出的一个启发函数：</p>
$$
e_a(d) = (\frac{d-d_{near}}{d_{far} - d_{near}})^Q \cdot e_{max}
$$

<p>其中</p>
<ul>
<li>$ d_{near} $ 和 $ d_{far} $ 是设置的视景体参数</li>
<li>$ e_{max} $ 是 maximum absolute per pixel error bound<ul>
<li>也就是关于 $ e_t(i) $ 的积分项关于积分域里面各个部分的最大值</li>
</ul>
</li>
<li>$ Q \in [0, 1] $ 反映了对误差的容忍程度</li>
</ul>
<h3 id="交替优化"><a href="#交替优化" class="headerlink" title="交替优化"></a>交替优化</h3><h4 id="Shader-简化"><a href="#Shader-简化" class="headerlink" title="Shader 简化"></a>Shader 简化</h4><blockquote>
<p>这里的 Shader 简化工作主要参考了前面的文章：</p>
<ul>
<li>[3] Y. He, T. Foley, N. Tatarchuk, and K. Fatahalian, “A system for rapid, automatic shader level-of-detail,” ACM Trans. on Graph. (TOG), vol. 34, no. 6, p. 187, 2015.</li>
<li>[8] R. Wang, X. Yang, Y. Yuan, W. Chen, K. Bala, and H. Bao, “Automatic shader simplification using surface signal approximation,” ACM Trans. on Graph. (TOG), vol. 33, no. 6, p. 226, 2014.</li>
<li>[18] F. Pellacini, “User-configurable automatic shader simplification,”<br>ACM Trans. Graph., vol. 24, no. 3, pp. 445–452, 2005</li>
<li>[21] P. Sitthi-Amorn, N. Modly, W. Weimer, and J. Lawrence, “Genetic programming for shader simplification,” in ACM Transactions on Graphics (TOG), vol. 30, no. 6. ACM, 2011, p. 152.</li>
</ul>
</blockquote>
<ol>
<li>将 Vertex Shader 和 Fragment Shader 转换为抽象语法树 (AST) 和程序依赖图 (PDG)</li>
<li>应用不同的化简规则来生成简化 Shader<ul>
<li>Operation Removal: 将 $ op(a, b) $ 省略为 $ a $ 或 $ b $</li>
<li>Code Transformation: 将 per-pixel 的 pixel shader 操作移动到 per-vertex 或 per-tessellated-vertex 的操作来减少计算量</li>
<li>Moving to parameter: 将参数用其均值替换（$ n \to average(n) $），并且替换到 “parameter stage” 中进行计算（详见 [3]），并将均值作为结果送入 GPU Shader 中</li>
</ul>
</li>
</ol>
<blockquote>
<p>本文并没有对 Shader 本身的优化方面做出额外的创新。这些方法主要来源于 [3] 这篇文章。</p>
</blockquote>
<h4 id="Mesh-简化"><a href="#Mesh-简化" class="headerlink" title="Mesh 简化"></a>Mesh 简化</h4><blockquote>
<p>Mesh 简化工作：</p>
<ul>
<li>[4] M. Garland and P. S. Heckbert, “Surface simplification using<br>quadric error metrics,” in Proceedings of the 24th annual conference on<br>Computer graphics and interactive techniques. ACM Press&#x2F;AddisonWesley Publishing Co., 1997, pp. 209–216.</li>
<li>[7] P. Lindstrom and G. Turk, “Image-driven simplification,” ACM<br>Transactions on Graphics (ToG), vol. 19, no. 3, pp. 204–241, 2000</li>
</ul>
</blockquote>
<p>主要用了 [7] 中的 Image-driven simplification 的方法。这个方法是基于顶点对折叠的，每次折叠选择使 image error 升高最低的一对顶点。</p>
<blockquote>
<p><strong>QEM</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf">https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf</a><br><a target="_blank" rel="noopener" href="http://mgarland.org/research/quadrics.html">http://mgarland.org/research/quadrics.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lafengxiaoyu/article/details/72812681">https://blog.csdn.net/lafengxiaoyu/article/details/72812681</a></p>
<p>QEM 是 SIGGRAPH’97 提出的经典算法，截至现在已经有大约 5000 次引用。</p>
</blockquote>
<h4 id="交替优化-1"><a href="#交替优化-1" class="headerlink" title="交替优化"></a>交替优化</h4><p>给定网格 $ M $ 和 Shader $ S $，</p>
<ol>
<li>搞 Shader 优化 (然后生成一堆变体 $ S_i $)</li>
<li>对于每个在 Pareto frontier 上的 $ S_i $，利用该 Shader 进行相应的 Mesh 简化，使得新的 $ M_j $ 在满足质量要求 (也就是 error &lt;&#x3D; absolute error bound) 的情况下为最简<blockquote>
<p>Pareto frontier 上的 $ S_i $ 满足</p>
<ul>
<li>不存在另一个 Shader，他的性能一样，质量更好</li>
<li>不存在另一个 Shader，他的质量一样，性能更好</li>
</ul>
</blockquote>
</li>
<li>将这些 $ (M_j, S_i) $ 按渲染性能排序，取前 20% 作为种子进入下一轮迭代</li>
</ol>
<h3 id="分别优化"><a href="#分别优化" class="headerlink" title="分别优化"></a>分别优化</h3><h4 id="生成网格变体"><a href="#生成网格变体" class="headerlink" title="生成网格变体"></a>生成网格变体</h4><p>因为没有任何关于简化后 Shader 的信息，所以作者此处采用原 Shader 进行着色后 supersampled &#x2F; filtered 的图片作为 loss 环节进行网格简化。</p>
<p>因为某些边简化之后对视觉表现没有什么影响，所以这里只选取 K (实现中 K &#x3D; 500) 个有较大 error 变化的简化网格作为候选变体。</p>
<h4 id="生成-Shader-变体"><a href="#生成-Shader-变体" class="headerlink" title="生成 Shader 变体"></a>生成 Shader 变体</h4><p>理论上，对于不同的场景配置 (简化网格 &amp; 距离配置)，最优的 Shader 变体是不同的。</p>
<p>但是，因为</p>
<ol>
<li>First, as has been proven in prior work [3], the performance and error of shader variants can be predicted instead of being actually evaluated. In this way, we do not need to actually render every shader variant under all scene configurations.<blockquote>
<p>在 [3] 中，性能的预测是通过一种简单的启发函数，即 <code>scalar fp ops + 100 * texture ops</code> 来预测的（不同 Shader stage 有不同权重，parameter 数量有额外惩罚）</p>
<p>error 的评价是通过 error cache 和偶尔的重新 evaluate 来实现的</p>
</blockquote>
</li>
<li>Second, we noted that for one shader variant with one simplified mesh, the shading errors at distances could be approximated by filtering the rendered image at the closest distance.<blockquote>
<p>通过在最近距离生成着色结果，再进行 filter 来模拟在远处的结果</p>
</blockquote>
</li>
<li>Finally, we further observed that although these Pareto frontiers may change with scene configurations, the shader variants on Pareto frontiers are similar at similar distances and with similarly simplified meshes. <blockquote>
<p>Pareto 面上的 shader 变体基本上是比较稳定的，随着场景配置的变化不是很多</p>
</blockquote>
</li>
</ol>
<p>所以，作者最后只选择<strong>有代表性的距离</strong>和<strong>有代表性的简化网格</strong>来计算最优 Shader 变体，而不是穷举所有场景配置。</p>
<p>作者选择均匀的从 N 组距离组里面选择 4 组，然后每个距离组里面选择 10 个前面的简化网格（即 Pareto 面左右的十个），就得到了 40 个组合。然后用 genetic programming 的优化方法来得到每个 (距离, 网格) 组上的最优简化 Shader。这些优化好的 Shader 变体都放到一个数组里面。</p>
<p>然后，作者近似的认为整个问题是一个凸区域上找可行域边界的问题，所以只需要 1D search，而不需要遍历 2D 区域。</p>
<p>然后，再用 find smooth path 的技术来获得比较连续的 LOD transition。</p>
<blockquote>
<p>具体来说，就是每个边的权重是在边界处的图像损失，这样图像损失小的转换会更容易被选中。</p>
</blockquote>
<p>最后，合并区别不大的 LOD 组。</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/cross-machine-black-box-GPU-perf-modeling" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/cross-machine-black-box-GPU-perf-modeling/"><strong>论文阅读 | 平衡精确度和预测范围的黑盒 GPU 性能建模</strong></a>
      <small class=article-date-index>&nbsp; 2023-02-16</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/cross-machine-black-box-GPU-perf-modeling/" class="article-date">
  <time datetime="2023-02-15T16:00:00.000Z" itemprop="datePublished">2023-02-16</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章提出了一种跨机器，黑盒，基于微测试 (microbenchmark) 的方法来解析的对不同实现变体的 OpenCL kernel 的执行时间进行预测和最优 kernel 选择。</p>
<p>简单来说，本文大的思路是，收集一些 kernel 中出现的<strong>特征</strong>和对应特征在运行时会出现的<strong>频率</strong>，利用 microbenchmark 在目标平台上测量这些<strong>特征</strong>每次出现会花费的运行时间，再用一个（多重）线性模型来拟合最后的运行时间。</p>
<p>由于文章比较长，此处将文章的大概结构列举如下：</p>
<ul>
<li>Section 1: 简介</li>
<li>Section 2: 解释性的例子</li>
<li>Section 3: 本文贡献概况</li>
<li>Section 4: 本文采用的假设和局限性</li>
<li>Section 5: <strong>收集 kernel 统计信息</strong></li>
<li>Section 6: <strong>建模 kernel 执行时间</strong></li>
<li>Section 7: <strong>校准模型参数</strong></li>
<li>Section 8: 结果展示</li>
<li>Section 9: 作者调研到的、其它相关的性能建模方法</li>
</ul>
<h2 id="本文的假设和局限性"><a href="#本文的假设和局限性" class="headerlink" title="本文的假设和局限性"></a>本文的假设和局限性</h2><p>本文提到的一些 assumptions：</p>
<ul>
<li>(usefulness) 可以帮助用户理解给定机器的性能特性，并且给优化器提供变体性能数据预测参考，同时降低需要在目标系统实际测量的数据数量</li>
<li>(accuracy) 根据检索到的相关文献显示，在本文提及的 GPU kernel 性能预测问题上，没有方法可以一致的获得小于个位数的预测误差，所以本文也设定这样的目标</li>
<li>(cost-explanatory): 和其它基于排名的方法不同 (Chen et al. (2018))，虽然本文优化的目标是在各种变体中进行选择，但是本文中模型的主要输出为运行时间，且采用比较可解释的线性模型进行建模</li>
</ul>
<p>本文提到的一些局限：</p>
<ul>
<li>硬件资源的利用率：<ul>
<li>硬件资源的利用率会影响最终的性能。比如，峰值浮点性能受 SIMD lane 使用率影响，片上状态存储器 (VGPR, Scratchpad Memory) 会影响调度槽位的利用率，进而影响延迟隐藏的能力</li>
<li>不过，采用本文的方法，基本的性能损失系数是比较容易解释和估计的。比如，实际的内存带宽利用率，以及峰值 FLOP&#x2F;s</li>
<li>即使无法达到硬件资源的全部利用，对于硬件资源利用率随参数变化相对稳定的场合，本文的模型仍然可以适用。不过对于变化的情况，让本文提出的模型适用的唯一可行方法，就是将模型的粒度调低到类似 SIMD lane 的水平，这样利用率的变化就不再相关了。ECM 系列模型就是这样考虑这个问题的。<blockquote>
<p>?</p>
</blockquote>
</li>
<li>为了简化的处理这个问题，本文采用 workgroup size 恒定为 256 的参数设定。</li>
</ul>
</li>
<li>程序建模上的简化：<ul>
<li>本文的模型中，主要检测的是基于某种特殊类别的操作 (e.g. 浮点操作，特殊类型的访存) 和检测到该特征出现的次数，其中次数被建模为 non-data-dependent 的一个特征。<ul>
<li>Polyhedrally-given loop domain?</li>
</ul>
</li>
<li>所有分支指令都假设两个分支均会执行，即假设 GPU 采用 masking 的方式进行执行。<blockquote>
<p>文章认为这和 GPU 的行为是匹配的，不过显然不完全是。较新的 GPU 是同时支持 branching 和 masking 的。masking 存在的意义是对于短分支来说，可以不打断流水线。</p>
</blockquote>
</li>
</ul>
</li>
<li>内存访问开销评估：<ul>
<li>内存访问的开销受到程序访问的局部性，以及对于 banked memory 来说的 bank 竞争问题的影响。</li>
<li>本文将内存访问切分成了两种：<ul>
<li>对于各个程序都常见的，比较简单的访存模式，用 Section 6.1.1 的办法按 interlane stride, utilization radio 和 data width 进行分类<blockquote>
<p>quasi-affine? </p>
</blockquote>
</li>
<li>对于更复杂的访存模式，在 Section 7.1.1 中提供一种单独抽出来在循环里面按该模式进行访存，并且进行测量的机制</li>
</ul>
</li>
</ul>
</li>
<li>平台无关：<ul>
<li>本文提出的系统作用于 OpenCL 上，但是相似的系统在 CUDA 上也可以比较轻松的实现。</li>
</ul>
</li>
</ul>
<h2 id="收集-kernel-统计信息"><a href="#收集-kernel-统计信息" class="headerlink" title="收集 kernel 统计信息"></a>收集 kernel 统计信息</h2><h3 id="计算每个特征的预期出现次数"><a href="#计算每个特征的预期出现次数" class="headerlink" title="计算每个特征的预期出现次数"></a>计算每个特征的预期出现次数</h3><p>前面提到，本文假设程序中出现的所有循环，其循环次数和本次运行所使用的数据无关，即 non-data-dependent。</p>
<p>这种情况下，如果要求解循环体中每个语句的运行次数，简单的做法是将所有循环展开，不过这样效率会比较低。事实上，此处可以把问题看作：在 $ d $ 维的整数空间 $ \mathrm{Z}^d $ 中，可行区域是由一些约束条件构成的超平面截出来的一个子区域，某个语句的循环次数就是在该子区域中整数格点的数目。</p>
<p>文章汇总提到，用 <code>barvinok</code> 和 <code>isl</code> 库一起，可以解决前面这个数循环体内语句执行次数的问题，其中 <code>barvinok</code> 是基于 Barvinok 算法的，这是一个比较高效的、计算有理凸多胞形中的格点数目的算法。</p>
<p>当然，还要分析好一条语句内真正进行计算或数据搬运的相应特征和次数。</p>
<blockquote>
<p>为什么要抽象成有理凸多胞形？ 这是因为真正循环的次数和 Kernel 本身的一些参数，以及 Kernel 的 Launch parameters 也有关系，这里希望带着这些参数做符号计算，让模型更有用一些（比如说，优化这些参数会变得容易）</p>
</blockquote>
<h3 id="计数粒度-count-granularity"><a href="#计数粒度-count-granularity" class="headerlink" title="计数粒度 (count granularity)"></a>计数粒度 (count granularity)</h3><p>计数粒度设计的思路是，计数出来的次数尽可能贴近真实 GPU 硬件中所执行操作的次数。</p>
<p>比如，我们知道，在 OpenCL 的调度模型中，每个 <code>sub-group</code> 会尽可能匹配 GPU 调度的最小单位，并且视硬件能力 <code>sub-group</code> 内部会支持一些 reduce 和 scatter 等原语，并且算数指令一般也是以 <code>sub-group</code> 为粒度进行调度和实现的。这样，算术指令就应该以 <code>sub-group</code> 为粒度计数。</p>
<p>当然，具体 <code>sub-group</code> 的数目是依赖具体的 Kernel launch parameters 的，不过这里对前面参数的依赖是多项式形式的 (比如 <code>work-group count / 32</code>），所以可以作为一个含参的量，让前面的循环次数计算也成为一个含参的值。</p>
<!-- TOOD: check this paragraph -->

<p>粒度有如下三种：</p>
<ul>
<li>per work-item<ul>
<li>同步障操作 (barrier synchronization)</li>
</ul>
</li>
<li>per sub-group （subgroup size 需要用户提供）<ul>
<li>片上操作：算数指令和 local memory 访问</li>
<li>uniform 访问：global memory 访问，但是 <code>lid(0)</code> stride 0，即多个线程访问同一块内存区域</li>
</ul>
</li>
<li>per work-group （没有给出例子）</li>
</ul>
<blockquote>
<p>这里的讨论很不详细，需要和下面一起看</p>
</blockquote>
<h2 id="建模-kernel-执行时间"><a href="#建模-kernel-执行时间" class="headerlink" title="建模 kernel 执行时间"></a>建模 kernel 执行时间</h2>$$
T_\text{wall}({\bf n}) = \text{feat}^\text{out}({\bf n}) \approx g(\text{feat}^\text{in}_0({\bf n}), ..., \text{feat}^\text{in}_j({\bf n}), p_0, ..., p_k)
$$

<p>其中：</p>
<ul>
<li>$ {\bf n} $ 是整个计算过程中为常数的、仅与各种变体相关的整数向量</li>
<li>$ \text{feat}^\text{in}_j({\bf n}) $ 是某种单元特征的出现次数（比如单精度 FP32 乘法数）</li>
<li>$ p_i $ 是硬件相关的校正参数</li>
<li>$ g $ 是用户提供的可微函数</li>
</ul>
<h3 id="kernel-特征"><a href="#kernel-特征" class="headerlink" title="kernel 特征"></a>kernel 特征</h3><h4 id="数据移动特征"><a href="#数据移动特征" class="headerlink" title="数据移动特征"></a>数据移动特征</h4><p>对于大多数计算 kernel 来说，数据搬运所占的开销是大头。</p>
<p>内存访问模式：</p>
<ul>
<li>内存类别：global &#x2F; local</li>
<li>访问类型：load &#x2F; store</li>
<li>the local and global strides along each thread axis in the array index<ul>
<li>也就是说，每次 <code>gid(0)</code>, <code>gid(1)</code>, <code>lid(0)</code>, <code>lid(1)</code> 自增一的时候，对 array 数组访问的偏移要分别增加多少</li>
</ul>
</li>
<li>the ratio of the number of element accesses to the number of elements accessed (access-to-footprint ratio, or AFR)<ul>
<li><code>AFR = 1</code>: every element in the footprint is accessed one time</li>
<li><code>AFR &gt; 1</code>: some elements are accessed more than once<ul>
<li>这样 Cache 就可能会对速度有加成了</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>文章中提到，解析形式的模型需要建模很多机器细节，比如 workgroup 调度，内存系统架构等，来达到和黑盒模型相似的精度。一个例子是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k_out = <span class="number">0</span>; k_out &lt;= ((<span class="number">-16</span> + n) / <span class="number">16</span>); ++k_out)</span><br><span class="line">  ...</span><br><span class="line">  a_fetch[...] = a[n*(<span class="number">16</span>*gid(<span class="number">1</span>) + lid(<span class="number">1</span>)) + <span class="number">16</span>*k_out + lid(<span class="number">0</span>)];</span><br><span class="line">  b_fetch[...] = b[n*(<span class="number">16</span>*k_out + lid(<span class="number">1</span>)) + <span class="number">16</span>*gid(<span class="number">0</span>) + lid(<span class="number">0</span>)];</span><br></pre></td></tr></table></figure>

<p>这个例子里面的内存访问模式如下：</p>
<table>
<thead>
<tr>
<th>Array</th>
<th>Ratio</th>
<th>Local strides</th>
<th>Global strides</th>
<th>Loop stride</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>n&#x2F;16</td>
<td>{0:1, 1:n}</td>
<td>{0:0, 1:n*16}</td>
<td>16</td>
</tr>
<tr>
<td>b</td>
<td>n&#x2F;16</td>
<td>{0:1, 1:n}</td>
<td>{0:16, 1:0}</td>
<td>16*n</td>
</tr>
</tbody></table>
<p>这两个例子的性能差距在 5 倍左右。</p>
</blockquote>
<p>With this approach, a universal model for all kernels on all hardware based on kernel-level features like ours  could need a prohibitively large number of global memory access features and corresponding measurement kernels. This motivates our decision to allow proxies of “in-situ” memory accesses to be included as features, which in turn motivates our ‘work removal’ code transformation, discussed in Section 7.1.1. This transformation facilitates generation of microbenchmarks exercising memory accesses which match the access patterns found in specific computations by stripping away unrelated portions of the computation in an automated fashion.</p>
<p>Specifying Data Motion Features in the Model: 弄个 aLD, bLD, f_mem_access_tag</p>
<p>也可以手动指定，不用运行时测量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Model(</span><br><span class="line">  <span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides:&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>显式语法格式如下：<code>&quot;f_mem_access_tag:&lt;mem access tag&gt;_&lt;mem type&gt;_&lt;data type&gt;_&lt;direction&gt;_lstrides:&#123;&lt;local stride constraints&gt;&#125;_gstrides:&#123;&lt;global stride constraints&gt;&#125;_afr:&lt;AFR constraint&gt;&quot;</code></p>
<h4 id="算术操作特征"><a href="#算术操作特征" class="headerlink" title="算术操作特征"></a>算术操作特征</h4><p>特征：</p>
<ul>
<li>操作类型：加法、乘法、指数</li>
<li>数据类型：float32, float64</li>
</ul>
<p>本文中的工作不考虑整数算术特征，因为在模型考虑的 kernel 变体中，整数算术只用在了数组下标计算中。</p>
<h4 id="同步特征"><a href="#同步特征" class="headerlink" title="同步特征"></a>同步特征</h4><p>特征：</p>
<ul>
<li>局部同步障 (local barriers)</li>
<li>kernel 启动</li>
</ul>
<p>这里 Local barriers 是 per work-item 的，然后根据实际程序同步的需要，可能需要进行乘以同时进行同步的 work item 数量。</p>
<p>简单来说就是，认为参与同步的 thread 越多越耗时。</p>
<blockquote>
<p>Recall that the statistics gathering module counts the number of synchronizations encountered by a single work-item, so depending on how a user intends to model execution, they may need to multiply a synchronization feature like local barriers by, e.g., the number of work-groups, a feature discussed in the next section.</p>
<p>A user might incorporate synchronization features into this model as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h3><ul>
<li>Thread groups feature<ul>
<li>给定 workgroup count，进行不同 workgroup count 间启动时间补偿</li>
</ul>
</li>
<li>OpenCL wall time feature<ul>
<li>给定 platform 和 device 下，执行 60 遍获得平均 walltime，作为输出特征</li>
<li>“We measure kernel execution time excluding any host-device transfer of data.”</li>
</ul>
</li>
</ul>
<p>一个完整的模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model = Model(<span class="string">&quot;f_cl_wall_time_nvidia_geforce&quot;</span>,</span><br><span class="line">  <span class="string">&quot;p_f32madd * f_op_float32_madd + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32l * f_mem_access_local_float32 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32ga * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:0&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gb * f_mem_access_global_float32_load_lstrides :&#123;0:1;1:&gt;15&#125;_gstrides:&#123;0:16&#125;_afr:&gt;1 + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_f32gc * f_mem_access_global_float32_store + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_barrier * f_sync_barrier_local * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_group * f_thread_groups + &quot;</span></span><br><span class="line">  <span class="string">&quot;p_launch * f_sync_kernel_launch&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="校准模型参数"><a href="#校准模型参数" class="headerlink" title="校准模型参数"></a>校准模型参数</h2><p>Work Removal Transformation: a code transformation that can extract a set of desired operations from a given computation, while maintaining overall loop structure and sufficient data flow to avoid elimination of further parts of the computation by optimizing compilers</p>
<p>Work Removal 变换会把 on-chip 工作从 kernel 中去掉，达成两方面目的：</p>
<ol>
<li>测试 on-chip work 和 global memory access 各自占用时间，决定是否要进行 latency hiding</li>
<li>测试某种特殊访存模型的时间占用</li>
</ol>
<h3 id="Measurement-kernel-设计"><a href="#Measurement-kernel-设计" class="headerlink" title="Measurement kernel 设计"></a>Measurement kernel 设计</h3><ul>
<li>Global memory access<ul>
<li>AFR &#x3D; 1: Fully specified by local strides, global strides, data size<ul>
<li>That is, patterns that do not produce a write race and not nested inside sequential loops</li>
<li>Performs global load from each of <em>a variable number of input arrays</em> using the specified access pattern</li>
<li>Each work-item then stores the sum of the input array values it fetched in a single result array</li>
<li>Params: data type, global memory array size, work-group dimensions, number of input arrays, thread index strides</li>
</ul>
</li>
<li>AFR &gt; 1:<ul>
<li>Use <strong>Work Removal Tranformation</strong> to generate dedicated measurement kernel.</li>
</ul>
</li>
</ul>
</li>
<li>Arithmetic operations<ul>
<li>First, have each work-item initialize 32 private variables of the specified data type</li>
<li>Then, perform a loop in which each iteration updates each variable using the target arithmetic operation on values from other variables<ul>
<li>This is to create structural dependency</li>
</ul>
</li>
<li>We <strong>unroll the loop by a factor of 64</strong> and <strong>arrange the variable assignment order</strong> to achieve high throughput using the approach found in the Scalable HeterOgeneous Computing (SHOC) OpenCL MaxFlops.cpp benchmark (Danalis et al. 2010).<ul>
<li>the 32 variable updates are ordered so that <strong>no assignment depends on the most recent four statements</strong><ul>
<li>32 is used because it permits maximum SIMD lane utilization &amp; prevent from spilling too many registers</li>
</ul>
</li>
<li>we <strong>sum</strong> the 32 variable values and <strong>store the result in a global array</strong> according to a <strong>user-specified memory access pattern</strong><ul>
<li>(NOTE: The actual cost can be deduced by change the runcount of arithmetic ops)</li>
<li>include the global store to avoid being optimized away</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Local memory access<ul>
<li>Tags: data type, global memory array size, iteration count, and workgroup dimensions<ul>
<li>Data type determines the local data stride</li>
</ul>
</li>
</ul>
<ol>
<li>each workitem <strong>initializes one element of a local array</strong> to the data type specified</li>
<li>Then we have it perform a loop, at each iteration moving a different element from one location in the array to another. <ul>
<li>We avoid write-races and simultaneous reads from a single memory location, and use an lid(0) stride of 1, avoiding bank conflicts.</li>
</ul>
</li>
<li>After the loop completes, <strong>each work-item writes one value from the shared array to global memory</strong></li>
</ol>
</li>
<li>Other features<ul>
<li>executes a variable number of local barriers, to measure operation overlapping behaviour (<strong>Section 7.4</strong>)</li>
<li>Empty kernel launch, to measure kernel launching overhead</li>
</ul>
</li>
</ul>
<p>文章提出，<em>Using a sufficiently high-fidelity model, we expect that users will be able to differentiate between latency-based costs of a single kernel launch and throughput-related costs that would be incurred in pipelined launches.</em></p>
<blockquote>
<p>怎么做？</p>
</blockquote>
<h3 id="计算模型参数"><a href="#计算模型参数" class="headerlink" title="计算模型参数"></a>计算模型参数</h3><p>采用最小二乘法来进行拟合，得到 feature 向量中给定 feature 的出现次数和总的运行时间的关系。</p>
<h3 id="Operation-Overlap-建模"><a href="#Operation-Overlap-建模" class="headerlink" title="Operation Overlap 建模"></a>Operation Overlap 建模</h3><p>Global memory 和 On-chip 的延迟之间是有可能互相隐藏的。</p>
<p>本文的建模基于简单的想法，即 $ \max (c_{onchip}, c_{gmem}) $，两类操作的时间求 $ \max $ 操作。</p>
<p>不过 $ \max $ 不是很可导，所以采用一个可微的近似函数来做，详情可以看论文。</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/learning-from-program-traces" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/learning-from-program-traces/"><strong>论文阅读 | Learning from Shader Program Traces</strong></a>
      <small class=article-date-index>&nbsp; 2023-01-03</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/learning-from-program-traces/" class="article-date">
  <time datetime="2023-01-02T16:00:00.000Z" itemprop="datePublished">2023-01-03</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Program trace<ul>
<li>In software engineering, a trace refers to the record of all states that a program visits during its execution, including all instructions and data.</li>
<li>本文提到的 Shader program trace，只包括中间结果 (<strong>data</strong>)，而不包括程序序列 (<strong>instruction</strong>)。</li>
</ul>
</li>
</ul>
<p>Since the fragment shader program operates independently per pixel, we can consider the full program trace as a vector of values computed at each pixel – a generalization from simple RGB.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>输入是用（嵌入到 Python 的） DSL 写的 fragment procedural shader program，翻译成 Tensorflow 程序<ul>
<li>可以同时输出渲染好的图片和生成的 program trace</li>
<li>分支展开、循环 unroll</li>
<li>These policies permit us to express the trace of any shader as a fixed-length vector of the computed scalar values, regardless of the pixel location</li>
</ul>
</li>
</ul>
<h3 id="输入特征化简"><a href="#输入特征化简" class="headerlink" title="输入特征化简"></a>输入特征化简</h3><ul>
<li>编译器优化<ul>
<li>忽略常量值、计算图上重复的节点，因为其在不同 pixel 位置的运行结果应该高度统一</li>
</ul>
</li>
<li>不生成内建函数的 trace</li>
<li>检测并筛除迭代改进模式的循环中的中间 trace 结果<ul>
<li>比如，raymarching 找 closest intersection 的迭代</li>
</ul>
</li>
<li>均匀的特征下采样<ul>
<li>The most straightforward strategy is to subsample the vector by some factor n, retaining only every nth trace feature as ordered in a depth first traversal of the compute graph</li>
</ul>
</li>
<li>其它采样方案 (都不太好用)<ul>
<li>clustering</li>
<li>loop subsampling</li>
<li>first or last</li>
<li>mean and variance</li>
</ul>
</li>
</ul>
<p>We <strong>first apply compiler optimizations</strong>, then <strong>subsample the features with a subsampling rate that makes the trace length be most similar to a fixed target length</strong>.</p>
<p>For all experiments, we target a length of 200, except where specifically noted such as in the simulation example. </p>
<p>After compiling and executing the shader, we have <strong>for every pixel: a vector of dimension N</strong>: the number of recorded intermediate values in the trace</p>
<h3 id="特征白化"><a href="#特征白化" class="headerlink" title="特征白化"></a>特征白化</h3><p>主要是为了解决 shader trace 里面的异常值，防止干扰训练和推理。用的是 Scaling + clamping。</p>
<ul>
<li>Check if the distribution merits clamping<ul>
<li>If N &lt;&#x3D; 10, no need to clamp</li>
<li>Else, do clamp<ul>
<li>Discard NaN, Inf, -Inf</li>
<li>let $P_0$ &#x3D; Lowest p’th percentile, $P_1$ &#x3D; highest p’th percentile, superparam $ \gamma $</li>
<li>Clamp to $ [P_0 − \gamma(P_1− P_0), P_1 + \gamma(P_1 − P_0)] $</li>
</ul>
</li>
<li>Do rescale<ul>
<li>for each intermediate feature, rescale the clamped values to the fixed range $ [-1,1] $</li>
<li>Record the bias and scale used (in rescaling)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The scale and bias is recorded and used in both training and testing, but the values will be clamped to range<br>[-2, 2] to allow data extrapolation.</p>
<blockquote>
<p>感觉有点乱…</p>
</blockquote>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>1x1 Conv + Feature Reduction (N &#x3D; 200 -&gt; K &#x3D; 48) </li>
<li>1x1 Conv * 3</li>
<li>Dilated Convolution (1, 2, 4, 8, 1)</li>
<li>1x1 Conv * 3 </li>
<li>1x1 Conv + Feature Reduction (K &#x3D; 48 -&gt; 3, that is, RGB color output)</li>
</ul>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>$ L_b = L_c + \alpha L_p $</p>
<ul>
<li>$ L_c $ 是 RGB 图像上的标准 $ L_2 $ loss</li>
<li>$ L_p $ 是 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1801.03924">The Unreasonable Effectiveness of Deep Features as a Perceptual Metric</a> 这篇文章中给出的损失函数度量 LPIPS<ul>
<li>大概就是，做了一个图像相似数据集，弄了很多 distortions 和 CNN 常见任务输出的图片，做 2AFC 和 JND，随后学习这个 metric</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/162070277">深度特征度量图像相似度的有效性——LPIPS</a> 这篇知乎文章比较不错</li>
</ul>
</li>
</ul>
<p>下面还有个 Appendix D，里面有实验的 GAN 的 loss</p>
<h4 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h4><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>和一个 Baseline 方法 RGBx 对比，这个 Baseline 用的手挑特征 normal, depth, diffuse, specular color (<em>where applicable</em>) 来作为输入进行学习。</p>
<h3 id="Denoising-fragment-shaders"><a href="#Denoising-fragment-shaders" class="headerlink" title="Denoising fragment shaders"></a>Denoising fragment shaders</h3><p>目标是用 1spp 图像来学习 1000spp 的 reference image。</p>
<h3 id="Reconstructing-simplified-shaders"><a href="#Reconstructing-simplified-shaders" class="headerlink" title="Reconstructing simplified shaders"></a>Reconstructing simplified shaders</h3><p>这个任务是，从简化后的 Shader 的运行结果中，重建原来 Shader 的运行结果。</p>
<p>简化 Shader 采用的是 Loop perforation 和 Genetic Programming Simplification。</p>
<p>用两个 Conditional GAN，分别称为 Spatial GAN 和 Temporal GAN，一个用来从 1spp 的图 $ c_x $ 生成 Ground Truth (原来的 Shader 运行结果) $ c_y $，另一个用来从前面三帧的 1spp 输出 + 前面两帧的 Spatial GAN 的生成器的输出来生成下一帧，也就是用序列 $ \tilde {c_x} $ 生成序列 $ \tilde {c_y} $。</p>
<blockquote>
<p>GAN related:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/301309418">四天搞懂生成对抗网络（一）——通俗理解经典GAN</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/302720602">四天搞懂生成对抗网络（二）——风格迁移的“精神始祖”Conditional GAN</a></li>
</ul>
</blockquote>
<h3 id="Postprocessing-filters"><a href="#Postprocessing-filters" class="headerlink" title="Postprocessing filters"></a>Postprocessing filters</h3><p>学习一些后处理效果的 Shader，如 edge-aware sharpening filter 和 defocus blur 效果。</p>
<h3 id="Learning-to-approximate-simulation"><a href="#Learning-to-approximate-simulation" class="headerlink" title="Learning to approximate simulation"></a>Learning to approximate simulation</h3><p>学习一些进行模拟的 Shader 将来的运行结果。</p>
<h2 id="Trace-有效性分析"><a href="#Trace-有效性分析" class="headerlink" title="Trace 有效性分析"></a>Trace 有效性分析</h2><p>这里主要做了两件事：</p>
<ol>
<li>哪些 Input feature 比较重要？<ul>
<li>这里作者采用求 Loss 关于 input trace feature 的一阶导数来评价重要性</li>
</ul>
</li>
<li>挑一个 Subset 来做训练？<ul>
<li>给定 m 个 feature 的训练 budget，如果要评价任意的 subset，即从 N 个里面抽 m 个来做训练的话，开销太大<ul>
<li>Oracle: 按 1 中所述重要性评分的前 m 个 input trace feature</li>
<li>Opponent: 按 1 中所述重要性评分的后 m 个 input trace feature</li>
<li>Uniform: 随便挑 m 个</li>
</ul>
</li>
<li>发现 Oracle &gt; Opponent &gt; Uniform</li>
</ul>
</li>
<li>多个 Shader 一起学习<ul>
<li>多个 Shader 一起学习降噪任务，感觉就像训练一个真·denoiser</li>
</ul>
</li>
</ol>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="post-example-vulkan-app-flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/example-vulkan-app-flow/"><strong>一个示例 Vulkan 程序的全流程记录</strong></a>
      <small class=article-date-index>&nbsp; 2022-12-29</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/example-vulkan-app-flow/" class="article-date">
  <time datetime="2022-12-28T16:00:00.000Z" itemprop="datePublished">2022-12-29</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>一些有用的链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.khronos.org/blog/understanding-vulkan-synchronization">Khronos Blog - Understanding Vulkan Synchronization</a></li>
<li><a target="_blank" rel="noopener" href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/">Yet another blog explaining Vulkan synchronization - Maister’s Graphics Adventures</a></li>
</ul>
</blockquote>
<p>本文主要分析 <a target="_blank" rel="noopener" href="https://github.com/glfw/glfw">glfw</a> 库的 <a target="_blank" rel="noopener" href="https://github.com/glfw/glfw/blob/57cbded0760a50b9039ee0cb3f3c14f60145567c/tests/triangle-vulkan.c">tests&#x2F;triangle-vulkan.c</a> 文件。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><blockquote>
<p>Update 2023-02-13: 补上了漏掉的创建逻辑设备的一步 vkCreateDevice</p>
</blockquote>
<ul>
<li>demo_init<ul>
<li>demo_init_connection<ul>
<li>glfwSerErrorCallback</li>
<li>gladLoadVulkanUserPtr: 设定 glad 使用 glfwGetInstanceProcAddress 来装载所有的 Vulkan 函数指针地址</li>
</ul>
</li>
<li>demo_init_vk<ul>
<li>启用验证层:<ul>
<li>vkEnumerateInstanceLayerProperties</li>
<li>demo_check_layers: 检查需要的验证层集合是否存在</li>
</ul>
</li>
<li>glfwGetRequiredInstanceExtensions: 获得需要的平台 Surface 扩展</li>
<li>准备启用的 Instance 扩展列表<ul>
<li>VK_EXT_debug_report</li>
<li>VK_KHR_portability_enumeration</li>
</ul>
</li>
<li>vkCreateInstance</li>
<li>vkEnumeratePhysicalDevices</li>
<li>检查设备是否支持 VK_KHR_swapchain<ul>
<li>vkEnumerateDeviceExtensionProperties</li>
</ul>
</li>
<li>vkCreateDebugReportCallbackEXT</li>
<li>vkGetPhysicalDeviceProperties</li>
<li>vkGetPhysicalDeviceQueueFamilyProperties</li>
<li>vkGetPhysicalDeviceFeatures</li>
</ul>
</li>
</ul>
</li>
<li>demo_create_window<ul>
<li>glfwWindowHint</li>
<li>glfwCreateWindow</li>
<li>glfwSetWindowUserPointer</li>
<li>glfwSetWindowRefreshCallback</li>
<li>glfwSetFramebufferSizeCallback</li>
<li>glfwSetKeyCallback</li>
</ul>
</li>
<li>demo_init_vk_swapchain<ul>
<li>glfwCreateWindowSurface<ul>
<li>内部调用 vkCreateWin32SurfaceKHR</li>
</ul>
</li>
<li>查找支持 Present 和 Graphics 的 Queue，需要是同一个 Queue<ul>
<li>vkGetPhysicalDeviceSurfaceSupportKHR</li>
<li><code>queueFlags &amp; VK_QUEUE_GRAPHICS_BIT</code></li>
</ul>
</li>
<li>demo_init_device<ul>
<li>vkCreateDevice: 创建 logical device<ul>
<li>VkDeviceCreateInfo<ul>
<li><code>.pQueueCreateInfos</code><ul>
<li><code>.queueFamilyIndex</code></li>
<li><code>.queueCount</code></li>
<li><code>.pQueuePriorities</code></li>
</ul>
</li>
<li><code>.ppEnabledLayerNames</code></li>
<li><code>.ppEnabledExtensionNames</code>: 要启用的设备扩展<blockquote>
<p>似乎把 Instance 扩展的名字扔进去也行？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkGetDeviceQueue</li>
<li>选择一个最优的 Surface format<ul>
<li>vkGetPhysicalDeviceSurfaceFormatsKHR</li>
</ul>
</li>
<li>vkGetPhysicalDeviceMemoryProperties</li>
</ul>
</li>
<li>demo_prepare<ul>
<li>创建 Command Pool<ul>
<li>vkCreateCommandPool</li>
</ul>
</li>
<li>分配一个 Command Buffer<ul>
<li>vkAllocateCommandBuffers<ul>
<li>VkCommandBufferAllocateInfo:<ul>
<li><code>.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY</code></li>
<li><code>.commandBufferCount = 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_buffers<ul>
<li>检查 Surface Capabilities 和 Present Modes<ul>
<li>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</li>
<li>vkGetPhysicalDeviceSurfacePresentModesKHR</li>
</ul>
</li>
<li>创建交换链<ul>
<li>计算 Swapchain Image Extent</li>
<li><code>.preTransform</code> 使用 <code>VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code>，如果没有则使用当前 Surface Transform</li>
<li><code>.minImageCount</code> 使用 Surface Capabilities 的 minImageCount</li>
<li><code>.presentMode</code> 选择 <code>VK_PRESENT_MODE_FIFO_KHR</code></li>
<li>vkCreateSwapchainKHR</li>
<li>如果有老的交换链： vkDestroySwapchainKHR</li>
<li>vkGetSwapchainImagesKHR 拿到 VkImage 格式的交换链图像</li>
<li>为每个交换链图像调用 vkCreateImageView 创建 Color Attachment View<blockquote>
<p>Componet Swizzle: TODO check spec</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_depth<ul>
<li>vkCreateImage 创建 depth image<ul>
<li><code>.arrayLayers</code> 可以指定 texture array 的 dimension</li>
</ul>
</li>
<li>vkGetImageMemoryRequirements 获得 image 的内存要求</li>
<li>选择内存大小和内存类型<ul>
<li>memory_type_from_properties : todo check this</li>
</ul>
</li>
<li>vkAllocateMemory 分配 image 所需内存，返回 VkDeviceMemory</li>
<li>vkBindImageMemory 将分配的 VkDeviceMemory 绑定到 VkImage</li>
<li>demo_set_image_layout<ul>
<li>如果 <code>demo-&gt;setup_cmd</code> 为空，则<ul>
<li>调用 vkAllocateCommandBuffers 从 <code>demo-&gt;cmd_pool</code> 中分配 <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> 的 Buffer</li>
<li>vkBeginCommandBuffer</li>
</ul>
</li>
<li>准备 Image Memory Barrier<ul>
<li>VkImageMemoryBarrier<ul>
<li><code>.srcAccessMask = 0</code><ul>
<li>不需要给 src stage 的任何读&#x2F;写操作 made coherent</li>
</ul>
</li>
<li><code>.dstAccessMask</code>:<ul>
<li>对于 <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>，设置为 <code>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</code></li>
</ul>
</li>
<li><code>.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED</code>，也就是垃圾数据</li>
<li><code>.newLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
</ul>
</li>
</ul>
</li>
<li>录制 Pipeline Barrier<ul>
<li>vkCmdPipelineBarrier<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是 wait for nothing</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>，也就是任何下面的指令在开始前都需要等待 Barrier 执行完</li>
<li>同时传入前面的 Image Mmeory Barrier</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkCreateImageView 创建深度缓冲对应图像的 ImageView</li>
</ul>
</li>
<li>demo_prepare_textures<ul>
<li>vkGetPhysicalDeviceFormatProperties 获得 <code>VK_FORMAT_B8G8R8A8_UNORM</code> 的 VkFormatProperties</li>
<li>对于每张 texture<blockquote>
<p>用 <code>texture_object</code> 来管理每个 texture</p>
<ul>
<li>VkSampler sampler</li>
<li>VkImage iamge;</li>
<li>VkImageLayout imageLayout;</li>
<li>VkDeviceMemory mem;</li>
<li>VkImageView view;</li>
<li>int32_t tex_width, tex_height;</li>
</ul>
</blockquote>
<ul>
<li>如果 sampler 支持（对此种 format 的）线性分块 <code>(props.linearTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul>
<li>demo_prepare_texture_image with required_props &#x3D; <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code><ul>
<li>vkCreateImage</li>
<li>vkGetImageMemoryRequirements</li>
<li>memory_type_from_properties<ul>
<li>对设备支持的每种内存类型，枚举其是否符合前面 <code>required_props</code> 的要求</li>
</ul>
</li>
<li>vkAllocateMemory</li>
<li>vkBindImageMemory</li>
<li>如果 memory type 有性质 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code><ul>
<li>vkGetImageSubresourceLayout</li>
<li>vkMapMemory: 映射到地址空间</li>
<li>填充之</li>
<li>vkUnmapMemory</li>
</ul>
</li>
<li>设置 image layout (前面分析过)<ul>
<li><code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> -&gt; <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code></li>
<li>demo_set_image_layout</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果 sampler 不支持对此种 format 的线性分块，但支持 optimal 分块 <code>(props.optimalTilingFeatures &amp;  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT)</code><ul>
<li>分别准备 host coherent 和 host visible 的 staging texture 和 GPU device local 的 texture<ul>
<li>demo_prepare_texture_image * 2<ul>
<li>这里 device local 的显然没能力初始化</li>
</ul>
</li>
<li>注意 memory props</li>
</ul>
</li>
<li>改 layout 以便使用 transfer 命令<ul>
<li>staging texture: VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</li>
<li>device local texture: VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</li>
</ul>
</li>
<li>vkCmdCopyImage</li>
<li>将 device local texture 的 layout 改回来<ul>
<li>demo_set_image_layout</li>
</ul>
</li>
<li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul>
<li>vkEndCommandBuffer</li>
<li>vkQueueSubmit<ul>
<li>no wait &#x2F; signal semaphores</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkFreeCommandBuffers</li>
<li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li>
</ul>
</li>
<li>demo_destroy_texture_image 销毁 staging texture</li>
</ul>
</li>
<li>创建对应的 sampler 和 Image View<ul>
<li>vkCreateSampler</li>
<li>vkCreateImageView</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_vertices<blockquote>
<p>这里直接用了 Host visible &amp; Host coherent 的 memory 作为 vertex buffer<br>而不是 Device local 的，然后单开 staging buffer 做拷贝.</p>
<p>应该是偷懒了.jpg</p>
</blockquote>
<ul>
<li>vkCreateBuffer<ul>
<li>with <code>.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code></li>
</ul>
</li>
<li>vkGetBufferMemoryRequirements</li>
<li>memory_type_from_properties</li>
<li>vkAllocateMemory</li>
<li>vkMapMemory</li>
<li>vkUnmapMemory</li>
<li>vkBindBufferMemory</li>
<li>配置一些结构体<ul>
<li>VkPipelineVertexInputStateCreateInfo<ul>
<li>VkVertexInputBindingDescription</li>
<li>VkVertexInputAttributeDescription</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_layout<ul>
<li>vkCreateDescriptorSetLayout<ul>
<li>VkDescriptorSetLayoutCreateInfo</li>
<li><code>.pBindings = &amp;layout_binding</code><ul>
<li>layout_binding: 设置每个 binding 的位置都放什么 - 可以为数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const VkDescriptorSetLayoutBinding layout_binding = &#123;</span><br><span class="line">  .binding = 0,</span><br><span class="line">  .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,</span><br><span class="line">  .descriptorCount = DEMO_TEXTURE_COUNT,</span><br><span class="line">  .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,</span><br><span class="line">  .pImmutableSamplers = NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
See also: <a target="_blank" rel="noopener" href="https://vkguide.dev/docs/chapter-4/descriptors/">https://vkguide.dev/docs/chapter-4/descriptors/</a></li>
</ul>
</li>
</ul>
</li>
<li>vkCreatePipelineLayout<ul>
<li>VkPipelineLayoutCreateInfo: <code>demo-&gt;pipeline_layout</code><ul>
<li>指定了到 Descriptor Set Layouts 的数量和数组指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_render_pass<ul>
<li>vkCreateRenderPass<ul>
<li>VkRenderPassCreateInfo<ul>
<li><code>.pAttachments</code>: VkAttachmentDescription<ul>
<li><code>[0]</code>: Color Attachment<ul>
<li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code> 图像的 sample 数</li>
<li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code> color &amp; depth 内容在 subpass 开始时如何处理</li>
<li><code>.storeOp = VK_ATTACHMENT_STORE_OP_STORE</code> color &amp; depth 内容在 subpass 结束后如何处理</li>
<li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code> stencil 内容在 subpass 开始时如何处理</li>
<li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code> stencil 内容在 subpass 结束时如何处理</li>
<li><code>.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 开始前 image subresource 的 layout</li>
<li><code>.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> subpass 结束后 image subresource 将会被自动转换到的 layout</li>
</ul>
</li>
<li><code>[1]</code>: Depth Stencil Attachment<ul>
<li><code>.format = demo-&gt;depth.format</code></li>
<li><code>.samples = VK_SAMPLE_COUNT_1_BIT</code></li>
<li><code>.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR</code></li>
<li><code>.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li>
<li><code>.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE</code></li>
<li><code>.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE</code></li>
<li><code>.initialLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
<li><code>.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pSubpasses</code>: VkSubpassDescription<blockquote>
<p>A single render pass can consist of multiple subpasses. Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. <a target="_blank" rel="noopener" href="https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes">Render passes - Vulkan Tutorial</a></p>
</blockquote>
<ul>
<li><code>.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code> 该 subpass 支持的 pipeline 类型</li>
<li><code>.pInputAttachments = NULL</code></li>
<li><code>.pColorAttachments = &amp;color_reference</code><ul>
<li><code>VkAttachmentReference &#123;.attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[0]</code></li>
</ul>
</li>
<li><code>.pDepthStencilAttachment = &amp;depth_reference</code><ul>
<li><code>VkAttachmentReference &#123;.attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&#125;</code><br>引用到上面的 <code>[1]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pDependencies</code>: VkSubpassDependency 有多个 subpass 时指定 subpass 间的读写依赖关系<blockquote>
<p>和 vkCmdPipelineBarrier + VkMemoryBarrier 差不多，区别只是同步作用域限于指定的 subpass 间，而非所有在前在后的操作 (<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap8.html#VkSubpassDependency">Vulkan Spec</a>)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_pipeline<ul>
<li>vkCreatePipelineCache: (<em>optional</em> for pipeline creation)<blockquote>
<p>主要用来供实现缓存编译好的 Pipeline; 可以使用 allocator 限制其缓存数据的大小; 可以创建时导入之前 (应用程序) 的 Cache 等</p>
</blockquote>
</li>
<li>vkCreateGraphicsPipelines<ul>
<li>VkGraphicsPipelineCreateInfo<ul>
<li><code>.layout = demo-&gt;pipeline_layout</code></li>
<li><code>.pVertexInputState</code>: VkPipelineVertexInputStateCreateInfo<ul>
<li>已经在 <code>demo_prepare_vertices</code> 中准备好</li>
</ul>
</li>
<li><code>.pInputAssemblyState</code>: VkPipelineInputAssemblyStateCreateInfo<ul>
<li><code>.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code></li>
</ul>
</li>
<li><code>.pRasterizationState</code>: VkPipelineRasterizationStateCreateInfo<ul>
<li><code>.polygonMode = VK_POLYGON_MODE_FILL</code></li>
<li><code>.cullMode = VK_CULL_MODE_BACK_BIT</code></li>
<li><code>.frontFace = VK_FRONT_FACE_CLOCKWISE</code><ul>
<li>front-facing triangle orientation to be used for culling</li>
</ul>
</li>
<li><code>.depthClampEnable = VK_FALSE</code><ul>
<li>不启用深度截断</li>
</ul>
</li>
<li><code>.rasterizerDiscardEnable = VK_FALSE</code><ul>
<li>是否在光栅化阶段前立即丢弃片元</li>
</ul>
</li>
<li><code>.depthBiasEnable = VK_FALSE</code></li>
<li><code>.lineWidth = 1.0f</code><ul>
<li>光栅化线段宽度</li>
</ul>
</li>
</ul>
</li>
<li><code>.pColorBlendState</code>: VkPipelineColorBlendStateCreateInfo<ul>
<li><code>.pAttachments</code>: VkPipelineColorBlendAttachmentState，对每个 color attachment 定义 blend state<ul>
<li><code>[0]</code><ul>
<li><code>.colorWriteMask = 0xf</code><ul>
<li>写入 RGBA 全部四个通道 (<a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap29.html#framebuffer-color-write-mask">Vulkan Spec</a>)</li>
</ul>
</li>
<li><code>.blendEnable = VK_FALSE</code><ul>
<li>不启用 Blending，直接写入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>.pMultisampleState</code>: VkPipelineMultisampleStateCreateInfo<ul>
<li><code>.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT</code></li>
<li><code>.pSampleMask = NULL</code></li>
</ul>
</li>
<li><code>.pViewportState</code>: VkPipelineViewportStateCreateInfo<ul>
<li><code>.viewportCount = 1</code></li>
<li><code>.scissorCount = 1</code></li>
<li>不过这里用的 <strong>Dynamic State</strong>，也就是 Viewport 和 Scissor 的信息是在录制 Command Buffer 时提供的，创建 Pipeline 时不提供<ul>
<li>详情看 <code>.pDynamicState</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.pDepthStencilState</code>: VkPipelineDepthStencilStateCreateInfo<ul>
<li><code>.depthTestEnable = VK_TRUE</code></li>
<li><code>.depthWriteEnable = VK_TRUE</code></li>
<li><code>.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL</code></li>
<li><code>.depthBoundsTestEnable = VK_FALSE</code><ul>
<li>Samples coverage &#x3D; 0 if outside the bound predetermined</li>
<li><a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap28.html#fragops-dbt">28.8. Depth Bounds Test</a></li>
</ul>
</li>
<li><code>.stencilTestEnable = VK_FALSE</code> 下面都是 Stencil test 的参数</li>
<li><code>.back.failOp = VK_STENCIL_OP_KEEP</code></li>
<li><code>.back.passOp = VK_STENCIL_OP_KEEP</code></li>
<li><code>.back.compareOp = VK_COMPARE_OP_ALWAYS</code></li>
<li><code>.front = ds.back</code></li>
</ul>
</li>
<li><code>.pStages</code>: VkPipelineShaderStageCreateInfo<ul>
<li><code>[0]</code><ul>
<li><code>.stage = VK_SHADER_STAGE_VERTEX_BIT</code></li>
<li><code>.pName = &quot;main&quot;</code></li>
<li><code>.module = demo_prepare_vs(demo)</code><ul>
<li>Call demo_prepare_shader_module with vert SPIR-V code<ul>
<li>vkCreateShaderModule with <code>size_t codeSize</code> &amp; <code>uint32_t *pCode</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>[1]</code><ul>
<li><code>.stage = VK_SHADER_STAGE_FRAGMENT_BIT</code></li>
<li><code>.pName = &quot;main&quot;</code></li>
<li><code>.module = demo_prepare_fs(demo)</code><ul>
<li>Similar with above</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>.pDynamicState</code>: VkPipelineDynamicStateCreateInfo<ul>
<li><code>.pDynamicStates = dynamicStateEnables</code><ul>
<li>启用了 <code>VK_DYNAMIC_STATE_VIEWPORT</code> 和 <code>VK_DYNAMIC_STATE_SCISSOR</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.renderPass</code>: VkRenderPass<br>传入之前创建的 VkRenderPass</li>
</ul>
</li>
</ul>
</li>
<li>vkDestroyPipelineCache</li>
<li>vkDestroyShaderModule * 2<ul>
<li>删除 vs 和 fs 的两个刚才创建的 Shader Module (<code>demo_prepare_vs</code> &#x2F; <code>demo_prepare_fs</code>)</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_pool<ul>
<li>vkCreateDescriptorPool<ul>
<li>VkDescriptorPoolCreateInfo<ul>
<li><code>.pPoolSizes = &amp;type_count</code><ul>
<li>VkDescriptorPoolSize<ul>
<li><code>.type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li>
<li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_descriptor_set<ul>
<li>vkAllocateDescriptorSets：按 Descriptor Set Layouts 从 Descriptor Pool 中分配 Descriptor Sets<ul>
<li><code>.pSetLayouts = &amp;demo-&gt;desc_layout</code></li>
<li><code>.descriptorPool = demo-&gt;desc_pool</code></li>
</ul>
</li>
<li>vkUpdateDescriptorSets<br>支持 Write 和 Copy 两种形式的 Descriptor Set 更新请求<ul>
<li>VkWriteSescriptorSet<ul>
<li><code>.dstSet = demo-&gt;desc_set</code> 刚分配的 Descriptor Set</li>
<li><code>.descriptorCount = DEMO_TEXTURE_COUNT</code></li>
<li><code>.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</code></li>
<li><code>.pImageInfo = tex_descs</code><ul>
<li>VkDescriptorImageInfo: 具体的 Descriptor 内容<ul>
<li><code>.sampler = demo-&gt;textures[i].sampler</code></li>
<li><code>.imageView = demo-&gt;textures[i].view</code></li>
<li><code>.imageLayout = VK_IMAGE_LAYOUT_GENERAL</code><blockquote>
<p>感觉这里应该是选对应的才对，不知道这样可以不可以</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_prepare_framebuffers<ul>
<li>创建 <code>demo-&gt;swapchainImageCount</code> 个 VkFramebuffer<ul>
<li>vkCreateFramebuffer<ul>
<li>VkFramebufferCreateInfo<ul>
<li><code>.renderPass = demo-&gt;renderpass</code></li>
<li><code>.pAttachments</code>: VkImageView[]<ul>
<li><code>[0]</code>: Color Attachment, <code>demo-&gt;buffers[i].view</code><ul>
<li>That is, the swapchain image view</li>
</ul>
</li>
<li><code>[1]</code>: Depth Attachment<ul>
<li><code>demo-&gt;depth.view</code></li>
</ul>
</li>
</ul>
</li>
<li><code>.width</code>, <code>.height</code></li>
<li><code>.layers = 1</code><blockquote>
<p>正如 VkImage 创建时也可以选择多 layer 一样，这里也可以；不过 Shader 默认写入第一层，除了 Geometry Shader</p>
<p>多 layer 的 Image &#x2F; Framebuffer 在 Shader 里面是用的 texture array 的语法来访问的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>demo_run<ul>
<li>glfwWindowShouldClose: 检测窗口的 closing 标志</li>
<li>glfwPollEvent</li>
<li>demo_draw<ul>
<li>vkCreateSemaphore: <code>imageAcquiredSemaphore</code></li>
<li>vkCreateSemaphore: <code>drawCompleteSemaphore</code></li>
<li>vkAcquireNextImageKHR<blockquote>
<p>这里有一个问题，这里返回并不意味着 Present 完成 (推荐做法是 Present 设置 Semaphore，然后等 Semaphore)</p>
<p>那么，什么情况下这里会 block？<br>也可以参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64150186/lets-get-swapchains-image-count-straight">Let’s get swapchain’s image count straight - StackOverflow</a></p>
</blockquote>
<ul>
<li><code>timeout = UINT64_MAX</code></li>
<li><code>semaphore = imageAcquiredSemaphore</code></li>
<li><code>pImageIndex = &amp;demo-&gt;current_buffer</code>: index of the next image to use<ul>
<li>完成后会 signal 该 semaphore</li>
</ul>
</li>
<li>返回值<ul>
<li>VK_ERROR_OUT_OF_DATE_KHR<ul>
<li>demo_resize: 处理 resize 情况：<strong>Destroy everything</strong><ul>
<li>vkDestroyFramebuffer</li>
<li>vkDestroyDescriptorPool</li>
<li>vkFreeCommandBuffers</li>
<li>vkDestroyCommandPool</li>
<li>vkDestroyPipeline</li>
<li>vkDestroyRenderPass</li>
<li>vkDestroyPipelineLayout</li>
<li>vkDestroyDescriptorSetLayout</li>
<li>vkDestroyBuffer (vertex buffer)</li>
<li>vkFreeMemory (vertex buffer memory)</li>
<li>vkDestroyImageView</li>
<li>vkDestroyImage</li>
<li>vkDestroySampler</li>
<li>…</li>
<li>call <code>demo_prepare</code></li>
</ul>
</li>
<li>demo_draw: 重复调用一下自己</li>
</ul>
</li>
<li>VK_SUBOPTIMAL_KHR: 不是最优，但是也能 present，所以不管</li>
</ul>
</li>
</ul>
</li>
<li>demo_flush_init_cmd: 同步方式 flush setup cmd<ul>
<li>vkEndCommandBuffer</li>
<li>vkQueueSubmit<ul>
<li>no wait &#x2F; signal semaphores</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkFreeCommandBuffers</li>
<li><code>demo-&gt;setup_cmd = VK_NULL_HANDLE</code></li>
</ul>
</li>
<li>demo_draw_build_cmd<ul>
<li>vkBeginCommandBuffer: <code>demo-&gt;draw_cmd</code></li>
<li>vkCmdPipelineBarrier<ul>
<li>Execution barrier 部分<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)<blockquote>
<p><code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> is equivalent to <code>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code> with VkAccessFlags set to 0 when specified in the first synchronization scope, but specifies no stage of execution when specified in the second scope.</p>
</blockquote>
</li>
</ul>
</li>
<li>Memory barrier 部分: 对 color attachment 做 layout transition<ul>
<li>从 <code>VK_IMAGE_LAYOUT_UNDEFINED</code> -&gt; <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li>
<li><code>.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBeginRenderPass with <code>VK_SUBPASS_CONTENTS_INLINE</code><blockquote>
<p><code>VK_SUBPASS_CONTENTS_INLINE</code> specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers must not be executed within the subpass.</p>
</blockquote>
<ul>
<li>VkRenderPassBeginInfo<ul>
<li><code>.renderPass</code></li>
<li><code>.framebuffer</code> - 选择<strong>当前</strong>的 framebuffer，我们有 <code>swapchainImageCount</code> 个</li>
<li><code>.renderArea</code><ul>
<li><code>.offset.&#123;x, y&#125;</code></li>
<li><code>.extent.&#123;width, height&#125;</code></li>
</ul>
</li>
<li><code>.pClearValues = clear_values</code> (VkClearValue)<blockquote>
<p>这里是和 RenderPassCreateInfo 指定的 attachments 相对应的</p>
<p><code>pClearValues</code> is a pointer to an array of <code>clearValueCount</code> VkClearValue structures containing clear values for each attachment, if the attachment uses a <code>loadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> or if the attachment has a depth&#x2F;stencil format and uses a <code>stencilLoadOp</code> value of <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.</p>
</blockquote>
<ul>
<li><code>[0] = &#123;.color.float32 = &#123;0.2f, 0.2f, 0.2f, 0.2f&#125;&#125;</code></li>
<li><code>[1] = &#123;.depthStencil = &#123;demo-&gt;depthStencil, 0&#125;&#125;</code><ul>
<li><code>demo-&gt;depthStencil</code> 用来加一个“无形的墙”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBindPipeline<ul>
<li><code>pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS</code></li>
</ul>
</li>
<li>vkCmdBindDescriptorSets<ul>
<li><code>layout = demo-&gt;pipeline_layout</code><br>Recall: Pipeline layout &lt;&#x3D; Descriptor Set Layouts</li>
<li>Descriptor Sets</li>
</ul>
</li>
<li>vkCmdSetViewport<ul>
<li>VkViewport<ul>
<li><code>.height</code>, <code>.width</code>, <code>.minDepth</code>, <code>.maxDepth</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdSetScissor<ul>
<li>VkRect2D<ul>
<li><code>.extent.&#123;width, height&#125;</code></li>
<li><code>.offset.&#123;x, y&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>vkCmdBindVertexBuffers<blockquote>
<p>看 <a target="_blank" rel="noopener" href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/instancing/instancing.cpp</a> 可能会印象更深刻</p>
</blockquote>
<ul>
<li>firstBinding 参数用于 (CPU 端) 指定绑定到哪里</li>
</ul>
</li>
<li>vkCmdDraw<ul>
<li><code>vertexCount = 3</code></li>
<li><code>instanceCount = 1</code></li>
<li><code>firstVertex = 0</code></li>
<li><code>firstInstance = 0</code></li>
</ul>
</li>
<li>vkCmdEndRenderPass</li>
<li>vkCmdPipelineBarrier<ul>
<li>Execution barrier:<ul>
<li><code>srcStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code>，也就是 wait for everything</li>
<li><code>dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> (Specifies no stage of execution)</li>
</ul>
</li>
<li>Memory barrier:<blockquote>
<p>正如 transfer，present 也需要 layout 改变</p>
</blockquote>
<ul>
<li><code>.srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code></li>
<li><code>.dstAccessMask = VK_ACCESS_MEMORY_READ_BIT</code></li>
<li><code>.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code></li>
<li><code>.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code></li>
</ul>
</li>
</ul>
</li>
<li>vkEndCommandBuffer: <code>demo-&gt;draw_cmd</code></li>
</ul>
</li>
<li>vkQueueSubmit<ul>
<li><code>.pCommandBuffers = &amp;demo-&gt;draw_cmd</code></li>
<li><code>.pWaitSemaphores = &amp;imageAcquiredSemaphore</code></li>
<li><code>.pWaitDstStageMask = &amp;pipe_stage_flags</code><ul>
<li><code>pWaitDstStageMask</code> is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.</li>
<li>这里设置成了 <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code></li>
<li>所以，相当于啥也没等</li>
</ul>
</li>
<li><code>.pSignalSemaphores = &amp;drawCompleteSemaphore</code></li>
</ul>
</li>
<li>vkQueuePresentKHR<ul>
<li>VkPresentInfoKHR<ul>
<li><code>.pWaitSemaphores = &amp;drawCompleteSemaphore</code></li>
<li><code>.pSwapchains = &amp;demo-&gt;swapchain</code><ul>
<li>可以多个，用来支持多个 swapchain 用一个 queue present 操作进行 present</li>
</ul>
</li>
<li><code>.pImageIndices = &amp;demo-&gt;current_buffer</code></li>
</ul>
</li>
<li>返回值<ul>
<li>VK_ERROR_OUT_OF_DATE_KHR<ul>
<li>demo_resize</li>
</ul>
</li>
<li>VK_SUBOPTIMAL_KHR<ul>
<li>啥事不干</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>vkQueueWaitIdle</li>
<li>vkDestroySemaphore: <code>imageAcquiredSemaphore</code></li>
<li>vkDestroySemaphore: <code>drawCompleteSemaphore</code></li>
</ul>
</li>
<li>demo-&gt;depthStencil 周期改变</li>
<li>vkDeviceWaitIdle</li>
<li>如果到了指定的帧数，则 glfwSetWindowShouldClose</li>
</ul>
</li>
<li>demo_cleanup<ul>
<li>删除一万个东西 (literally)</li>
<li>glfwDestroyWindow</li>
<li>glfwTerminate</li>
</ul>
</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/data-driven-prt" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/data-driven-prt/"><strong>论文阅读 | 数据驱动的 PRT</strong></a>
      <small class=article-date-index>&nbsp; 2022-12-18</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/data-driven-prt/" class="article-date">
  <time datetime="2022-12-17T16:00:00.000Z" itemprop="datePublished">2022-12-18</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文省略了一大堆细节，详情参见论文。</p>
<p>TODO: 整理清楚各个维数，因为原论文也不甚详细；</p>
<p>更新后的版本会放到 <a href="https://blog.libreliu.info/paper-reading/data-driven-prt/">这里</a>，如果有。</p>
</blockquote>
<h2 id="Recap-Precomputed-Radiance-Transfer"><a href="#Recap-Precomputed-Radiance-Transfer" class="headerlink" title="Recap: Precomputed Radiance Transfer"></a>Recap: Precomputed Radiance Transfer</h2><blockquote>
<p>本节主要参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">GAMES 202 - 高质量实时渲染</a>课程的 Lecture 6 和 Lecture 7</p>
</blockquote>
<p>考虑渲染方程</p>
$$
L({\bf o}) = \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}
$$

<p>其中</p>
<ul>
<li>$ {\bf i}, {\bf o} $ 为入射和出射方向</li>
<li>$ L({\bf i}), L({\bf o}) $ 为入射和出射 radiance<ul>
<li>此处<strong>省略了</strong>作为参数的 shading point 位置 $ \bf x $，下同</li>
</ul>
</li>
<li>$ \rho $ 为 BRDF 函数</li>
<li>$ V $ 为 Visibility 项</li>
</ul>
<p>将 $ L({\bf i}) $ 项用级数的有限项进行近似，即</p>
$$
L({\bf i}) \approx \sum_{i=1}^{n} l_i B_i({\bf i})
$$

<blockquote>
<p>其中 $ B_i: S^2 \to \mathbb{R} $ 为基函数</p>
</blockquote>
<p>带入得到</p>
$$
\begin{aligned}
L({\bf o}) &= \int_{\mathcal{H}^2} L({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\
&\approx \sum_i l_i \int_{\mathcal{H}^2} B_i({\bf i}) \rho({\bf i}, {\bf o}) V({\bf i}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i} \\
&= \sum_i l_i T_i({\bf o})
\end{aligned}
$$

<p>这里把上面的积分 (“Light transport term”) 记作 $ T_i $.</p>
<p>这里继续进行展开</p>
$$
T_i({\bf o}) \approx \sum_{j=1}^{m} t_{ij} B_j({\bf o})
$$

<p>所以我们得到</p>
$$
\begin{aligned}
L({\bf o}) &\approx \sum_i l_i T_i({\bf o}) \\
&\approx \sum_i l_i \left( \sum_j t_{ij} B_j({\bf o}) \right) \\
&\approx \sum_j \left( \sum_i l_i t_{ij} \right) B_j({\bf o}) \\
\end{aligned}
$$

<p>也就是说</p>
$$
L({\bf o}) 
\approx 
\begin{bmatrix}
l_1 & ... & l_n
\end{bmatrix}
\begin{bmatrix}
t_{11} & ... & t_{1m} \\
\vdots & & \vdots \\
t_{n1} & ... & t_{nm}
\end{bmatrix}
\begin{bmatrix}
B_1({\bf o}) \\ \vdots \\ B_m({\bf o})
\end{bmatrix}
$$

<p>那么，PRT 的框架就大致如下</p>
<ol>
<li><p>预计算</p>
<ul>
<li>对每个可能的 shading point $ {\bf x} $<ul>
<li>计算该物体的环境光在基函数下对应的系数 $ l_i $</li>
<li>计算该物体光传输展开系数 $ t_{ij} $</li>
</ul>
</li>
</ul>
<blockquote>
<p>当然，对于 Image based lighting，一般认为 $ L({\bf i}, {\bf x}) \approx L({\bf i}) $，那某些东西就不需要 per-shading point 存储</p>
</blockquote>
</li>
<li><p>运行时</p>
<ul>
<li>根据视角 $ {\bf o} $ 和位置 $ {\bf x} $ 来读取对应的向量并计算</li>
</ul>
</li>
</ol>
<blockquote>
<p>对于 Diffuse 物体，$ \rho({\bf i}, {\bf o}) $ 是常数，所以不需要继续展开 $ T_i $ 项</p>
</blockquote>
<blockquote>
<p>Remarks from paper: PRT methods bake the transport matrix using implicit light sources defined by the illumination basis.<br>Those light sources shade the asset with positive and negative radiance values. Hence, a dedicated light transport algorithm is used for them.</p>
</blockquote>
<h2 id="本文思路"><a href="#本文思路" class="headerlink" title="本文思路"></a>本文思路</h2><p>本文的框架只考虑<strong>漫反射</strong>，虽然结果上对于不是特别 Glossy 的材质应该都可以应用。</p>
<p>框架上的思路就是</p>
<ul>
<li>间接光 $ L_i({\bf x}; t) $ 和直接光 $ L_d({\bf i}, {\bf x}; t) $ 之间存在线性关系</li>
<li>框架：<ul>
<li>将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ I &#x3D; MD $<ul>
<li>相当于挑了一组基，每个基内部由同一个光照条件下各个位置的 $ L_d $ 组成</li>
</ul>
</li>
<li>对于给定的光照条件 $ x $ （各个位置 $ L_d $的值构成的列向量） ，如何求解 $ L_i $ ？<ul>
<li>首先把 $ x $ 分解到该 $ D $ 基下，得到系数向量 $ c &#x3D; (D^T D)^{-1} D^T x $</li>
<li>每个 $ D $ 基我们都存储有对应的输出，所以结果 $ y &#x3D; Mx &#x3D; I(D^T D)^{-1} D^T x $</li>
</ul>
</li>
</ul>
</li>
<li>近似：<ul>
<li>对 $ I $ 进行 SVD 分解并保留前 $ k $ 项，得到近似矩阵 $ I &#x3D; U \Sigma V^T \approx U_n \Sigma_n V_n^T $</li>
<li>$ y \approx U_n (\Sigma_n V_n^T) (D^T D)^{-1} D^T x $<ul>
<li>let $ M_n &#x3D; (\Sigma_n V_n^T) (D^T D)^{-1} D^T $</li>
</ul>
</li>
<li>存储 $ U_n $ 和 $ M_n $</li>
</ul>
</li>
<li>运行时：<ul>
<li>用 G-Buffer 得到 $ \mathcal{X}_D $ 空间上的各 $ L_d({\bf i}, {\bf x}; t) $ 的值</li>
<li>计算 $ y &#x3D; U_n M_n x $ 的值</li>
</ul>
</li>
</ul>
<h3 id="估计光传输矩阵"><a href="#估计光传输矩阵" class="headerlink" title="估计光传输矩阵"></a>估计光传输矩阵</h3><p>给定<strong>环境光</strong>条件 $ t \in \mathcal T $，那么在物体表面 $ {\bf x} $ 处，<strong>漫反射</strong>光传输方程的形式如下</p>
$$
L_i({\bf x}; t) = \frac{1}{2 \pi}\int_{\mathcal{H}^2} L_d({\bf i}, {\bf x}; t) V({\bf i}, {\bf x}) \max(0, {\bf n} \cdot {\bf i}) d {\bf i}
$$

<p>其中，$ L_i({\bf x}; t) $ 被称为间接光， $ L_d({\bf i}, {\bf x}; t) $ 被称为直接光</p>
<blockquote>
<p>$ L_d({\bf i}, {\bf x}; t) $ 不考虑环境和物体 inter-reflection; 推导中可以先忽略，虽然实际上对于有 inter-transmission 的情况应该也是可以应用的</p>
</blockquote>
<p>现在将 $ {\bf x} $ 和 $ i \times t $ 所在空间分别做一离散化，得到 $ \mathcal{X}_D $ 和 $ \mathcal{T}_D $ 两有限维空间，那么在这两个空间上， $ L_d $ 和 $ L_i $ 都可以表示为矩阵形式，这里规定每一列的元素在同一个环境光条件 $ {\bf i}, t $ 上。</p>
<blockquote>
<p>比如说，都在环境光为某点光源照射的情况； $ L_d({\bf i}, {\bf x}; t) $ 的 $ {\bf i} $ 一般意义上是依赖 $ t $ 的</p>
</blockquote>
<p>记得到的两个矩阵为 $ D $ 和 $ I $，则</p>
$$
I_k = f(D_k) \quad \forall k \in [0, |\mathcal{T}_D|]
$$

<p>从前面可以看到，这里的 $f$ 是线性算子 (<em>是嘛？</em>)，所以</p>
$$
I = MD
$$

<p>又假设我们离散 $ \mathcal T $ 空间离散的很好，那么对任意的环境光条件，<strong>直接光向量</strong> $ x $ 都可以表示成 $ D $ 的线性组合，满足</p>
$$
x = Dc
$$

<p>左右乘 $ M $ 得到</p>
$$
Mx = MDc = Ic
$$

<p>也就是说 $x$ 产生的间接光照可以用 $I$ 中列向量的线性组合来表示</p>
<p>因为 $ x &#x3D; Dc $，假设 $ D^T D $ 可逆，那么用左逆得到</p>
$$
c = (D^T D)^{-1} D^T x
$$

<p>那么</p>
$$
y = Mx = Ic = I (D^T D)^{-1} D^T x
$$

<p>这样就给出了<strong>任意直接光经过光传输</strong>的结果</p>
<h3 id="间接光基函数"><a href="#间接光基函数" class="headerlink" title="间接光基函数"></a>间接光基函数</h3><p>我们认为，间接光所对应的空间的秩比较低，所以用 SVD 分解然后保留前 $ n $ 项</p>
$$
I = U \Sigma V^T \approx U_n \Sigma_n V_n^T = U_n C_n
$$

<p>其中记 $ C_n &#x3D; \Sigma_n V_n^T $</p>
<p>带回去，得到任意直接光组合经过光传输方程的近似结果</p>
$$
\begin{aligned}
y &\approx U_n C_n (D^T D)^{-1} D^T x \\
&\approx U_n M_n x
\end{aligned}
$$

<p>其中 $ M_n &#x3D; C_n (D^T D)^{-1} D^T $</p>
<h3 id="直接光编码"><a href="#直接光编码" class="headerlink" title="直接光编码"></a>直接光编码</h3><p>如果有需要的话，可以考虑 SH 基函数，详见文章</p>
<h2 id="对比经典-PRT"><a href="#对比经典-PRT" class="headerlink" title="对比经典 PRT"></a>对比经典 PRT</h2><p>First, because classical PRT restricts the frequency content of the incoming lighting, we can see that the directional light leaks behind the object. Our method <strong>does not restrict the frequency content of incoming light</strong> but rather <strong>the space of possible indirect illumination</strong>.  Hence, we can better reproduce such lighting scenario. </p>
<p>Furthermore, classical PRT is performed on the vertices of the asset. This can cause interpolation artifacts when the asset is poorly tessellated, and it also links performance to the vertex count. Since we rely on a <strong>meshless approach</strong>, we are free of issues.</p>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p><strong>Sparse Illumination Measurement</strong>. As shown in Section 3.3, the sampling of the measurement points is linked to the achievable lighting dimensionality. Thus, it needs to be sufficiently dense to reproduce the space of observable lighting configurations. It follows that a lighting scenario mixing many light types might require a denser sampling. </p>
<p><strong>No Directionality</strong>. We reconstruct a diffuse appearance when reconstructing indirect illumination. However, since our method does not depend on the encoding of the measured indirect illumination, it can be extended to reconstruct glossy appearances e.g. directional distributions using directional sampling or any basis such as Spherical Harmonics. However, our method is likely to be restricted to low frequency gloss here and will not work to render specular reflections. </p>
<p><strong>Large Assets</strong>. Our solution is not designed to handle assets such as levels in a game. Because we handle light transport globally and reduce it with a handful of basis functions, we cannot reconstruct the interconnected interiors or large environments in which the combinatorics of possible illumination is large. For such case, our method would require to be extended to handle modular transfer between disjoint transport solutions (Similar to Loos et al. [2011]).</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <article id="paper-reading-paper-reading/continuous-mis" class="article article-type-paper-reading" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/paper-reading/continuous-mis/"><strong>论文阅读 | 连续多重重要性采样</strong></a>
      <small class=article-date-index>&nbsp; 2022-11-05</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/paper-reading/continuous-mis/" class="article-date">
  <time datetime="2022-11-04T16:00:00.000Z" itemprop="datePublished">2022-11-05</time>
</a>-->
      <!--
-->
      <!--
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本篇文章扩展了 Veach 在 1995 年提出的、用于 Monte Carlo 多重重要性采样 (Multiple Importance Sampling)，将其推广到了具有<strong>无限</strong>的<strong>连续</strong>采样策略的情况。</p>
<h2 id="多重重要性采样-MIS"><a href="#多重重要性采样-MIS" class="headerlink" title="多重重要性采样 (MIS)"></a>多重重要性采样 (MIS)</h2><blockquote>
<p>本方法比较详细的讨论可以参考 <em>Optimally Combining Sampling Techniques<br>for Monte Carlo Rendering</em> 这篇 SIGGRAPH’95 的论文，是 Veach 和 Guibas 很高引用的文章之一。</p>
<p>也可以参考 <a target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling">Importance Sampling | PBR Book 3rd</a>，不过里面没有证明。</p>
</blockquote>
<p>对于积分</p>
$$
I = \int_\Omega f(x) dx
$$

<p>我们希望用 Monte Carlo 采样的方法进行积分值的估计。</p>
<p>多重重要性采样 (Multiple Importance Sampling, MIS) 的大致思路如下：有 $ m $ 个采样策略，每个采样策略都可以对样本空间 $ \Omega $ 进行采样，并且每种策略都有概率密度函数 $ p_i(x) $。</p>
<p>对于 Multi-sample MIS，要分别使用每种采样策略<strong>独立</strong>采样 $ n_i $ 次，获得总计 $ \sum_{i&#x3D;1}^{m} n_i $ 个采样，然后使用如下的式子进行积分的估计：</p>
$$
\langle I \rangle_{mis} = \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})}
$$

<p>其中 $ x_{i, j} $ 表示第 $ i $ 个采样策略第 $ j $ 次采样获得的值，$ w_i(x) $ 为 $ m $ 个与 MIS 相关的权重函数。</p>
<p>首先可以证明，这 $ m $ 个权重函数只要满足 $ \sum_{i&#x3D;1}^m w_i(x) &#x3D; 1 $，那么 $ \langle I \rangle_{mis} $ 就是无偏的：</p>
$$
\begin{aligned}
\operatorname{E}[\langle I \rangle_{mis}] &= \operatorname{E}\left[ \sum_{i=1}^m \frac{1}{n_i} \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\
&= \sum_{i=1}^m \frac{1}{n_i} \operatorname{E}\left[ \sum_{j=1}^{n_i} \frac{w_i(x_{i,j}) f(x_{i, j})}{p_i(x_{i,j})} \right] \\
&= \sum_{i=1}^m \operatorname{E}\left[ \frac{w_i(x_{i,1}) f(x_{i, 1})}{p_i(x_{i,1})} \right] \quad (\because \text{i.i.d})\\
&= \sum_{i=1}^m \int_\Omega \frac{w_i(x) f(x)}{p_i(x)} p_i(x) dx \\
&= \sum_{i=1}^m \int_\Omega w_i(x) f(x) dx \\
&= \int_\Omega \sum_{i=1}^m w_i(x) f(x) dx \\
&= \int_\Omega f(x) dx \\
&= I
\end{aligned}
$$

<p>那么，哪样的权重会让估计量的方差比较小呢？Veach 和 Guibas 在其论文中，给出了被称为 <strong>Balance Heuristic</strong> 的估计量：</p>
$$
\hat w_i (x) = \frac{c_i p_i(x)}{\sum_{j=1}^m c_j p_j(x)} \quad \text{where}\ c_i = n_i / \sum_{j=1}^{m} n_j 
$$

<p>并且他们证明了，使用 $ { \hat w_i(x) }<em>{i&#x3D;1}^m $ 作为权重函数构造的估计量 $ \langle \hat I</em>{mis} \rangle $ 和<strong>任意的</strong>权重函数构造的估计量 $ \langle I_{mis} \rangle $ 的方差满足下面的关系：</p>
$$
\operatorname{V}[\langle \hat I \rangle_{mis}] \le \operatorname{V}[\langle I \rangle_{mis}] + \left( \frac{1}{\min_i n_i} - \frac{1}{\sum_i n_i} \right) I^2 
$$

<p>这其实在说，Balance Heuristic 从渐进意义上来说是方差比较低的估计。</p>
<p>有的时候，我们只希望采样一次。这种情况下，我们可以首先以 $P(t&#x3D;i)$ 的概率去采样我们将要使用的采样方法 $t$，然后再使用 MIS 积分估计量：</p>
$$
\langle I \rangle_{mis} = \frac{w_t(x_{t,1}) f(x_{t,1})}{p_t(x_{t,1}) P(t=i)}
$$

<p>其中 $ p_t(x_{t,1}) $ 表示采样方法为 $ t $ 情况下抽样到 $ x_{t,1} $ 的条件概率。</p>
<p>Veach 的论文中证明，Balance Heuristic 在任何 One-sample MIS 的情形下都是最优的权重组合。</p>
<h2 id="连续多重重要性采样-Continuous-MIS"><a href="#连续多重重要性采样-Continuous-MIS" class="headerlink" title="连续多重重要性采样 (Continuous MIS)"></a>连续多重重要性采样 (Continuous MIS)</h2><p>West 等人将上面的工作进行了进一步的推广：如果现在有连续的无限多种采样策略，那么也可以将 MIS 中的估计量进行推广，得到<strong>连续多重重要性采样</strong> (Continuous Multiple Importance Sampling, CMIS)。</p>
<p>定义采样方法空间 $ \mathcal{T} $，在其上的每个元素 $ t \in \mathcal{T} $ 都是一种采样策略。</p>
<p>那么自然可以想到，将 $ w_i(x) $ 推广为一个 $ \mathcal{T} \times \mathcal{X} \to \mathrm{R} $ 的函数 $ w(t, x) $，归一化条件 $ \sum_i w_i(x) &#x3D; 1 $ 推广为 $ \int_\mathcal{T} w(t, x) dt &#x3D; 1 $。</p>
<p>类似的，可以定义 One-sample CMIS 积分估计量</p>
$$
\langle I \rangle_{CMIS} = \frac{w(t, x)f(x)}{p(t, x)} = \frac{w(t, x)f(x)}{p(t) p(x|t)}
$$

<p>其中 $ p(t) $ 是选择策略 $ t $ 的概率密度， $ p(x|t) $ 是在策略 $ t $ 下采样得到 $ x $ 的条件概率。</p>
<p>同时，只要满足如下两个条件，上面的估计量就是无偏的：</p>
<ol>
<li>$ \int_\mathcal{T} w(t, x) dt = 1 $ 对任何 $ x \in \operatorname{supp} f(x) $ 成立</li>
<li>当 $ p(t, x) &#x3D; 0 $ 时，$ w(t, x) &#x3D; 0 $ <blockquote>
<p>为什么？</p>
</blockquote>
</li>
</ol>
<p>类比 MIS，CMIS 也可以定义 Balance Heuristic 如下：</p>
$$
\bar w(t, x) = \frac{p(t)p(x|t)}{\int_\mathcal{T} p(t') p(x|t') dt'} = \frac{p(t, x)}{\int_\mathcal{T} p(t', x)dt} = \frac{p(t, x)}{p(x)}
$$

<blockquote>
<p>那么其实可以看到，用 Balance Heristic 的 $ w(t, x) $ 带入到 $ \langle I \rangle_{CMIS} $ 之后，其实就会化简成为 $ f(x) &#x2F; p(x) $，只不过这里的 $ p(x) $ 是 $ p(t, x) $ 的边缘分布。</p>
</blockquote>
<h2 id="随机多重重要性采样-Stochastic-MIS"><a href="#随机多重重要性采样-Stochastic-MIS" class="headerlink" title="随机多重重要性采样 (Stochastic MIS)"></a>随机多重重要性采样 (Stochastic MIS)</h2><p>前面的方法会面临一个问题，有的时候 $ p(x) &#x3D; \int_\mathcal{T} p(t’, x)dt $ 是没有闭式解的，这样去算 $ \bar w(t, x) $ 的时候会遇到问题。所以，West 等人又提出了随机多重重要性采样 (Stochastic MIS, SMIS)。</p>
<p>SMIS 首先假设在 $ \mathcal{T} \times \mathcal{X} $ 中独立的采样 $ (t_1, x_1), …, (t_n, x_n) $ 共 $n$ 组点。</p>
<blockquote>
<p>TODO: implement me</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="Path-Reuse"><a href="#Path-Reuse" class="headerlink" title="Path Reuse"></a>Path Reuse</h4><h4 id="Spectral-Rendering"><a href="#Spectral-Rendering" class="headerlink" title="Spectral Rendering"></a>Spectral Rendering</h4><h4 id="Volume-Single-Scattering"><a href="#Volume-Single-Scattering" class="headerlink" title="Volume Single Scattering"></a>Volume Single Scattering</h4>
      
    </div>
	
    <!--
	
    -->
    <!--
    
    -->
  </div>
  
</article>



    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next »</a>
      </nav>
    

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Libre Liu&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true,
    },
    options: {
    renderActions: {
      findScript: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>
